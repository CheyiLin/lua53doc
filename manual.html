<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<head>
<title>Lua 5.3 參考手冊</title>
<link rel="stylesheet" type="text/css" href="lua.css">
<link rel="stylesheet" type="text/css" href="manual.css">
<META HTTP-EQUIV="content-type" CONTENT="text/html; charset=utf-8">
</head>

<body>

<hr>
<h1>
<a href="http://www.lua.org/"><img src="logo.gif" alt="" border="0"></a>
Lua 5.3 參考手冊
</h1>

作者 Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes
<p>
譯者 <a href="http://blog.codingnow.com">雲風</a>
<p>
<small>
Lua.org, PUC-Rio 版權所有 &copy; 2015 ，
在遵循
<A HREF="http://www.lua.org/license.html">Lua license</A>
條款下，可自由使用。
</small>
<hr>
<p>

<a href="contents.html#contents">目錄</A>
&middot;
<a href="contents.html#index">索引</A>
&middot;
<A HREF="term.html">中英術語對照表</A>

<!-- ====================================================================== -->
<p>

<!-- $Id: manual.of,v 1.146 2015/01/06 11:23:01 roberto Exp $ -->




<h1>1 &ndash; <a name="1">簡介</a></h1>

<p>
Lua 是一門擴展式程序設計語言，被設計成支持通用過程式編程，並有相關數據描述設施。
同時對面向對像編程、函數式編程和數據驅動式編程也提供了良好的支持。
它作為一個強大、輕量的嵌入式腳本語言，可供任何需要的程序使用。
Lua 由 <em>clean C（標準 C 和 C++ 間共通的子集）</em> 實現成一個庫。


<p>
作為一門擴展式語言，Lua 沒有 "main" 程序的概念：
它只能 <em>嵌入</em> 一個宿主程序中工作，
該宿主程序被稱為 <em>被嵌入程序</em> 或者簡稱 <em>宿主</em> 。 
宿主程序可以調用函式執行一小段 Lua 代碼，可以讀寫 Lua 變量，可以註冊 C 函式讓 Lua 代碼調用。
依靠 C 函式，Lua 可以共享相同的語法框架來定制編程語言，從而適用不同的領域。
Lua 的官方發佈版包含一個叫做 <code>lua</code> 的宿主程序示例，
它是一個利用 Lua 庫實現的完整獨立的 Lua 解釋器，可用於交互式應用或批處理。


<p>
Lua 是一個自由軟件，其使用許可證決定了它的使用過程無需任何擔保。
本手冊所描述的實現可以在 Lua 的官方網站 <code>www.lua.org</code> 找到。


<p>
與其它的許多參考手冊一樣，這份文檔有些地方比較枯燥。
關於 Lua 背後的設計思想，
可以看看 Lua 網站上提供的技術論文。
至於用 Lua 編程的細節介紹，
請參閱 Roberto 的書，<em>Programming in Lua</em>。

<h1>2 &ndash; <a name="2">基本概念</a></h1>

<p>
本章描述了語言的基本概念。



<h2>2.1 &ndash; <a name="2.1">值與型別</a></h2>

<p>
Lua 是一門<em>動態型別語言</em>。
這意味著變量沒有型別；只有值才有型別。
語言中不設型別定義。
所有的值攜帶自己的型別。


<p>
Lua 中所有的值都是 <em>一等公民</em>。
這意味著所有的值均可保存在變量中、
當作參數傳遞給其它函式、以及作為返回值。


<p>
Lua 中有八種基本型別：
<em>nil</em>、<em>boolean</em>、<em>number</em>、<em>string</em>、<em>function</em>、<em>userdata</em>、
<em>thread</em> 和 <em>table</em>。
<em>Nil</em> 是值 <b>nil</b> 的型別，
其主要特徵就是和其它值區別開；通常用來表示一個有意義的值不存在時的狀態。
<em>Boolean</em> 是 <b>false</b> 與 <b>true</b> 兩個值的型別。
<b>nil</b> 和 <b>false</b> 都會導致條件判斷為假；
而其它任何值都表示為真。
<em>Number</em> 代表了整數和實數（浮點數）。
<em>String</em> 表示一個不可變的字節序列。

Lua 對 8 位是友好的：
字串可以容納任意 8 位值，
其中包含零 ('<code>\0</code>') 。
Lua 的字串與編碼無關；
它不關心字串中具體內容。


<p>
<em>number</em> 型別有兩種內部表現方式，
 <em>整數</em> 和 <em>浮點數</em>。
對於何時使用哪種內部形式，Lua 有明確的規則，
但它也按需（參見 <a href="#3.4.3">&sect;3.4.3</a>）作自動轉換。
因此，程序員多數情況下可以選擇忽略整數與浮點數之間的差異或者假設完全控制每個數字的內部表現方式。
標準 Lua 使用 64 位整數和雙精度（64 位）浮點數，
但你也可以把 Lua 編譯成使用 32 位整數和單精度（32 位）浮點數。
以 32 位表示數字對小型機器以及嵌入式系統特別合適。
（參見 <code>luaconf.h</code> 文件中的宏 <code>LUA_32BITS</code> 。）


<p>
Lua 可以調用（以及操作）用 Lua 或 C （參見 <a href="#3.4.10">&sect;3.4.10</a>）編寫的函式。
這兩種函式有統一型別 <em>function</em>。


<p>
<em>userdata</em> 型別允許將 C 中的數據保存在 Lua 變量中。
用戶數據型別的值是一個記憶體塊，
有兩種用戶數據：
<em>完全用戶數據</em> ，指一塊由 Lua 管理的記憶體對應的對象；
<em>輕量用戶數據</em> ，則指一個簡單的 C 指針。
用戶數據在 Lua 中除了賦值與相等性判斷之外沒有其他預定義的操作。
通過使用 <em>元表</em> ，程序員可以給完全用戶數據定義一系列的操作
（參見 <a href="#2.4">&sect;2.4</a>）。
你只能通過 C API 而無法在 Lua 代碼中創建或者修改用戶數據的值，
這保證了數據僅被宿主程序所控制。


<p>
<em>thread</em> 型別表示了一個獨立的執行序列，被用於實現協程
（參見 <a href="#2.6">&sect;2.6</a>）。
Lua 的線程與操作系統的線程毫無關係。
Lua 為所有的系統，包括那些不支持原生線程的系統，提供了協程支持。


<p>
<em>table</em> 是一個關聯數組，
也就是說，這個數組不僅僅以數字做索引，除了 <b>nil</b> 和 NaN 之外的所有 Lua 值
都可以做索引。
（<em>Not a Number</em> 是一個特殊的數字，它用於表示未定義或表示不了的運算結果，比如 <code>0/0</code>。）
表可以是 <em>異構</em> 的；
也就是說，表內可以包含任何型別的值（ <b>nil</b> 除外）。
任何鍵的值若為 <b>nil</b> 就不會被記入表結構內部。
換言之，對於表內不存在的鍵，都對應著值 <b>nil</b> 。


<p>
表是 Lua 中唯一的數據結構，
它可被用於表示普通數組、序列、符號表、集合、記錄、圖、樹等等。
對於記錄，Lua 使用域名作為索引。
語言提供了 <code>a.name</code> 這樣的語法糖來替代
<code>a["name"]</code> 這種寫法以方便記錄這種結構的使用。
在 Lua 中有多種便利的方式創建表（參見 <a href="#3.4.9">&sect;3.4.9</a>）。


<p>
我們使用 <em>序列</em> 這個術語來表示一個用 {1..<em>n</em>} 的正整數集做索引的表。
這裡的非負整數 <em>n</em> 被稱為該序列的長度（參見 <a href="#3.4.7">&sect;3.4.7</a>）。


<p>
和索引一樣，表中每個域的值也可以是任何型別。
需要特別指出的是：既然函式是一等公民，那麼表的域也可以是函式。
這樣，表就可以攜帶 <em>方法</em> 了。
（參見 <a href="#3.4.11">&sect;3.4.11</a>）。


<p>
索引一張表的原則遵循語言中的直接比較規則。
當且僅當 <code>i</code> 與 <code>j</code>直接比較相等時
（即不通過元方法的比較），
表達式 <code>a[i]</code> 與 <code>a[j]</code>
表示了表中相同的元素。
特別指出：一個可以完全表示為整數的浮點數和對應的整數相等
（例如：<code>1.0 == 1</code>）。
為了消除歧義，當一個可以完全表示為整數的浮點數做為鍵值時，
都會被轉換為對應的整數儲存。
例如，當你寫 <code>a[2.0] = true</code> 時，
實際被插入表中的鍵是整數 <code>2</code> 。
（另一方面，2 與 "<code>2</code>" 是兩個不同的 Lua 值，
故而它們可以是同一張表中的不同項。）


<p>
表、函式、線程、以及完全用戶數據在 Lua 中被稱為 <em>對像</em>：
變量並不真的 <em>持有</em> 它們的值，而僅保存了對這些對象的 <em>引用</em>。
賦值、參數傳遞、函式返回，都是針對引用而不是針對值的操作，
這些操作均不會做任何形式的隱式拷貝。


<p>
庫函式 <a href="#pdf-type"><code>type</code></a> 用於以字串形式返回給定值的型別。
（參見 <a href="#6.1">&sect;6.1</a>）。




<h2>2.2 &ndash; <a name="2.2">環境與全局環境</a></h2>

<p>
後面在 <a href="#3.2">&sect;3.2</a> 以及 <a href="#3.3.3">&sect;3.3.3</a> 會討論，
引用一個叫 <code>var</code> 的自由名字（指在任何層級都未被聲明的名字）
在句法上都被翻譯為 <code>_ENV.var</code> 。
此外，每個被編譯的 Lua 代碼塊都會有一個額外的局部變量叫 <code>_ENV</code>
（參見 <a href="#3.3.2">&sect;3.3.2</a>），
因此，<code>_ENV</code> 這個名字永遠都不會成為一個代碼塊中的自由名字。


<p>
在轉譯那些自由名字時，<code>_ENV</code> 是否是那個額外的局部變量無所謂。
<code>_ENV</code> 和其它你可以使用的變量名沒有區別。
這裡特別指出，你可以定義一個新變量或指定一個參數叫這個名字。
當編譯器在轉譯自由名字時所用到的 <code>_ENV</code> ，
指的是你的程序在那個點上可見的那個名為 _ENV 的變量。
（Lua 的可見性規則參見 <a href="#3.5">&sect;3.5</a>）

<p>

被 <code>_ENV</code> 用於值的那張表被稱為 <em>環境</em>。


<p>
Lua 保有一個被稱為 <em>全局環境</em> 特別環境。它被保存在 C 註冊表
（參見 <a href="#4.5">&sect;4.5</a>）的一個特別索引下。
在 Lua 中，全局變量 <a href="#pdf-_G"><code>_G</code></a> 被初始化為這個值。
（<a href="#pdf-_G"><code>_G</code></a> 不被內部任何地方使用。）


<p>
當 Lua 加載一個代碼塊，<code>_ENV</code> 這個上值的默認值就是這個全局環境
（參見 <a href="#pdf-load"><code>load</code></a>）。
因此，在默認情況下，Lua 代碼中提及的自由名字都指的全局環境中的相關項
（因此，它們也被稱為 <em>全局變量</em> ）。
此外，所有的標準庫都被加載入全局環境，一些函式也針對這個環境做操作。
你可以用 <a href="#pdf-load"><code>load</code></a> （或 <a href="#pdf-loadfile"><code>loadfile</code></a>）加載代碼塊，並賦予它們不同的環境。
（在 C 裡，當你加載一個代碼塊後，可以通過改變它的第一個上值來改變它的環境。）




<h2>2.3 &ndash; <a name="2.3">錯誤處理</a></h2>

<p>
Lua 作為一門嵌入式語言，
所有的 Lua 行為都始於宿主程序的 C 代碼中對於 Lua 庫裡某函式的一次調用。
（當你使用 Lua 獨立版本時，<code>lua</code> 程序就是那個宿主程序。）
在編譯或運行一個 Lua 代碼塊時，無論發生任何錯誤，
控制權都返還給宿主。接下來可以針對情況來採取恰當的措施
（比如打印錯誤消息）。


<p>
Lua 代碼中可以通過調用 <a href="#pdf-error"><code>error</code></a> 函式來顯式的拋出一個錯誤。
如果你需要在 Lua 中捕獲這些錯誤，
你可以使用 <a href="#pdf-pcall"><code>pcall</code></a> 或
<a href="#pdf-xpcall"><code>xpcall</code></a>
以 <em>保護模式</em> 來調用一個函式。


<p>
無論何時錯誤發生，都會產生一個攜帶有錯誤信息的 <em>錯誤對像</em> 
（也被稱為 <em>錯誤消息</em>）。
Lua 本身只會產生字串型別的錯誤對象，
但你的程序可以為一個錯誤拋出任何型別的錯誤對象。
這就看 Lua 程序或你的宿主如何處理這些錯誤對象了。

<p>
當你使用 <a href="#pdf-xpcall"><code>xpcall</code></a> 或
<a href="#lua_pcall"><code>lua_pcall</code></a> 時，
你應當給出一個 <em>消息處理器</em> 用於發生錯誤時的處理流程。
這個處理器函式會被傳入原始的錯誤消息，並應返回一個新的錯誤消息。
它在錯誤發生後堆疊尚未展開時調用，
因此它可以通過堆疊來收集更多的信息。
例如它可以通過探知堆疊來創建一組堆疊回溯信息。
這個處理器函式也被保護模式調用以保護；
因此在處理器函式內發生的錯誤會再次調用它。
如果遞歸調用太深，Lua 會打破遞歸並返回一個恰當的消息。



<h2>2.4 &ndash; <a name="2.4">元表及元方法</a></h2>

<p>
Lua 中的每個值都可以有一個 <em>元表</em>。
這個 <em>元表</em> 就是一個普通的 Lua 表，
它用於定義原始值在特定操作下的行為。
如果你想改變一個值在特定操作下的行為，你可以在它的元表中設置對應域。
例如，當你對非數字值做加操作時，
Lua 會檢查該值的元表中的 "<code>__add</code>" 域下的函式。
如果能找到，Lua 則調用這個函式來完成加這個操作。


<p>
元表中的鍵對應著不同的 <em>事件</em> 名；
鍵關聯的那些值被稱為 <em>元方法</em>。
在上面那個例子中引用的事件為 <code>"add"</code> ，
完成加操作的那個函式就是元方法。


<p>
你可以用 <a href="#pdf-getmetatable"><code>getmetatable</code></a> 函式
來獲取任何值的元表。


<p>
使用 <a href="#pdf-setmetatable"><code>setmetatable</code></a> 
來替換一張表的元表。在 Lua 中，你不可以改變表以外其它型別的值的元表
（除非你使用調試庫（參見<a href="#6.10">&sect;6.10</a>））；
若想改變這些非表型別的值的元表，請使用 C API。


<p>
表和完全用戶數據有獨立的元表
（當然，多個表和用戶數據可以共享同一個元表）。
其它型別的值按型別共享元表；
也就是說所有的數字都共享同一個元表，
所有的字串共享另一個元表等等。
默認情況下，值是沒有元表的，
但字串庫在初始化的時候為字串型別設置了元表
（參見 <a href="#6.4">&sect;6.4</a>）。


<p>
元表決定了一個對像在數學運算、位運算、比較、連接、
取長度、調用、索引時的行為。
元表還可以定義一個函式，當表對像或用戶數據對像在垃圾回收
（參見<a href="#2.5">&sect;2.5</a>）時調用它。


<p>
接下來會給出一張元表可以控制的事件的完整列表。
每個操作都用對應的事件名來區分。
每個事件的鍵名用加有 '<code>__</code>' 前綴的字串來表示；
例如 "add" 操作的鍵名為字串 "<code>__add</code>"。
注意、Lua 從元表中直接獲取元方法；
訪問元表中的元方法永遠不會觸發另一次元方法。
下面的代碼模擬了 Lua 從一個對像 <code>obj</code> 中獲取一個元方法的過程：

<pre>
     rawget(getmetatable(obj) or {}, "__" .. event_name)
</pre>

<p>
對於一元操作符（取負、求長度、位反），
元方法調用的時候，第二個參數是個啞元，其值等於第一個參數。
這樣處理僅僅是為了簡化 Lua 的內部實現
（這樣處理可以讓所有的操作都和二元操作一致），
這個行為有可能在將來的版本中移除。
（使用這個額外參數的行為都是不確定的。）


<ul>

<li><b>"add": </b>
<code>+</code> 操作。

如果任何不是數字的值（包括不能轉換為數字的字串）做加法，
Lua 就會嘗試調用元方法。
首先、Lua 檢查第一個操作數（即使它是合法的），
如果這個操作數沒有為 "<code>__add</code>" 事件定義元方法，
Lua 就會接著檢查第二個操作數。
一旦 Lua 找到了元方法，
它將把兩個操作數作為參數傳入元方法，
元方法的結果（調整為單個值）作為這個操作的結果。
如果找不到元方法，將拋出一個錯誤。
</li>

<li><b>"sub": </b>
<code>-</code> 操作。

行為和 "add" 操作類似。
</li>

<li><b>"mul": </b>
<code>*</code> 操作。

行為和 "add" 操作類似。
</li>

<li><b>"div": </b>
<code>/</code> 操作。

行為和 "add" 操作類似。
</li>

<li><b>"mod": </b>
<code>%</code> 操作。

行為和 "add" 操作類似。
</li>

<li><b>"pow": </b>
<code>^</code> （次方）操作。

行為和 "add" 操作類似。
</li>

<li><b>"unm": </b>
<code>-</code> （取負）操作。

行為和 "add" 操作類似。
</li>

<li><b>"idiv": </b>
<code>//</code> （向下取整除法）操作。

行為和 "add" 操作類似。
</li>

<li><b>"band": </b>
<code>&amp;</code> （按位與）操作。

行為和 "add" 操作類似，
不同的是 Lua 會在任何一個操作數無法轉換為整數時
（參見 <a href="#3.4.3">&sect;3.4.3</a>）嘗試取元方法。
</li>

<li><b>"bor": </b>
<code>|</code> （按位或）操作。

行為和 "band" 操作類似。
</li>

<li><b>"bxor": </b>
<code>~</code> （按位異或）操作。

行為和 "band" 操作類似。
</li>

<li><b>"bnot": </b>
<code>~</code> （按位非）操作。

行為和 "band" 操作類似。
</li>

<li><b>"shl": </b>
<code>&lt;&lt;</code> （左移）操作。

行為和 "band" 操作類似。
</li>

<li><b>"shr": </b>
<code>&gt;&gt;</code> （右移）操作。

行為和 "band" 操作類似。
</li>

<li><b>"concat": </b>
<code>..</code> （連接）操作。

行為和 "add" 操作類似，
不同的是 Lua 在任何操作數即不是一個字串
也不是數字（數字總能轉換為對應的字串）的情況下嘗試元方法。
</li>

<li><b>"len": </b>
<code>#</code> （取長度）操作。

如果對像不是字串，Lua 會嘗試它的元方法。
如果有元方法，則調用它並將對像以參數形式傳入，
而返回值（被調整為單個）則作為結果。
如果對象是一張表且沒有元方法，
Lua 使用表的取長度操作（參見 <a href="#3.4.7">&sect;3.4.7</a>）。
其它情況，均拋出錯誤。
</li>

<li><b>"eq": </b>
<code>==</code> （等於）操作。

和 "add" 操作行為類似，
不同的是 Lua 僅在兩個值都是表或都是完全用戶數據
且它們不是同一個對像時才嘗試元方法。
調用的結果總會被轉換為布爾量。
</li>

<li><b>"lt": </b>
<code>&lt;</code> （小於）操作。

和 "add" 操作行為類似，
不同的是 Lua 僅在兩個值不全為整數也不全為字串時才嘗試元方法。
調用的結果總會被轉換為布爾量。
</li>

<li><b>"le": </b>
<code>&lt;=</code> （小於等於）操作。

和其它操作不同，
小於等於操作可能用到兩個不同的事件。
首先，像 "lt" 操作的行為那樣，Lua 在兩個操作數中查找 "<code>__le</code>" 元方法。
如果一個元方法都找不到，就會再次查找 "<code>__lt</code>" 事件，
它會假設 <code>a &lt;= b</code> 等價於 <code>not (b &lt; a)</code>。
而其它比較操作符類似，其結果會被轉換為布爾量。
</li>

<li><b>"index": </b>
索引 <code>table[key]</code>。

當 <code>table</code> 不是表或是表 <code>table</code> 中不存在
<code>key</code> 這個鍵時，這個事件被觸發。
此時，會讀出 <code>table</code> 相應的元方法。

<p>
儘管名字取成這樣，
這個事件的元方法其實可以是一個函式也可以是一張表。
如果它是一個函式，則以 <code>table</code> 和 <code>key</code> 作為參數調用它。
如果它是一張表，最終的結果就是以 <code>key</code> 取索引這張表的結果。
（這個索引過程是走常規的流程，而不是直接索引，
所以這次索引有可能引發另一次元方法。）
</li>

<li><b>"newindex": </b>
索引賦值 <code>table[key] = value</code> 。

和索引事件類似，它發生在
<code>table</code> 不是表或是表 <code>table</code> 中不存在
<code>key</code> 這個鍵的時候。
此時，會讀出 <code>table</code> 相應的元方法。

<p>
同索引過程那樣，
這個事件的元方法即可以是函式，也可以是一張表。
如果是一個函式，
則以 <code>table</code>、 <code>key</code>、以及 <code>value</code> 為參數傳入。
如果是一張表，
Lua 對這張表做索引賦值操作。
（這個索引過程是走常規的流程，而不是直接索引賦值，
所以這次索引賦值有可能引發另一次元方法。）


<p>
一旦有了 "newindex" 元方法，
Lua 就不再做最初的賦值操作。
（如果有必要，在元方法內部可以調用 <a href="#pdf-rawset"><code>rawset</code></a>
來做賦值。）
</li>

<li><b>"call": </b>
函式調用操作 <code>func(args)</code>。

當 Lua 嘗試調用一個非函式的值的時候會觸發這個事件
（即 <code>func</code> 不是一個函式）。
查找 <code>func</code> 的元方法，
如果找得到，就調用這個元方法，
<code>func</code> 作為第一個參數傳入，原來調用的參數（<code>args</code>）後依次排在後面。
</li>

</ul>




<h2>2.5 &ndash; <a name="2.5">垃圾收集</a></h2>

<p>
Lua 採用了自動記憶體管理。
這意味著你不用操心新創建的對象需要的記憶體如何分配出來，
也不用考慮在對像不再被使用後怎樣釋放它們所佔用的記憶體。
Lua 運行了一個 <em>垃圾收集器</em> 來收集所有 <em>死對像</em>
（即在 Lua 中不可能再訪問到的對象）來完成自動記憶體管理的工作。
Lua 中所有用到的記憶體，如：字串、表、用戶數據、函式、線程、
內部結構等，都服從自動管理。


<p>
Lua 實現了一個增量標記-掃瞄收集器。
它使用這兩個數字來控制垃圾收集循環：
<em>垃圾收集器間歇率</em> 和 <em>垃圾收集器步進倍率</em>。
這兩個數字都使用百分數為單位
（例如：值 100 在內部表示 1 ）。


<p>
垃圾收集器間歇率控制著收集器需要在開啟新的循環前要等待多久。
增大這個值會減少收集器的積極性。
當這個值比 100 小的時候，收集器在開啟新的循環前不會有等待。
設置這個值為 200 就會讓收集器等到總記憶體使用量達到
之前的兩倍時才開始新的循環。


<p>
垃圾收集器步進倍率控制著收集器運作速度相對於記憶體分配速度的倍率。
增大這個值不僅會讓收集器更加積極，還會增加每個增量步驟的長度。
不要把這個值設得小於 100 ，
那樣的話收集器就工作的太慢了以至於永遠都幹不完一個循環。
默認值是 200 ，這表示收集器以記憶體分配的「兩倍」速工作。


<p>
如果你把步進倍率設為一個非常大的數字
（比你的程序可能用到的字節數還大 10% ），
收集器的行為就像一個 stop-the-world 收集器。
接著你若把間歇率設為 200 ，
收集器的行為就和過去的 Lua 版本一樣了：
每次 Lua 使用的記憶體翻倍時，就做一次完整的收集。



<p>
你可以通過在 C 中調用 <a href="#lua_gc"><code>lua_gc</code></a>
或在 Lua 中調用 <a href="#pdf-collectgarbage"><code>collectgarbage</code></a>
來改變這倆數字。
這兩個函式也可以用來直接控制收集器（例如停止它或重啟它）。


<h3>2.5.1 &ndash; <a name="2.5.1">垃圾收集元方法</a></h3>

<p>
你可以為表設定垃圾收集的元方法，
對於完全用戶數據（參見 <a href="#2.4">&sect;2.4</a>），
則需要使用 C API 。
該元方法被稱為 <em>終結器</em>。
終結器允許你配合 Lua 的垃圾收集器做一些額外的資源管理工作
（例如關閉文件、網絡或數據庫連接，或是釋放一些你自己的記憶體）。


<p>
如果要讓一個對像（表或用戶數據）在收集過程中進入終結流程，
你必須 <em>標記</em> 它需要觸發終結器。

當你為一個對像設置元表時，若此刻這張元表中用一個以字串
"<code>__gc</code>" 為索引的域，那麼就標記了這個對象需要觸發終結器。
注意：如果你給對像設置了一個沒有 <code>__gc</code>
域的元表，之後才給元表加上這個域，
那麼這個對象是沒有被標記成需要觸發終結器的。
然而，一旦對像被標記，
你還是可以自由的改變其元表中的 <code>__gc</code> 域的。


<p>
當一個被標記的對象成為了垃圾後，
垃圾收集器並不會立刻回收它。
取而代之的是，Lua 會將其置入一個鏈表。
在收集完成後，Lua 將遍歷這個鏈表。
Lua 會檢查每個鏈表中的對象的 <code>__gc</code>
元方法：如果是一個函式，那麼就以對像為唯一參數調用它；
否則直接忽略它。


<p>
在每次垃圾收集循環的最後階段，
本次循環中檢測到的需要被回收之對象，
其終結器的觸發次序按當初給對像作需要觸發終結器的標記之次序的逆序進行；
這就是說，第一個被調用的終結器是程序中最後一個被標記的對象所攜的那個。
每個終結器的運行可能發生在執行常規代碼過程中的任意一刻。


<p>
由於被回收的對象還需要被終結器使用，
該對像（以及僅能通過它訪問到的其它對像）一定會被 Lua <em>復活</em>。
通常，復活是短暫的，對像所屬記憶體會在下一個垃圾收集循環釋放。
然後，若終結器又將對像保存去一些全局的地方
（例如：放在一個全局變量裡），這次復活就持續生效了。
此外，如果在終結器中對一個正進入終結流程的對象再次做一次標記讓它觸發終結器，
只要這個對象在下個循環中依舊不可達，它的終結函式還會再調用一次。
無論是哪種情況，
對像所屬記憶體僅在垃圾收集循環中該對像不可達且
沒有被標記成需要觸發終結器才會被釋放。


<p>
當你關閉一個狀態機（參見 <a href="#lua_close"><code>lua_close</code></a>），
Lua 將調用所有被標記了需要觸發終結器對象的終結過程，
其次序為標記次序的逆序。
在這個過程中，任何終結器再次標記對象的行為都不會生效。





<h3>2.5.2 &ndash; <a name="2.5.2">弱表</a></h3>

<p>
<em>弱表</em> 指內部元素為 <em>弱引用</em> 的表。
垃圾收集器會忽略掉弱引用。
換句話說，如果一個對像只被弱引用引用到，
垃圾收集器就會回收這個對象。


<p>
一張弱表可以有弱鍵或是弱值，也可以鍵值都是弱引用。
僅含有弱鍵的表允許收集器回收它的鍵，但會阻止對值所指的對象被回收。
若一張表的鍵值均為弱引用，
那麼收集器可以回收其中的任意鍵和值。
任何情況下，只要鍵或值的任意一項被回收，
相關聯的鍵值對都會從表中移除。
一張表的元表中的 <code>__mode</code> 域控制著這張表的弱屬性。
當 <code>__mode</code> 域是一個包含字符 '<code>k</code>'
的字串時，這張表的所有鍵皆為弱引用。
當 <code>__mode</code> 域是一個包含字符 '<code>v</code>'
的字串時，這張表的所有值皆為弱引用。


<p>
屬性為弱鍵強值的表也被稱為 <em>暫時表</em>。
對於一張暫時表，
它的值是否可達僅取決於其對應鍵是否可達。
特別注意，如果表內的一個鍵僅僅被其值所關聯引用，
這個鍵值對將被表內移除。


<p>
對一張表的弱屬性的修改僅在下次收集循環才生效。
尤其是當你把表由弱改強，Lua 還是有可能在修改生效前回收表內一些項目。


<p>
只有那些有顯式構造過程的對象才會從弱表中移除。
值，例如數字和輕量 C 函式，不受垃圾收集器管轄，
因此不會從弱表中移除
（除非它們的關聯項被回收）。
雖然字串受垃圾回收器管轄，
但它們沒有顯式的構造過程，所以也不會從弱表中移除。


<p>
弱表針對復活的對象
（指那些正在走終結流程，僅能被終結器訪問的對象）
有著特殊的行為。
弱值引用的對象，在運行它們的終結器前就被移除了，
而弱鍵引用的對象則要等到終結器運行完畢後，到下次收集當對像真的被釋放時才被移除。
這個行為使得終結器運行時得以訪問到由該對像在弱表中所關聯的屬性。


<p>
如果一張弱表在當次收集循環內的復活對像中，
那麼在下個循環前這張表有可能未被正確地清理。






<h2>2.6 &ndash; <a name="2.6">協程</a></h2>

<p>
Lua 支持協程，同時它也被稱為 <em>協同式多線程</em>。
Lua 為每個協程提供一個獨立的運行序。
然而和多線程系統中的線程不同，
協程僅在顯式地調用一個讓出函式時才掛起當前的執行狀態。


<p>
通過調用
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>
可創建一個協程。
它唯一的參數是一個函式，這個函式將作為這個協程的主函式。
<code>create</code> 函式僅僅創建出這個協程然後返回它的句柄
（一個型別為 <em>thread</em> 的對象）；
它並不運行該協程。


<p>
通過調用
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
可執行一個協程。
第一次調用
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
時，第一個參數應傳入
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a>
返回的線程對象，這樣協程就會從其主函式的第一行開始執行。
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
後面的參數將作為主函式的參數傳入。
協程將一直運行到它結束或 <em>讓出</em>。


<p>
協程的運行可能被兩種方式終止：
正常途徑是主函式返回
（顯式返回或運行完最後一條指令）；
非正常途徑是發生了一個未被捕獲的錯誤。
對於正常結束，
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 將返回 <b>true</b>，
並接上協程主函式的返回值。
當錯誤發生時，
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 將返回 <b>false</b>
與錯誤消息。


<p>
讓出協程的執行通過調用
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 完成。
當協程讓出，
即使讓出發生在內嵌函式調用中
（即不在主函式，但在主函式直接或間接調用的函式內部），
之前對該協程調用的 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 會立刻返回。
在讓出的情況下，
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 依舊返回 <b>true</b>，
接下來的返回值是傳給
<a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a> 的那些參數。
當下一次你延續同一個協程時，
協程會接在讓出點繼續運行。
調用 <a href="#pdf-coroutine.yield"><code>coroutine.yield</code></a>
的讓出點會返回傳給
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
的額外參數。


<p>
就像
<a href="#pdf-coroutine.create"><code>coroutine.create</code></a> 那樣，
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a> 函式也會創建一個協程。
不同的是，它不返回協程本身，而是返回一個函式。
調用這個函式將延續這個協程。
為這個函式提供的參數相當於
傳給 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 的額外參數。
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
的返回值是
<a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a>
的返回值中除去第一個返回值（布爾型的錯誤碼）剩餘的部分。
和 <a href="#pdf-coroutine.resume"><code>coroutine.resume</code></a> 不同，
<a href="#pdf-coroutine.wrap"><code>coroutine.wrap</code></a>
不會捕獲錯誤；
錯誤會傳播給調用者。


<p>
下面的代碼展示了一個協程工作的範例：

<pre>
     function foo (a)
       print("foo", a)
       return coroutine.yield(2*a)
     end
     
     co = coroutine.create(function (a,b)
           print("co-body", a, b)
           local r = foo(a+1)
           print("co-body", r)
           local r, s = coroutine.yield(a+b, a-b)
           print("co-body", r, s)
           return b, "end"
     end)
     
     print("main", coroutine.resume(co, 1, 10))
     print("main", coroutine.resume(co, "r"))
     print("main", coroutine.resume(co, "x", "y"))
     print("main", coroutine.resume(co, "x", "y"))
</pre><p>
當你運行它，將產生下列輸出：

<pre>
     co-body 1       10
     foo     2
     main    true    4
     co-body r
     main    true    11      -9
     co-body x       y
     main    true    10      end
     main    false   cannot resume dead coroutine
</pre>

<p>
你也可以通過 C API 來創建及操作協程：
參見函式
<a href="#lua_newthread"><code>lua_newthread</code></a>，
<a href="#lua_resume"><code>lua_resume</code></a>，
以及 <a href="#lua_yield"><code>lua_yield</code></a>。





<h1>3 &ndash; <a name="3">語言定義</a></h1>

<p>
這一章描述了 Lua 的詞法、語法和句法。
換句話說，本章描述哪些符記是有效的，
它們如何被組合起來，這些組合方式有什麼含義。


<p>
關於語言的構成概念將用常見的擴展 BNF 表達式寫出。
也就是這個樣子：
{<em>a</em>} 表示 0 或多個 <em>a</em>，
[<em>a</em>] 表示一個可選的 <em>a</em>。

可以被分解的非最終符號會這樣寫 non-terminal ，
關鍵字會寫成這樣 <b>kword</b>，
而其它不能被分解的最終符號則寫成這樣 &lsquo;<b>=</b>&rsquo; 。
完整的 Lua 語法可以在本手冊最後一章 <a href="#9">&sect;9</a> 找到。



<h2>3.1 &ndash; <a name="3.1">詞法約定</a></h2>

<p>
Lua 語言的格式自由。
它會忽略語法元素（符記）間的空格（包括換行）和註釋，
僅把它們看作為名字和關鍵字間的分割符。


<p>
Lua 中的 <em>名字</em>
（也被稱為 <em>標識符</em>）
可以是由非數字打頭的任意字母下劃線和數字構成的字串。
標識符可用於對變量、表的域、以及標籤命名。


<p>
下列 <em>關鍵字</em> 是保留的，不可用於名字：


<pre>
     and       break     do        else      elseif    end
     false     for       function  goto      if        in
     local     nil       not       or        repeat    return
     then      true      until     while
</pre>

<p>
Lua 語言對大小寫敏感：
<code>and</code> 是一個保留字，但 <code>And</code> 與 <code>AND</code>
則是兩個不同的有效名字。
作為一個約定，程序應避免創建以下劃線加一個或多個大寫字母構成的名字
（例如 <a href="#pdf-_VERSION"><code>_VERSION</code></a>）。


<p>
下列字串是另外一些符記：

<pre>
     +     -     *     /     %     ^     #
     &amp;     ~     |     &lt;&lt;    &gt;&gt;    //
     ==    ~=    &lt;=    &gt;=    &lt;     &gt;     =
     (     )     {     }     [     ]     ::
     ;     :     ,     .     ..    ...
</pre>

<p>
<em>字面串</em> 可以用單引號或雙引號括起。
字面串內部可以包含下列 C 風格的轉義串： 
'<code>\a</code>' （響鈴），
'<code>\b</code>' （退格），
'<code>\f</code>' （換頁），
'<code>\n</code>' （換行），
'<code>\r</code>' （回車），
'<code>\t</code>' （橫項製表），
'<code>\v</code>' （縱向製表），
'<code>\\</code>' （反斜槓），
'<code>\"</code>' （雙引號），
以及 '<code>\'</code>' (單引號)。
在反斜槓後跟一個真正的換行等價於在字串中寫一個換行符。
轉義串 '<code>\z</code>' 會忽略其後的一系列空白符，包括換行；
它在你需要對一個很長的字串常量斷行為多行並希望在每個新行保持縮進時非常有用。



<p>
Lua 中的字串可以保存任意 8 位值，其中包括用 '<code>\0</code>' 表示的 0 。
一般而言，你可以用字符的數字值來表示這個字符。
方式是用轉義串 <code>\x<em>XX</em></code>，
此處的 <em>XX</em> 必須是恰好兩個字符的 16 進制數。
或者你也可以使用轉義串 <code>\<em>ddd</em></code> ，
這裡的 <em>ddd</em> 是一到三個十進制數字。
（注意，如果在轉義符後接著恰巧是一個數字符號的話，
你就必須在這個轉義形式中寫滿三個數字。）


<p>
對於用 UTF-8 編碼的 Unicode 字符，你可以用
轉義符 <code>\u{<em>XXX</em>}</code> 來表示
（這裡必須有一對花括號），
此處的 <em>XXX</em> 是用 16 進製表示的字符編號。


<p>
字面串還可以用一種 <em>長括號</em> 括起來的方式定義。
我們把兩個正的方括號間插入 <em>n</em> 個等號定義為 <em>第 <em>n</em> 級開長括號</em>。
就是說，0 級開的長括號寫作 <code>[[</code> ， 一級開長括號寫作 <code>[=[</code> ，
如此等等。
<em>閉長括號</em>也作類似定義； 
舉個例子，4 級反的長括號寫作 <code>]====]</code> 。
一個 <em>長字面串</em> 可以由任何一級的開長括號開始，而由第一個碰到的同級的閉長括號結束。
這種方式描述的字串可以包含任何東西，當然特定級別的反長括號除外。
整個詞法分析過程將不受分行限制，不處理任何轉義符，並且忽略掉任何不同級別的長括號。 
其中碰到的任何形式的換行串（回車、換行、回車加換行、換行加回車），都會被轉換為單個換行符。


<p>
字面串中的每個不被上述規則影響的字節都呈現為本身。
然而，Lua 是用文本模式打開源文件解析的，
一些系統的文件操作函式對某些控制字符的處理可能有問題。
因此，對於非文本數據，用引號括起來並顯式按轉義符規則來表述更安全。


<p>
為了方便起見，
當一個開長括號後緊接一個換行符時，
這個換行符不會放在字串內。
舉個例子，假設一個系統使用 ASCII 碼
（此時 '<code>a</code>' 編碼為 97 ，
換行編碼為 10 ，'<code>1</code>' 編碼為 49 ），
下面五種方式描述了完全相同的字串：

<pre>
     a = 'alo\n123"'
     a = "alo\n123\""
     a = '\97lo\10\04923"'
     a = [[alo
     123"]]
     a = [==[
     alo
     123"]==]
</pre>

<p>
<em>數字常量</em> （或稱為 <em>數字量</em>）
可以由可選的小數部分和可選的十為底的指數部分構成，
指數部分用字符 '<code>e</code>' 或 '<code>E</code>' 來標記。
Lua 也接受以 <code>0x</code> 或 <code>0X</code> 開頭的 16 進制常量。
16 進制常量也接受小數加指數部分的形式，指數部分是以二為底，
用字符 '<code>p</code>' 或 '<code>P</code>' 來標記。
數字常量中包含小數點或指數部分時，被認為是一個浮點數；
否則被認為是一個整數。
下面有一些合法的整數常量的例子：
<pre>
     3   345   0xff   0xBEBADA
</pre><p>
以下為合法的浮點常量：
<pre>
     3.0     3.1416     314.16e-2     0.31416E1     34e1
     0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
</pre>

<p>
在字串外的任何地方出現以雙橫線 (<code>--</code>) 開頭的部分是 <em>註釋</em> 。
如果 <code>--</code> 後沒有緊跟著一個開大括號，
該註釋為 <em>短註釋</em>，
註釋到當前行末截至。
否則，這是一段 <em>長註釋</em> ，
註釋區一直維持到對應的閉長括號。
長註釋通常用於臨時屏蔽掉一大段代碼。



<h2>3.2 &ndash; <a name="3.2">變量</a></h2>

<p>
變量是儲存值的地方。
Lua 中有三種變量：
全局變量、局部變量和表的域。


<p>
單個名字可以指代一個全局變量也可以指代一個局部變量
（或者是一個函式的形參，這是一種特殊形式的局部變量）。

<pre>
	var ::= Name
</pre><p>
名字指 <a href="#3.1">&sect;3.1</a> 中定義的標識符。


<p>
所有沒有顯式聲明為局部變量（參見 <a href="#3.3.7">&sect;3.3.7</a>）
的變量名都被當做全局變量。
局部變量有其 <em>作用範圍</em> ：
局部變量可以被定義在它作用範圍中的函式自由使用（參見
<a href="#3.5">&sect;3.5</a>）。


<p>
在變量的首次賦值之前，變量的值均為 <b>nil</b>。


<p>
方括號被用來對表作索引：

<pre>
	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
</pre><p>
對全局變量以及表的域之訪問的含義可以通過元表來改變。 
以索引方式訪問一個變量 <code>t[i]</code> 等價於
調用 <code>gettable_event(t,i)</code>。
（參見 <a href="#2.4">&sect;2.4</a> ，有一份完整的關於
<code>gettable_event</code> 函式的說明。
這個函式並沒有在 lua 中定義出來，也不能在 lua 中調用。這裡我們把提到它只是方便說明問題。）


<p>
<code>var.Name</code> 這種語法只是一個語法糖，用來表示
<code>var["Name"]</code>：

<pre>
	var ::= prefixexp &lsquo;<b>.</b>&rsquo; Name
</pre>

<p>
對全局變量 <code>x</code> 的操作等價於操作
<code>_ENV.x</code>。
由於代碼塊編譯的方式，
<code>_ENV</code> 永遠也不可能是一個全局名字 （參見 <a href="#2.2">&sect;2.2</a>）。





<h2>3.3 &ndash; <a name="3.3">語句</a></h2>

<p>
Lua 支持所有與 Pascal 或是 C 類似的常見形式的語句，
這個集合包括賦值，控制結構，函式調用，還有變量聲明。



<h3>3.3.1 &ndash; <a name="3.3.1">語句塊</a></h3>

<p>
語句塊是一個語句序列，它們會按次序執行：

<pre>
	block ::= {stat}
</pre><p>
Lua 支持 <em>空語句</em>，
你可以用分號分割語句，也可以以分號開始一個語句塊，
或是連著寫兩個分號：

<pre>
	stat ::= &lsquo;<b>;</b>&rsquo;
</pre>

<p>
函式調用和賦值語句都可能以一個小括號打頭，
這可能讓 Lua 的語法產生歧義。
我們來看看下面的代碼片斷：

<pre>
     a = b + c
     (print or io.write)('done')
</pre><p>
從語法上說，可能有兩種解釋方式：

<pre>
     a = b + c(print or io.write)('done')
     
     a = b + c; (print or io.write)('done')
</pre><p>
當前的解析器總是用第一種結構來解析，
它會將開括號看成函式調用的參數傳遞開始處。
為了避免這種二義性，
在一條語句以小括號開頭時，前面放一個分號是個好習慣：

<pre>
     ;(print or io.write)('done')
</pre>

<p>

一個語句塊可以被顯式的定界為單條語句：

<pre>
	stat ::= <b>do</b> block <b>end</b>
</pre><p>
顯式的對一個塊定界通常用來控制內部變量聲明的作用域。
有時，顯式定界也用於在一個語句塊中間插入
<b>return</b> （參見 <a href="#3.3.4">&sect;3.3.4</a>）。





<h3>3.3.2 &ndash; <a name="3.3.2">代碼塊</a></h3>

<p>
Lua 的一個編譯單元被稱為一個 <em>代碼塊</em>。
從句法構成上講，一個代碼塊就是一個語句塊。

<pre>
	chunk ::= block
</pre>

<p>
Lua 把一個代碼塊當作一個擁有不定參數的匿名函式
（參見<a href="#3.4.11">&sect;3.4.11</a>）來處理。
正是這樣，代碼塊內可以定義局部變量，它可以接收參數，返回若干值。
此外，這個匿名函式在編譯時還為它的作用域綁定了一個外部局部變量
<code>_ENV</code> （參見 <a href="#2.2">&sect;2.2</a>）。
該函式總是把 <code>_ENV</code> 作為它唯一的一個上值，
即使這個函式不使用這個變量，它也存在。


<p>
代碼塊可以被保存在文件中，也可以作為宿主程序內部的一個字串。
要執行一個代碼塊，
首先要讓 Lua <em>加載</em> 它，
將代碼塊中的代碼預編譯成虛擬機中的指令，
而後，Lua 用虛擬機解釋器來運行編譯後的代碼。


<p>
代碼塊可以被預編譯為二進制形式；
參見程序  <code>luac</code> 以及函式 <a href="#pdf-string.dump"><code>string.dump</code></a> 可獲得更多細節。
用源碼表示的程序和編譯後的形式可自由替換；
Lua 會自動檢測文件格式做相應的處理
（參見 <a href="#pdf-load"><code>load</code></a>）。





<h3>3.3.3 &ndash; <a name="3.3.3">賦值</a></h3>

<p>
Lua 允許多重賦值。
因此，賦值的語法定義是等號左邊放一個變量列表， 而等號右邊放一個表達式列表。
兩邊的列表中的元素都用逗號間開：

<pre>
	stat ::= varlist &lsquo;<b>=</b>&rsquo; explist
	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}
	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}
</pre><p>
表達式放在 <a href="#3.4">&sect;3.4</a> 中討論。


<p>
在作賦值操作之前，
那值列表會被 <em>調整</em> 為左邊變量列表的個數。
如果值比需要的更多的話，多餘的值就被扔掉。 
如果值的數量不夠需求，
將會按所需擴展若干個 <b>nil</b>。
如果表達式列表以一個函式調用結束，
這個函式所返回的所有值都會在調整操作之前被置入值列表中
（除非這個函式調用被用括號括了起來；參見 <a href="#3.4">&sect;3.4</a>）。



<p>
賦值語句首先讓所有的表達式完成運算，
之後再做賦值操作。
因此，下面這段代碼

<pre>
     i = 3
     i, a[i] = i+1, 20
</pre><p>
會把 <code>a[3]</code> 設置為 20，而不會影響到 <code>a[4]</code> 。
這是因為 <code>a[i]</code> 中的 <code>i</code> 在被賦值為 4 之前就被計算出來了（當時是 3 ）。 
簡單說 ，這樣一行

<pre>
     x, y = y, x
</pre><p>
會交換 <code>x</code> 和 <code>y</code> 的值，
及

<pre>
     x, y, z = y, z, x
</pre><p>
會輪換 <code>x</code>，<code>y</code>，<code>z</code> 的值。


<p>
對全局變量以及表的域的賦值操作的含義可以通過元表來改變。
對 <code>t[i] = val</code> 這樣的變量索引賦值，
等價於 <code>settable_event(t,i,val)</code>。
（關於函式 <code>settable_event</code> 的詳細說明，參見
<a href="#2.4">&sect;2.4</a>。
這個函式並沒有在 Lua 中定義出來，也不可以被調用。
這裡我們列出來，僅僅出於方便解釋的目的。）



<p>
對於全局變量 <code>x = val</code> 的賦值等價於
<code>_ENV.x = val</code>
（參見 <a href="#2.2">&sect;2.2</a>）。





<h3>3.3.4 &ndash; <a name="3.3.4">控制結構</a></h3><p>
<b>if</b>, <b>while</b>, and <b>repeat</b>
這些控制結構符合通常的意義，而且也有類似的語法：




<pre>
	stat ::= <b>while</b> exp <b>do</b> block <b>end</b>
	stat ::= <b>repeat</b> block <b>until</b> exp
	stat ::= <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b>
</pre><p>
Lua 也有一個 <b>for</b> 語句，它有兩種形式
（參見 <a href="#3.3.5">&sect;3.3.5</a>）。


<p>
控制結構中的條件表達式可以返回任何值。
<b>false</b> 與 <b>nil</b> 兩者都被認為是假。
所有不同於 <b>nil</b> 與 <b>false</b> 的其它值都被認為是真
（特別需要注意的是，數字 0 和空字串也被認為是真）。


<p>
在 <b>repeat</b>&ndash;<b>until</b> 循環中，
內部語句塊的結束點不是在 <b>until</b> 這個關鍵字處，
它還包括了其後的條件表達式。
因此，條件表達式中可以使用循環內部語句塊中的定義的局部變量。


<p>
<b>goto</b> 語句將程序的控制點轉移到一個標籤處。
由於句法上的原因，
Lua 裡的標籤也被認為是語句：



<pre>
	stat ::= <b>goto</b> Name
	stat ::= label
	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;
</pre>

<p>
除了在內嵌函式中，以及在內嵌語句塊中定義了同名標籤，的情況外，
標籤對於它定義所在的整個語句塊可見。
只要 goto 沒有進入一個新的局部變量的作用域，它可以跳轉到任意可見標籤處。


<p>
標籤和沒有內容的語句被稱為<em>空語句</em>，它們不做任何操作。


<p>
<b>break</b> 被用來結束
<b>while</b>、 <b>repeat</b>、或 <b>for</b> 循環，
它將跳到循環外接著之後的語句運行：


<pre>
	stat ::= <b>break</b>
</pre><p>
<b>break</b> 跳出最內層的循環。


<p>
<b>return</b> 被用於從函式或是代碼塊（其實它就是一個函式）
中返回值。

函式可以返回不止一個值，所以 <b>return</b> 的語法為

<pre>
	stat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]
</pre>

<p>
<b>return</b> 只能被寫在一個語句塊的最後一句。
如果你真的需要從語句塊的中間 <b>return</b>，
你可以使用顯式的定義一個內部語句塊，
一般寫作 <code>do return end</code>。
可以這樣寫是因為現在 <b>return</b> 成了（內部）語句塊的最後一句了。





<h3>3.3.5 &ndash; <a name="3.3.5">For 語句</a></h3>

<p>
<b>for</b> 有兩種形式：一種是數字形式，另一種是通用形式。


<p>
數字形式的 <b>for</b> 循環，通過一個數學運算不斷地運行內部的代碼塊。
下面是它的語法：

<pre>
	stat ::= <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b>
</pre><p>
<em>block</em> 將把 <em>name</em> 作循環變量。
從第一個 <em>exp</em> 開始起，直到第二個 <em>exp</em> 的值為止，
其步長為第三個 <em>exp</em> 。
更確切的說，一個 <b>for</b> 循環看起來是這個樣子

<pre>
     for v = <em>e1</em>, <em>e2</em>, <em>e3</em> do <em>block</em> end
</pre><p>
這等價於代碼：

<pre>
     do
       local <em>var</em>, <em>limit</em>, <em>step</em> = tonumber(<em>e1</em>), tonumber(<em>e2</em>), tonumber(<em>e3</em>)
       if not (<em>var</em> and <em>limit</em> and <em>step</em>) then error() end
       <em>var</em> = <em>var</em> - <em>step</em>
       while true do
         <em>var</em> = <em>var</em> + <em>step</em>
         if (<em>step</em> &gt;= 0 and <em>var</em> &gt; <em>limit</em>) or (<em>step</em> &lt; 0 and <em>var</em> &lt; <em>limit</em>) then
           break
         end
         local v = <em>var</em>
         <em>block</em>
       end
     end
</pre>

<p>
注意下面這幾點：

<ul>

<li>
所有三個控制表達式都只被運算一次，
表達式的計算在循環開始之前。 
這些表達式的結果必須是數字。
</li>

<li>
<code><em>var</em></code>，<code><em>limit</em></code>，以及 <code><em>step</em></code>
都是一些不可見的變量。 
這裡給它們起的名字都僅僅用於解釋方便。
</li>

<li>
如果第三個表達式（步長）沒有給出，會把步長設為 1 。
</li>

<li>
你可以用 <b>break</b> 和 <b>goto</b> 來退出 <b>for</b> 循環。
</li>

<li>
循環變量 <code>v</code> 是一個循環內部的局部變量；
如果你需要在循環結束後使用這個值，
在退出循環前把它賦給另一個變量。
</li>

</ul>

<p>
通用形式的 <b>for</b> 通過一個叫作 <em>迭代器</em> 的函式工作。
每次迭代，迭代器函式都會被調用以產生一個新的值，
當這個值為 <b>nil</b> 時，循環停止。 
通用形式的 <b>for</b> 循環的語法如下：

<pre>
	stat ::= <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b>
	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}
</pre><p>
這樣的 <b>for</b> 語句

<pre>
     for <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> in <em>explist</em> do <em>block</em> end
</pre><p>
它等價於這樣一段代碼：

<pre>
     do
       local <em>f</em>, <em>s</em>, <em>var</em> = <em>explist</em>
       while true do
         local <em>var_1</em>, &middot;&middot;&middot;, <em>var_n</em> = <em>f</em>(<em>s</em>, <em>var</em>)
         if <em>var_1</em> == nil then break end
         <em>var</em> = <em>var_1</em>
         <em>block</em>
       end
     end
</pre><p>
注意以下幾點：

<ul>

<li>
<code><em>explist</em></code> 只會被計算一次。
它返回三個值， 一個 <em>迭代器</em> 函式，
一個 <em>狀態</em>，
一個 <em>迭代器的初始值</em>。
</li>

<li>
<code><em>f</em></code>， <code><em>s</em></code>，與 <code><em>var</em></code>
都是不可見的變量。
這裡給它們起的名字都只是為了解說方便。
</li>

<li>
你可以使用 <b>break</b> 來跳出 <b>for</b> 循環。
</li>

<li>
環變量 <code><em>var_i</em></code> 對於循環來說是一個局部變量；
你不可以在 <b>for</b> 循環結束後繼續使用。
如果你需要保留這些值，那麼就在循環跳出或結束前賦值到別的變量裡去。
</li>

</ul>




<h3>3.3.6 &ndash; <a name="3.3.6">函式調用語句</a></h3><p>
為了允許使用函式的副作用，
函式調用可以被作為一個語句執行：

<pre>
	stat ::= functioncall
</pre><p>
在這種情況下，所有的返回值都被捨棄。
函式調用在 <a href="#3.4.10">&sect;3.4.10</a> 中解釋。





<h3>3.3.7 &ndash; <a name="3.3.7">局部聲明</a></h3><p>
局部變量可以在語句塊中任何地方聲明。 
聲明可以包含一個初始化賦值操作：


<pre>
	stat ::= <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist]
</pre><p>
如果有初始化值的話，初始化賦值操作的語法和賦值操作一致
（參見 <a href="#3.3.3">&sect;3.3.3</a> ）。
若沒有初始化值，所有的變量都被初始化為 <b>nil</b>。



<p>
一個代碼塊同時也是一個語句塊（參見 <a href="#3.3.2">&sect;3.3.2</a>），
所以局部變量可以放在代碼塊中那些顯式註明的語句塊之外。 


<p>
局部變量的可見性規則在 <a href="#3.5">&sect;3.5</a> 中解釋。







<h2>3.4 &ndash; <a name="3.4">表達式</a></h2>

<p>
Lua 中有這些基本表達式：

<pre>
	exp ::= prefixexp
	exp ::= <b>nil</b> | <b>false</b> | <b>true</b>
	exp ::= Numeral
	exp ::= LiteralString
	exp ::= functiondef
	exp ::= tableconstructor
	exp ::= &lsquo;<b>...</b>&rsquo;
	exp ::= exp binop exp
	exp ::= unop exp
	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;
</pre>

<p>
數字和字面串在 <a href="#3.1">&sect;3.1</a> 中解釋；
變量在 <a href="#3.2">&sect;3.2</a> 中解釋；
函式定義在 <a href="#3.4.11">&sect;3.4.11</a> 中解釋；
函式調用在 <a href="#3.4.10">&sect;3.4.10</a> 中解釋；
表的構造在 <a href="#3.4.9">&sect;3.4.9</a> 中解釋。
可變參數的表達式寫作三個點（'<code>...</code>'），
它只能在有可變參數的函式中直接使用；這些在 <a href="#3.4.11">&sect;3.4.11</a> 中解釋。


<p>
二元操作符包含有數學運算操作符（參見 <a href="#3.4.1">&sect;3.4.1</a>），
位操作符（參見 <a href="#3.4.2">&sect;3.4.2</a>），
比較操作符（參見 <a href="#3.4.4">&sect;3.4.4</a>），
邏輯操作符（參見 <a href="#3.4.5">&sect;3.4.5</a>），
以及連接操作符（參見 <a href="#3.4.6">&sect;3.4.6</a>）。
一元操作符包括負號（參見 <a href="#3.4.1">&sect;3.4.1</a>），
按位非（參見 <a href="#3.4.2">&sect;3.4.2</a>），
邏輯非（參見 <a href="#3.4.5">&sect;3.4.5</a>），
和取長度操作符（參見 <a href="#3.4.7">&sect;3.4.7</a>）。



<p>
函式調用和可變參數表達式都可以放在多重返回值中。 
如果函式調用被當作一條語句（參見 <a href="#3.3.6">&sect;3.3.6</a>），
其返回值列表被調整為零個元素，即拋棄所有的返回值。
如果表達式被用於表達式列表的最後（或是唯一的）一個元素，
那麼不會做任何調整（除非表達式被括號括起來）。
在其它情況下，
Lua 都會把結果調整為一個元素置入表達式列表中，
即保留第一個結果而忽略之後的所有值，或是在沒有結果時，
補單個 <b>nil</b>。


<p>
這裡有一些例子：

<pre>
     f()                -- 調整為 0 個結果
     g(f(), x)          -- f() 會被調整為一個結果
     g(x, f())          -- g 收到 x 以及 f() 返回的所有結果
     a,b,c = f(), x     -- f() 被調整為 1 個結果 （c 收到 nil）
     a,b = ...          -- a 收到可變參數列表的第一個參數，
                        -- b 收到第二個參數（如果可變參數列表中
                        -- 沒有實際的參數，a 和 b 都會收到 nil）
     
     a,b,c = x, f()     -- f() 被調整為 2 個結果
     a,b,c = f()        -- f() 被調整為 3 個結果
     return f()         -- 返回 f() 的所有返回結果
     return ...         -- 返回從可變參數列表中接收到的所有參數parameters
     return x,y,f()     -- 返回 x, y, 以及 f() 的所有返回值
     {f()}              -- 用 f() 的所有返回值創建一個列表
     {...}              -- 用可變參數中的所有值創建一個列表
     {f(), nil}         -- f() 被調整為一個結果
</pre>

<p>
被括號括起來的表達式永遠被當作一個值。
所以，
<code>(f(x,y,z))</code> 即使 <code>f</code> 返回多個值，
這個表達式永遠是一個單一值。 
（<code>(f(x,y,z))</code> 的值是 <code>f</code> 返回的第一個值。
如果 <code>f</code> 不返回值的話，那麼它的值就是 <b>nil</b> 。）



<h3>3.4.1 &ndash; <a name="3.4.1">數學運算操作符</a></h3><p>
Lua 支持下列數學運算操作符：

<ul>
<li><b><code>+</code>: </b>加法</li>
<li><b><code>-</code>: </b>減法</li>
<li><b><code>*</code>: </b>乘法</li>
<li><b><code>/</code>: </b>浮點除法</li>
<li><b><code>//</code>: </b>向下取整除法</li>
<li><b><code>%</code>: </b>取模</li>
<li><b><code>^</code>: </b>乘方</li>
<li><b><code>-</code>: </b>取負</li>
</ul>

<p>
除了乘方和浮點除法運算，
數學運算按如下方式工作：
如果兩個操作數都是整數，
該操作以整數方式操作且結果也將是一個整數。
否則，當兩個操作數都是數字或可以被轉換為數字的字串
（參見 <a href="#3.4.3">&sect;3.4.3</a>）時，
操作數會被轉換成兩個浮點數，
操作按通常的浮點規則（一般遵循 IEEE 754 標準）
來進行，結果也是一個浮點數。


<p>
乘方和浮點除法 （<code>/</code>）
總是把操作數轉換成浮點數進行，其結果總是浮點數。
乘方使用 ISO C 函式 <code>pow</code>，
因此它也可以接受非整數的指數。


<p>
向下取整的除法 （<code>//</code>）
指做一次除法，並將商圓整到靠近負無窮的一側，
即對操作數做除法後取 floor 。


<p>
取模被定義成除法的餘數，其商被圓整到靠近負無窮的一側（向下取整的除法）。


<p>
對於整數數學運算的溢出問題，
這些操作採取的策略是按通常遵循的以 2 為補碼的數學運算的 <em>環繞</em> 規則。
（換句話說，它們返回其運算的數學結果對 <em>2<sup>64</sup></em> 取模後的數字。）



<h3>3.4.2 &ndash; <a name="3.4.2">位操作符</a></h3><p>
Lua 支持下列位操作符：

<ul>
<li><b><code>&amp;</code>: </b>按位與</li>
<li><b><code>&#124;</code>: </b>按位或</li>
<li><b><code>~</code>: </b>按位異或</li>
<li><b><code>&gt;&gt;</code>: </b>右移</li>
<li><b><code>&lt;&lt;</code>: </b>左移</li>
<li><b><code>~</code>: </b>按位非</li>
</ul>

<p>
所有的位操作都將操作數先轉換為整數
（參見 <a href="#3.4.3">&sect;3.4.3</a>），
然後按位操作，其結果是一個整數。


<p>
對於右移和左移，均用零來填補空位。
移動的位數若為負，則向反方向位移；
若移動的位數的絕對值大於等於
整數本身的位數，其結果為零
（所有位都被移出）。





<h3>3.4.3 &ndash; <a name="3.4.3">強制轉換</a></h3><p>
Lua 對一些型別和值的內部表示會在運行時做一些數學轉換。
位操作總是將浮點操作數轉換成整數。
乘方和浮點除法總是將整數轉換為浮點數。
其它數學操作若針對混合操作數
（整數和浮點數）將把整數轉換為浮點數；
這一點被稱為 <em>通常規則</em>。
C API 同樣會按需把整數轉換為浮點數以及
把浮點數轉換為整數。
此外，字串連接操作除了字串，也可以接受數字作為參數。


<p>
當操作需要數字時，Lua 還會把字串轉換為數字。


<p>
當把一個整數轉換為浮點數時，
若整數值恰好可以表示為一個浮點數，那就取那個浮點數。
否則，轉換會取最接近的較大值或較小值來表示這個數。
這種轉換是不會失敗的。


<p>
將浮點數轉為整數的過程會檢查
浮點數能否被準確的表達為一個整數
（即，浮點數是一個整數值且在整數可以表達的區間）。
如果可以，結果就是那個數，否則轉換失敗。


<p>
從字串到數字的轉換過程遵循以下流程：
首先，遵循按 Lua 詞法分析器的規則分析語法來轉換為對應的
整數或浮點數。
（字串可以有前置或後置的空格以及一個符號。）
然後，結果數字再按前述規則轉換為所需要的型別（浮點或整數）。


<p>
從數字轉換為字串使用非指定的人可讀的格式。
若想完全控制數字到字串的轉換過程，
可以使用字串庫中的 <code>format</code> 函式
（參見 <a href="#pdf-string.format"><code>string.format</code></a>）。





<h3>3.4.4 &ndash; <a name="3.4.4">比較操作符</a></h3><p>
Lua 支持下列比較操作符：

<ul>
<li><b><code>==</code>: </b>等於</li>
<li><b><code>~=</code>: </b>不等於</li>
<li><b><code>&lt;</code>: </b>小於</li>
<li><b><code>&gt;</code>: </b>大於</li>
<li><b><code>&lt;=</code>: </b>小於等於</li>
<li><b><code>&gt;=</code>: </b>大於等於</li>
</ul><p>
這些操作的結果不是 <b>false</b> 就是 <b>true</b>。


<p>
等於操作 （<code>==</code>）先比較操作數的型別。
如果型別不同，結果就是 <b>false</b>。
否則，繼續比較值。 
字串按一般的方式比較。
數字遵循二元操作的規則：
如果兩個操作數都是整數，
它們按整數比較；
否則，它們先轉換為浮點數，然後再做比較。


<p>
表，用戶數據，以及線程都按引用比較：
只有兩者引用同一個對像時才認為它們相等。
每次你創建一個新對像（一張表，一個用戶數據，或一個線程），
新對象都一定和已有且存在的對象不同。
相同引用的 Closure 一定相等。
有任何可察覺的差異（不同的行為，不同的定義）一定不等。


<p>
你可以通過使用 "eq" 元方法（參見 <a href="#2.4">&sect;2.4</a>）
來改變 Lua 比較表和用戶數據時的方式。


<p>
等於操作不會將字串轉換為數字，反之亦然。
即，<code>"0"==0</code> 結果為 <b>false</b>，
且 <code>t[0]</code> 與 <code>t["0"]</code> 指代著表中的不同項。


<p>
<code>~=</code> 操作完全等價於 (<code>==</code>) 操作的反值。


<p>
大小比較操作以以下方式進行。
如果參數都是數字，
它們按二元操作的常規進行。
否則，如果兩個參數都是字串，
它們的值按當前的區域設置來比較。
再則，Lua 就試著調用 "lt" 或是 "le" 元方法
（參見 <a href="#2.4">&sect;2.4</a>）。
<code>a &gt; b</code> 的比較被轉譯為 <code>b &lt; a</code>，
<code>a &gt;= b</code> 被轉譯為 <code>b &lt;= a</code>。





<h3>3.4.5 &ndash; <a name="3.4.5">邏輯操作符</a></h3><p>
Lua 中的邏輯操作符有 <b>and</b>， <b>or</b>，以及 <b>not</b>。
和控制結構（參見 <a href="#3.3.4">&sect;3.3.4</a>）一樣，
所有的邏輯操作符把 <b>false</b> 和 <b>nil</b> 都作為假，
而其它的一切都當作真。


<p>
取反操作 <b>not</b> 總是返回 <b>false</b> 或 <b>true</b> 中的一個。
與操作符 <b>and</b> 在第一個參數為 <b>false</b> 或 <b>nil</b> 時
返回這第一個參數；
否則，<b>and</b> 返回第二個參數。 
或操作符 <b>or</b> 在第一個參數不為 <b>nil</b> 也不為 <b>false</b> 時，
返回這第一個參數，否則返回第二個參數。
<b>and</b> 和 <b>or</b> 都遵循短路規則；
也就是說，第二個操作數只在需要的時候去求值。
這裡有一些例子：

<pre>
     10 or 20            --&gt; 10
     10 or error()       --&gt; 10
     nil or "a"          --&gt; "a"
     nil and 10          --&gt; nil
     false and error()   --&gt; false
     false and nil       --&gt; false
     false or nil        --&gt; nil
     10 and 20           --&gt; 20
</pre><p>
（在這本手冊中，
<code>--&gt;</code> 指前面表達式的結果。）





<h3>3.4.6 &ndash; <a name="3.4.6">字串連接</a></h3><p>
Lua 中字串的連接操作符寫作兩個點（'<code>..</code>'）。
如果兩個操作數都是字串或都是數字，
連接操作將以 <a href="#3.4.3">&sect;3.4.3</a> 中提到的規則把其轉換為字串。
否則，會調用元方法 <code>__concat</code> （參見 <a href="#2.4">&sect;2.4</a>）。





<h3>3.4.7 &ndash; <a name="3.4.7">取長度操作符</a></h3>

<p>
取長度操作符寫作一元前置符 <code>#</code>。
字串的長度是它的字節數（就是以一個字符一個字節計算的字串長度）。


<p>
程序可以通過 <code>__len</code> 元方法（參見 <a href="#2.4">&sect;2.4</a>）
來修改對字串型別外的任何值的取長度操作行為。


<p>
如果 <code>__len</code> 元方法沒有給出，
表 <code>t</code> 的長度只在表是一個 <em>序列</em> 時有定義。
序列指表的正數鍵集等於 <em>{1..n}</em> ，
其中 <em>n</em> 是一個非負整數。
在這種情況下，<em>n</em> 是表的長度。
注意這樣的表

<pre>
     {10, 20, nil, 40}
</pre><p>
不是一個序列，因為它有鍵 <code>4</code>
卻沒有鍵 <code>3</code>。
（因此，該表的正整數鍵集不等於 <em>{1..n}</em> 集合，故而就不存在 <em>n</em>。）
注意，一張表是否是一個序列和它的非數字鍵無關。





<h3>3.4.8 &ndash; <a name="3.4.8">優先級</a></h3><p>
Lua 中操作符的優先級寫在下表中，從低到高優先級排序：

<pre>
     or
     and
     &lt;     &gt;     &lt;=    &gt;=    ~=    ==
     |
     ~
     &amp;
     &lt;&lt;    &gt;&gt;
     ..
     +     -
     *     /     //    %
     unary operators (not   #     -     ~)
     ^
</pre><p>
通常，
你可以用括號來改變運算次序。
連接操作符 ('<code>..</code>') 和乘方操作 ('<code>^</code>') 
是從右至左的。 
其它所有的操作都是從左至右。




<h3>3.4.9 &ndash; <a name="3.4.9">表構建</a></h3><p>
表構造子是一個構造表的表達式。
每次構造子被執行，都會構造出一張新的表。
構造子可以被用來構造一張空表，
也可以用來構造一張表並初始化其中的一些域。
一般的構造子的語法如下

<pre>
	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;
	fieldlist ::= field {fieldsep field} [fieldsep]
	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp
	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;
</pre>

<p>
每個形如 <code>[exp1] = exp2</code> 的域向表中增加新的一項，
其鍵為 <code>exp1</code> 而值為 <code>exp2</code>。
形如 <code>name = exp</code> 的域等價於
<code>["name"] = exp</code>。
最後，形如 <code>exp</code> 的域等價於 <code>[i] = exp</code> ，
這裡的 <code>i</code> 是一個從 1 開始不斷增長的數字。
這這個格式中的其它域不會破壞其記數。
舉個例子：

<pre>
     a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
</pre><p>
等價於

<pre>
     do
       local t = {}
       t[f(1)] = g
       t[1] = "x"         -- 1st exp
       t[2] = "y"         -- 2nd exp
       t.x = 1            -- t["x"] = 1
       t[3] = f(x)        -- 3rd exp
       t[30] = 23
       t[4] = 45          -- 4th exp
       a = t
     end
</pre>

<p>
構造子中賦值的次序未定義。
（次序問題只會對那些鍵重複時的情況有影響。）


<p>
如果表單中最後一個域的形式是 <code>exp</code> ，
而且其表達式是一個函式調用或者是一個可變參數，
那麼這個表達式所有的返回值將依次進入列表 
（參見 <a href="#3.4.10">&sect;3.4.10</a>）。


<p>
初始化域表可以在最後多一個分割符，
這樣設計可以方便由機器生成代碼。




<h3>3.4.10 &ndash; <a name="3.4.10">函式調用</a></h3><p>
Lua 中的函式調用的語法如下：

<pre>
	functioncall ::= prefixexp args
</pre><p>
函式調用時，
第一步，prefixexp 和 args 先被求值。
如果 prefixexp 的值的型別是 <em>function</em>，
那麼這個函式就被用給出的參數調用。
否則 prefixexp 的元方法 "call" 就被調用，
第一個參數是 prefixexp 的值，
接下來的是原來的調用參數 
（參見 <a href="#2.4">&sect;2.4</a>）。


<p>
這樣的形式

<pre>
	functioncall ::= prefixexp &lsquo;<b>:</b>&rsquo; Name args
</pre><p>
可以用來調用 "方法"。
這是 Lua 支持的一種語法糖。
像 <code>v:name(args)</code> 這個樣子，
被解釋成 <code>v.name(v,args)</code>，
這裡的 <code>v</code> 只會被求值一次。


<p>
參數的語法如下：

<pre>
	args ::= &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo;
	args ::= tableconstructor
	args ::= LiteralString
</pre><p>
所有參數的表達式求值都在函式調用之前。
這樣的調用形式 <code>f{fields}</code> 是一種語法糖用於表示
<code>f({fields})</code>；
這裡指參數列表是一個新創建出來的列表。
而這樣的形式 <code>f'<em>string</em>'</code>
（或是 <code>f"<em>string</em>"</code> 亦或是 <code>f[[<em>string</em>]]</code>）
也是一種語法糖，用於表示 <code>f('<em>string</em>')</code>；
此時的參數列表是一個單獨的字串。


<p>
<code>return <em>functioncall</em></code> 
這樣的調用形式將觸發一次 <em>尾調用</em>。
Lua 實現了 <em>完全尾調用</em>（或稱為 <em>完全尾遞歸</em>）：
在尾調用中， 被調用的函式重用調用它的函式的堆堆疊項。
因此，對於程序執行的嵌套尾調用的層數是沒有限制的。
然而，尾調用將刪除調用它的函式的任何調試信息。
注意，尾調用只發生在特定的語法下，
僅當 <b>return</b> 只有單一函式調用作為參數時才發生尾調用；
這種語法使得調用函式的所有結果可以完整地返回。
因此，下面這些例子都不是尾調用：

<pre>
     return (f(x))        -- 返回值被調整為一個
     return 2 * f(x)
     return x, f(x)       -- 追加若干返回值
     f(x); return         -- 返回值全部被捨棄
     return x or f(x)     -- 返回值被調整為一個
</pre>




<h3>3.4.11 &ndash; <a name="3.4.11">函式定義</a></h3>

<p>
函式定義的語法如下：

<pre>
	functiondef ::= <b>function</b> funcbody
	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>
</pre>

<p>
另外定義了一些語法糖簡化函式定義的寫法：

<pre>
	stat ::= <b>function</b> funcname funcbody
	stat ::= <b>local</b> <b>function</b> Name funcbody
	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]
</pre><p>
該語句

<pre>
     function f () <em>body</em> end
</pre><p>
被轉譯成

<pre>
     f = function () <em>body</em> end
</pre><p>
該語句

<pre>
     function t.a.b.c.f () <em>body</em> end
</pre><p>
被轉譯成

<pre>
     t.a.b.c.f = function () <em>body</em> end
</pre><p>
該語句

<pre>
     local function f () <em>body</em> end
</pre><p>
被轉譯成

<pre>
     local f; f = function () <em>body</em> end
</pre><p>
而不是

<pre>
     local f = function () <em>body</em> end
</pre><p>
（這個差別只在函式體內需要引用 <code>f</code> 時才有。）


<p>
一個函式定義是一個可執行的表達式，
執行結果是一個型別為 <em>function</em> 的值。
當 Lua 預編譯一個代碼塊時，
代碼塊作為一個函式，整個函式體也就被預編譯了。
那麼，無論何時 Lua 執行了函式定義，
這個函式本身就進行了 <em>實例化</em>（或者說是 <em>關閉</em>了）。
這個函式的實例（或者說是 <em>Closure</em>）是表達式的最終值。

<p>
形參被看作是一些局部變量，
它們將由實參的值來初始化：

<pre>
	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;
</pre><p>
當一個函式被調用，
如果函式並非一個 <em>可變參數函式</em>，
即在形參列表的末尾註明三個點 ('<code>...</code>')，
那麼實參列表就會被調整到形參列表的長度。
變長參數函式不會調整實參列表； 
取而代之的是，它將把所有額外的參數放在一起通過
<em>變長參數表達式</em>傳遞給函式，
其寫法依舊是三個點。
這個表達式的值是一串實參值的列表，
看起來就跟一個可以返回多個結果的函式一樣。
如果一個變長參數表達式放在另一個表達式中使用，
或是放在另一串表達式的中間，
那麼它的返回值就會被調整為單個值。
若這個表達式放在了一系列表達式的最後一個，
就不會做調整了
（除非這最後一個參數被括號給括了起來）。


<p>
我們先做如下定義，然後再來看一個例子：

<pre>
     function f(a, b) end
     function g(a, b, ...) end
     function r() return 1,2,3 end
</pre><p>
下面看看實參到形參數以及可變長參數的映射關係：

<pre>
     CALL            PARAMETERS
     
     f(3)             a=3, b=nil
     f(3, 4)          a=3, b=4
     f(3, 4, 5)       a=3, b=4
     f(r(), 10)       a=1, b=10
     f(r())           a=1, b=2
     
     g(3)             a=3, b=nil, ... --&gt;  (nothing)
     g(3, 4)          a=3, b=4,   ... --&gt;  (nothing)
     g(3, 4, 5, 8)    a=3, b=4,   ... --&gt;  5  8
     g(5, r())        a=5, b=1,   ... --&gt;  2  3
</pre>

<p>
結果由 <b>return</b> 來返回（參見 <a href="#3.3.4">&sect;3.3.4</a>）。
如果執行到函式末尾依舊沒有遇到任何 <b>return</b> 語句，
函式就不會返回任何結果。


<p>
關於函式可返回值的數量限制和系統有關。
這個限制一定大於 1000 。


<p>
<em>冒號</em> 語法可以用來定義 <em>方法</em>，
就是說，函式可以有一個隱式的形參 <code>self</code>。
因此，如下語句

<pre>
     function t.a.b.c:f (<em>params</em>) <em>body</em> end
</pre><p>
是這樣一種寫法的語法糖

<pre>
     t.a.b.c.f = function (self, <em>params</em>) <em>body</em> end
</pre>






<h2>3.5 &ndash; <a name="3.5">可見性規則</a></h2>

<p>
Lua 語言有詞法作用範圍。
變量的作用範圍開始於聲明它們之後的第一個語句段，
結束於包含這個聲明的最內層語句塊的最後一個非空語句。
看下面這些例子：

<pre>
     x = 10                -- 全局變量
     do                    -- 新的語句塊
       local x = x         -- 新的一個 'x', 它的值現在是 10
       print(x)            --&gt; 10
       x = x+1
       do                  -- 另一個語句塊
         local x = x+1     -- 又一個 'x'
         print(x)          --&gt; 12
       end
       print(x)            --&gt; 11
     end
     print(x)              --&gt; 10 （取到的是全局的那一個）
</pre>

<p>
注意這裡，類似 <code>local x = x</code> 這樣的聲明，
新的 <code>x</code> 正在被聲明，但是還沒有進入它的作用範圍，
所以第二個 <code>x</code> 指向的是外面一層的變量。


<p>
因為有這樣一個詞法作用範圍的規則，
局部變量可以被在它的作用範圍內定義的函式自由使用。
當一個局部變量被內層的函式中使用的時候，
它被內層函式稱作 <em>上值</em>，或是 <em>外部局部變量</em>。


<p>
注意，每次執行到一個 <b>local</b> 語句都會定義出一個新的局部變量。
看看這樣一個例子：

<pre>
     a = {}
     local x = 20
     for i=1,10 do
       local y = 0
       a[i] = function () y=y+1; return x+y end
     end
</pre><p>
這個循環創建了十個 Closure（這指十個匿名函式的實例）。
這些 Closure 中的每一個都使用了不同的 <code>y</code> 變量，
而它們又共享了同一份 <code>x</code>。




<h1>4 &ndash; <a name="4">API 應用程式介面</a></h1>

<p>
這個部分描述了 Lua 的 C API ，
也就是宿主程序跟 Lua 通訊用的一組 C 函式。 
所有的 API 函式按相關的型別以及常量都聲明在頭文件 
<a name="pdf-lua.h"><code>lua.h</code></a> 中。


<p>
雖然我們說的是「函式」，
但一部分簡單的 API 是以宏的形式提供的。 
除非另有說明，
所有的這些宏都只使用它們的參數一次 
（除了第一個參數，那一定是 Lua 狀態），
因此你不需擔心這些宏的展開會引起一些副作用。


<p>
C 庫中所有的 Lua API 函式都不去檢查參數是否相容及有效。
然而，你可以在編譯 Lua 時加上打開一個宏開關
<a name="pdf-LUA_USE_APICHECK"><code>LUA_USE_APICHECK</code></a>
來改變這個行為。


<h2>4.1 &ndash; <a name="4.1">Stack 堆疊</a></h2>

<p>
Lua 使用一個 <em>虛擬堆疊</em> 來和 C 互傳值。
堆疊上的的每個元素都是一個 Lua 值 （<b>nil</b>，數字，字串，等等）。



<p>
無論何時 Lua 調用 C，被調用的函式都得到一個新的堆疊，
這個堆疊獨立於 C 函式本身的堆疊，也獨立於之前的 Lua 堆疊。
它裡面包含了 Lua 傳遞給 C 函式的所有參數，
而 C 函式則把要返回的結果放入這個堆疊以返回給調用者 
（參見 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。


<p>
方便起見，
所有針對堆疊的 API 查詢操作都不嚴格遵循堆疊的操作規則。
而是可以用一個 <em>索引</em> 來指向堆疊上的任何元素：
正的索引指的是堆疊上的絕對位置（從1開始）；
負的索引則指從堆疊頂開始的偏移量。
展開來說，如果堆堆疊有 <em>n</em> 個元素，
那麼索引 1 表示第一個元素
（也就是最先被壓堆疊的元素）
而索引 <em>n</em> 則指最後一個元素；
索引 -1 也是指最後一個元素
（即堆疊頂的元素）， 
索引 <em>-n</em> 是指第一個元素。




<h2>4.2 &ndash; <a name="4.2">堆疊大小</a></h2>

<p>
當你使用 Lua API 時，
就有責任保證做恰當的調用。 
特別需要注意的是，
<em>你有責任控制不要堆堆疊溢出</em>。
你可以使用 <a href="#lua_checkstack"><code>lua_checkstack</code></a>
這個函式來擴大可用堆堆疊的尺寸。


<p>
無論何時 Lua 調用 C ，
它都只保證至少有
<a name="pdf-LUA_MINSTACK"><code>LUA_MINSTACK</code></a>
這麼多的堆堆疊空間可以使用。
<code>LUA_MINSTACK</code> 一般被定義為 20 ，
因此，只要你不是不斷的把數據壓堆疊，
通常你不用關心堆堆疊大小。


<p>
當你調用一個 Lua 函式卻沒有指定要接收多少個返回值時
（參見 <a href="#lua_call"><code>lua_call</code></a>），
Lua 可以保證堆疊一定有足夠的空間來接收所有的返回值，
但不保證此外留有額外的空間。
因此，在做了一次這樣的調用後，如果你需要繼續壓堆疊，
則需要使用 <a href="#lua_checkstack"><code>lua_checkstack</code></a>。




<h2>4.3 &ndash; <a name="4.3">有效索引與可接受索引</a></h2>

<p>
API 中的函式若需要傳入堆疊索引，這個索引必須是
<em>有效索引</em> 或是 <em>可接受索引</em>。


<p>
<em>有效索引</em> 指引用堆疊內真實位置的索引；
即在 1 到堆疊頂之間的位置
（<code>1 &le; abs(index) &le; top</code>）。

通常，一個可能修改該位置的值的函式需要傳入有效索引。


<p>
除非另有說明，
任何可以接受有效索引的函式同時也接受 <em>偽索引</em>。
偽索引指代一些可以被 C code 訪問得到 Lua 值，而它們又不在堆疊內。
這用於訪問註冊表以及 C 函式的上值（參見 <a href="#4.4">&sect;4.4</a>）。


<p>
對於那些只是需要堆疊中的值（例如查詢函式）
而不需要指定一個堆疊位置的函式，
可以用一個可接受的索引去調用它們。
<em>可接受索引</em> 不僅可以是任何包括偽索引在內的有效索引，
還可以是任何超過堆疊頂但落在為堆疊分配出來的空間內的正索引。
（注意 0 永遠都不是一個可接受索引。）
除非另有說明，API 裡的函式都接受可接受索引。


<p>
允許可接受索引是為了避免對堆疊頂以外的查詢時做額外的檢查。
例如，C 函式可以直接查詢傳給它的第三個參數，
而不用先檢查是不是有第三個參數，
即不需要檢查 3 是不是一個有效索引。


<p>
對於那些以可接受索引調用的函式，
無效索引被看作包含了一個虛擬型別
<a name="pdf-LUA_TNONE"><code>LUA_TNONE</code></a> 的值，
這個值的行為和 nil 一致。




<h2>4.4 &ndash; <a name="4.4">C Closure</a></h2>

<p>
當 C 函式被創建出來，
我們有可能會把一些值關聯在一起，
也就是創建一個 <em>C Closure</em>
（參見 <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>）；
這些被關聯起來的值被叫做 <em>上值</em> ，
它們可以在函式被調用的時候訪問的到。 


<p>
無論何時去調用 C 函式，
函式的上值都可以用偽索引定位。
我們可以用
<a href="#lua_upvalueindex"><code>lua_upvalueindex</code></a>
這個宏來生成這些偽索引。
第一個關聯到函式的值放在
<code>lua_upvalueindex(1)</code> 位置處，依此類推。 
使用 <code>lua_upvalueindex(<em>n</em>)</code> 時，
若 <em>n</em> 大於當前函式的總上值個數
（但不可以大於 256）會產生一個可接受的但無效的索引。




<h2>4.5 &ndash; <a name="4.5">註冊表</a></h2>

<p>
Lua 提供了一個 <em>註冊表</em>，
這是一個預定義出來的表，
可以用來保存任何 C 代碼想保存的 Lua 值。 
這個表可以用有效偽索引 
<a name="pdf-LUA_REGISTRYINDEX"><code>LUA_REGISTRYINDEX</code></a> 來定位。
任何 C 庫都可以在這張表裡保存數據，
為了防止衝突，你需要特別小心的選擇鍵名。
一般的用法是，你可以用一個包含你的庫名的字串做為鍵名，
或者取你自己 C 對象的地址，以輕量用戶數據的形式做鍵，
還可以用你的代碼創建出來的任意 Lua 對像做鍵。
關於變量名，字串鍵名中以下劃線加大寫字母的名字被 Lua 保留。



<p>
註冊表中的整數鍵用於引用機制
（參見 <a href="#luaL_ref"><code>luaL_ref</code></a>），
以及一些預定義的值。
因此，整數鍵不要用於別的目的。


<p>
當你創建了一個新的 Lua 狀態機，
其中的註冊表內就預定義好了幾個值。
這些預定義值可以用整數索引到，
這些整數以常數形式定義在 <code>lua.h</code> 中。
有下列常數：

<ul>
<li><b><a name="pdf-LUA_RIDX_MAINTHREAD"><code>LUA_RIDX_MAINTHREAD</code></a>: </b>
註冊表中這個索引下是狀態機的主線程。
（主線程和狀態機同時被創建出來。）
</li>

<li><b><a name="pdf-LUA_RIDX_GLOBALS"><code>LUA_RIDX_GLOBALS</code></a>: </b> 
註冊表的這個索引下是全局環境。
</li>
</ul>




<h2>4.6 &ndash; <a name="4.6">C 中的錯誤處理</a></h2>

<p>
在內部實現中，Lua 使用了 C 的 <code>longjmp</code> 機制來處理錯誤。
（如果你使用 C++ 編譯，Lua 將換成異常；
細節請在源代碼中搜索 <code>LUAI_THROW</code>。）
當 Lua 碰到任何錯誤
（比如記憶體分配錯誤、型別錯誤、語法錯誤、還有運行時錯誤）
它都會 <em>拋出</em>一個錯誤出去；
也就是調用一次長跳轉。
在 <em>保護環境</em> 下，
Lua 使用 <code>setjmp</code> 來設置一個恢復點；
任何發生的錯誤都會跳轉到最近的一個恢復點。


<p>
如果錯誤發生在保護環境之外，
Lua 會先調用 <em>panic 函式</em> （參見 <a href="#lua_atpanic"><code>lua_atpanic</code></a>）
然後調用 <code>abort</code> 來退出宿主程序。
你的 panic 函式只要不返回
（例如：長跳轉到你在 Lua 外你自己設置的恢復點）
就可以不退出程序。


<p>
panic 函式以錯誤消息處理器（參見 <a href="#2.3">&sect;2.3</a>）的方式運行；
錯誤消息在堆疊頂。
不同的是，它不保證堆疊空間。
做任何壓堆疊操作前，panic 函式都必須先檢查是否有足夠的空間
（參見 <a href="#4.2">&sect;4.2</a>）。


<p>
大多數 API 函式都有可能拋出錯誤，
例如在記憶體分配錯誤時就會拋出。
每個函式的文檔都會註明它是否可能拋出錯誤。


<p>
在 C 函式內部，你可以通過調用 <a href="#lua_error"><code>lua_error</code></a>
來拋出錯誤。





<h2>4.7 &ndash; <a name="4.7">C 中的讓出處理</a></h2>

<p>
Lua 內部使用 C 的 <code>longjmp</code> 機制讓出一個協程。
因此，如果一個 C 函式 <code>foo</code> 調用了一個 API 函式，
而這個 API 函式讓出了（直接或間接調用了讓出函式）。
由於 <code>longjmp</code> 會移除 C 堆疊的堆疊幀，
Lua 就無法返回到 <code>foo</code> 裡了。


<p>
為了迴避這類問題，
碰到 API 調用中調用讓出時，除了那些拋出錯誤的 API 外，還提供了三個函式：
<a href="#lua_yieldk"><code>lua_yieldk</code></a>，
<a href="#lua_callk"><code>lua_callk</code></a>，和 <a href="#lua_pcallk"><code>lua_pcallk</code></a> 。
它們在讓出發生時，可以從傳入的 <em>延續函式</em>
（名為 <code>k</code> 的參數）繼續運行。


<p>
我們需要預設一些術語來解釋延續點。
對於從 Lua 中調用的 C 函式，我們稱之為 <em>原函式</em>。
從這個原函式中調用的上面所述的三個 C API 函式我們稱之為 <em>被調函式</em>。
被調函式可以使當前線程讓出。
（讓出發生在被調函式是 <a href="#lua_yieldk"><code>lua_yieldk</code></a>，
或傳入 <a href="#lua_callk"><code>lua_callk</code></a> 或
<a href="#lua_pcallk"><code>lua_pcallk</code></a> 的函式調用了讓出時。）


<p>
假設正在運行的線程在執行被調函式時讓出。
當再次延續這條線程，它希望繼續被調函式的運行。
然而，被調函式不可能返回到原函式中。
這是因為之前的讓出操作破壞了 C 堆疊的堆疊幀。
作為替代品，Lua 調用那個作為被調函式參數給出的 <em>延續函式</em> 。
正如其名，延續函式將延續原函式的任務。


<p>
下面的函式會做一個說明：

<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       status = lua_pcall(L, n, m, h);  /* calls Lua */
       ...     /* code 2 */
     }
</pre><p>
現在我們想允許被
<a href="#lua_pcall"><code>lua_pcall</code></a>
運行的 Lua 代碼讓出。
首先，我們把函式改寫成這個樣子：

<pre>
     int k (lua_State *L, int status, lua_KContext ctx) {
       ...  /* code 2 */
     }
     
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcall(L, n, m, h), ctx);
     }
</pre><p>
上面的代碼中，新函式 <code>k</code>
就是一個 <em>延續函式</em>
（函式型別為 <a href="#lua_KFunction"><code>lua_KFunction</code></a>）。
它的工作就是原函式中調用 <a href="#lua_pcall"><code>lua_pcall</code></a>
之後做的那些事情。
現在我們必須通知 Lua 說，你必須在被
<a href="#lua_pcall"><code>lua_pcall</code></a>
執行的 Lua 代碼發生過中斷（錯誤或讓出）後，
還得繼續調用 <code>k</code> 。
所以我們還得繼續改寫這段代碼，把
<a href="#lua_pcall"><code>lua_pcall</code></a> 替換成
<a href="#lua_pcallk"><code>lua_pcallk</code></a>：


<pre>
     int original_function (lua_State *L) {
       ...     /* code 1 */
       return k(L, lua_pcallk(L, n, m, h, ctx2, k), ctx1);
     }
</pre><p>
注意這裡那個額外的顯式的對延續函式的調用：
Lua 僅在需要時，這可能是由錯誤導致的也可能是發生了讓出而需要繼續運行，才會調用延續函式。
如果沒有發生過任何讓出，調用的函式正常返回，
那麼 <a href="#lua_pcallk"><code>lua_pcallk</code></a>
（以及 <a href="#lua_callk"><code>lua_callk</code></a>）也會正常返回。
（當然，這個例子中你也可以不在之後調用延續函式，
而是在原函式的調用後直接寫上需要做的工作。）


<p>
除了 Lua 狀態，延續函式還有兩個參數：
一個是調用最後的狀態碼，另一個一開始由
<a href="#lua_pcallk"><code>lua_pcallk</code></a> 傳入的上下文
（<code>ctx</code>）。
（Lua 本身不使用這個值；它僅僅從原函式轉發這個值給延續函式。）
對於 <a href="#lua_pcallk"><code>lua_pcallk</code></a> 而言，
狀態碼和 <a href="#lua_pcallk"><code>lua_pcallk</code></a>
本應返回值相同，區別僅在於發生過讓出後才執行完時，狀態碼為
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>（而不是
<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>）。
對於 <a href="#lua_yieldk"><code>lua_yieldk</code></a> 和
<a href="#lua_callk"><code>lua_callk</code></a> 而言，
調用延續函式傳入的狀態碼一定是
<a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a>。
（對這兩個函式，Lua 不會因任何錯誤而調用延續函式。
因為它們並不處理錯誤。）
同樣，當你使用 <a href="#lua_callk"><code>lua_callk</code></a> 時，
你應該用 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a>
作為狀態碼來調用延續函式。
（對於 <a href="#lua_yieldk"><code>lua_yieldk</code></a>，
幾乎沒有什麼地方需要直接調用延續函式，
因為 <a href="#lua_yieldk"><code>lua_yieldk</code></a> 本身並不會返回。）


<p>
Lua 會把延續函式看作原函式。
延續函式將接收到和原函式相同的 Lua 堆疊，其接收到的 lua 狀態也和
被調函式若返回後應該有的狀態一致。
（例如，
<a href="#lua_callk"><code>lua_callk</code></a> 調用之後，
堆疊中之前壓入的函式和調用參數都被調用產生的返回值所替代。）
這時也有相同的上值。
等到它返回的時候，Lua 會將其看待成原函式的返回去操作。





<h2>4.8 &ndash; <a name="4.8">函式和型別</a></h2>

<p>
這裡按字母次序列出了所有 C API 中的函式和型別。
每個函式都有一個這樣的提示：
<span class="apii">[-o, +p, <em>x</em>]</span>


<p>
對於第一個域，<code>o</code>，
指的是該函式會從堆疊上彈出多少個元素。
第二個域，<code>p</code>，
指該函式會將多少個元素壓堆疊。
（所有函式都會在彈出參數後再把結果壓堆疊。）
<code>x|y</code> 這種形式的域表示該函式根據具體情況可能壓入（或彈出）
<code>x</code> 或 <code>y</code> 個元素；
問號 '<code>?</code>' 表示
我們無法僅通過參數來瞭解該函式會彈出/壓入多少元素
（比如，數量取決於堆疊上有些什麼）。
第三個域，<code>x</code>，
解釋了該函式是否會拋出錯誤：
'<code>-</code>' 表示該函式絕對不會拋出錯誤；
'<code>e</code>' 表示該函式可能拋出錯誤；
'<code>v</code>' 表示該函式可能拋出有意義的錯誤。



<hr><h3><a name="lua_absindex"><code>lua_absindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_absindex (lua_State *L, int idx);</pre>

<p>
將一個可接受的索引 <code>idx</code> 轉換為絕對索引
（即，一個不依賴堆疊頂在哪的值）。





<hr><h3><a name="lua_Alloc"><code>lua_Alloc</code></a></h3>
<pre>typedef void * (*lua_Alloc) (void *ud,
                             void *ptr,
                             size_t osize,
                             size_t nsize);</pre>

<p>
Lua 狀態機中使用的記憶體分配器函式的型別。
記憶體分配函式必須提供一個功能類似於 <code>realloc</code>
但又不完全相同的函式。
它的參數有
<code>ud</code> ，一個由 <a href="#lua_newstate"><code>lua_newstate</code></a> 傳給它的指針；
<code>ptr</code> ，一個指向已分配出來/將被重新分配/要釋放的記憶體塊指針；
<code>osize</code> ，記憶體塊原來的尺寸或是關於什麼將被分配出來的代碼；
<code>nsize</code> ，新記憶體塊的尺寸。 

<p>
如果 <code>ptr</code> 不是 <code>NULL</code>，
<code>osize</code> 是 <code>ptr</code> 指向的記憶體塊的尺寸，
即這個記憶體塊當初被分配或重分配的尺寸。


<p>
如果 <code>ptr</code> 是 <code>NULL</code>，
<code>osize</code> 是 Lua 即將分配對像型別的編碼。
當（且僅當）Lua 創建一個對應型別的新對像時，
<code>osize</code> 是
<a href="#pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>，<a href="#pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>，<a href="#pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>，
<a href="#pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>，或 <a href="#pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a> 中的一個。
若 <code>osize</code> 是其它型別，Lua 將為其它東西分配記憶體。


<p>
Lua 假定分配器函式會遵循以下行為：


<p>
當 <code>nsize</code> 是零時，
分配器必須和 <code>free</code> 行為類似並返回 <code>NULL</code>。


<p>
當 <code>nsize</code> 不是零時，
分配器必須和 <code>realloc</code> 行為類似。
如果分配器無法完成請求，返回 <code>NULL</code>。
Lua 假定在 <code>osize &gt;= nsize</code> 成立的條件下，
分配器絕不會失敗。


<p>
這裡有一個簡單的分配器函式的實現。
這個實現被放在補充庫中，供
<a href="#luaL_newstate"><code>luaL_newstate</code></a> 使用。

<pre>
     static void *l_alloc (void *ud, void *ptr, size_t osize,
                                                size_t nsize) {
       (void)ud;  (void)osize;  /* not used */
       if (nsize == 0) {
         free(ptr);
         return NULL;
       }
       else
         return realloc(ptr, nsize);
     }
</pre><p>
注意，標準 C 能確保 <code>free(NULL)</code> 沒有副作用，
且 <code>realloc(NULL,size)</code> 等價於 <code>malloc(size)</code>。
這段代碼假定 <code>realloc</code> 在縮小塊長度時不會失敗。
（雖然標準 C 沒有對此行為做出保證，但這看起來是一個安全的假定。）





<hr><h3><a name="lua_arith"><code>lua_arith</code></a></h3><p>
<span class="apii">[-(2|1), +1, <em>e</em>]</span>
<pre>void lua_arith (lua_State *L, int op);</pre>

<p>
對堆疊頂的兩個值（或者一個，比如取反）做一次數學或位操作。
其中，堆疊頂的那個值是第二個操作數。
它會彈出壓入的值，並把結果放在堆疊頂。
這個函式遵循 Lua 對應的操作符運算規則
（即有可能觸發元方法）。


<p>
<code>op</code> 的值必須是下列常量中的一個：

<ul>

<li><b><a name="pdf-LUA_OPADD"><code>LUA_OPADD</code></a>: </b> 加法 (<code>+</code>)</li>
<li><b><a name="pdf-LUA_OPSUB"><code>LUA_OPSUB</code></a>: </b> 減法 (<code>-</code>)</li>
<li><b><a name="pdf-LUA_OPMUL"><code>LUA_OPMUL</code></a>: </b> 乘法 (<code>*</code>)</li>
<li><b><a name="pdf-LUA_OPDIV"><code>LUA_OPDIV</code></a>: </b> 浮點除法 (<code>/</code>)</li>
<li><b><a name="pdf-LUA_OPIDIV"><code>LUA_OPIDIV</code></a>: </b> 向下取整的除法 (<code>//</code>)</li>
<li><b><a name="pdf-LUA_OPMOD"><code>LUA_OPMOD</code></a>: </b> 取模 (<code>%</code>)</li>
<li><b><a name="pdf-LUA_OPPOW"><code>LUA_OPPOW</code></a>: </b> 乘方 (<code>^</code>)</li>
<li><b><a name="pdf-LUA_OPUNM"><code>LUA_OPUNM</code></a>: </b> 取負 (一元 <code>-</code>)</li>
<li><b><a name="pdf-LUA_OPBNOT"><code>LUA_OPBNOT</code></a>: </b> 按位取反 (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPBAND"><code>LUA_OPBAND</code></a>: </b> 按位與 (<code>&amp;</code>)</li>
<li><b><a name="pdf-LUA_OPBOR"><code>LUA_OPBOR</code></a>: </b> 按位或 (<code>|</code>)</li>
<li><b><a name="pdf-LUA_OPBXOR"><code>LUA_OPBXOR</code></a>: </b> 按位異或 (<code>~</code>)</li>
<li><b><a name="pdf-LUA_OPSHL"><code>LUA_OPSHL</code></a>: </b> 左移 (<code>&lt;&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPSHR"><code>LUA_OPSHR</code></a>: </b> 右移 (<code>&gt;&gt;</code>)</li>

</ul>




<hr><h3><a name="lua_atpanic"><code>lua_atpanic</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);</pre>

<p>
設置一個新的 panic 函式，並返回之前設置的那個。
（參見 <a href="#4.6">&sect;4.6</a>）。





<hr><h3><a name="lua_call"><code>lua_call</code></a></h3><p>
<span class="apii">[-(nargs+1), +nresults, <em>e</em>]</span>
<pre>void lua_call (lua_State *L, int nargs, int nresults);</pre>

<p>
調用一個函式。


<p>
要調用一個函式請遵循以下協議：
首先，要調用的函式應該被壓入堆疊；
接著，把需要傳遞給這個函式的參數按正序壓堆疊；
這是指第一個參數首先壓堆疊。
最後調用一下 <a href="#lua_call"><code>lua_call</code></a>；
<code>nargs</code> 是你壓入堆疊的參數個數。
當函式調用完畢後，所有的參數以及函式本身都會出堆疊。
而函式的返回值這時則被壓堆疊。
返回值的個數將被調整為 <code>nresults</code> 個，
除非 <code>nresults</code> 被設置成 <a name="pdf-LUA_MULTRET"><code>LUA_MULTRET</code></a>。
在這種情況下，所有的返回值都被壓入堆堆疊中。 
Lua 會保證返回值都放入堆疊空間中。
函式返回值將按正序壓堆疊（第一個返回值首先壓堆疊），
因此在調用結束後，最後一個返回值將被放在堆疊頂。

<p>
被調用函式內發生的錯誤將（通過 <code>longjmp</code> ）一直上拋。

<p>
下面的例子中，這行 Lua 代碼等價於在宿主程序中用 C 代碼做一些工作：

<pre>
     a = f("how", t.x, 14)
</pre><p>
這裡是 C 裡的代碼：

<pre>
     lua_getglobal(L, "f");                  /* function to be called */
     lua_pushliteral(L, "how");                       /* 1st argument */
     lua_getglobal(L, "t");                    /* table to be indexed */
     lua_getfield(L, -1, "x");        /* push result of t.x (2nd arg) */
     lua_remove(L, -2);                  /* remove 't' from the stack */
     lua_pushinteger(L, 14);                          /* 3rd argument */
     lua_call(L, 3, 1);     /* call 'f' with 3 arguments and 1 result */
     lua_setglobal(L, "a");                         /* set global 'a' */
</pre><p>
注意上面這段代碼是 <em>平衡</em> 的：
到了最後，堆堆疊恢復成原有的配置。
這是一種良好的編程習慣。




<hr><h3><a name="lua_callk"><code>lua_callk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +nresults, <em>e</em>]</span>
<pre>void lua_callk (lua_State *L,
                int nargs,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
這個函式的行為和 <a href="#lua_call"><code>lua_call</code></a>
完全一致，只不過它還允許被調用的函式讓出
（參見 <a href="#4.7">&sect;4.7</a>）。





<hr><h3><a name="lua_CFunction"><code>lua_CFunction</code></a></h3>
<pre>typedef int (*lua_CFunction) (lua_State *L);</pre>

<p>
C 函式的型別。


<p>
為了正確的和 Lua 通訊，
C 函式必須使用下列協議。
這個協議定義了參數以及返回值傳遞方法：
C 函式通過 Lua 中的堆疊來接受參數，
參數以正序入堆疊（第一個參數首先入堆疊）。
因此，當函式開始的時候，
<code>lua_gettop(L)</code> 可以返回函式收到的參數個數。
第一個參數（如果有的話）在索引 1 的地方，
而最後一個參數在索引 <code>lua_gettop(L)</code> 處。 
當需要向 Lua 返回值的時候，
C 函式只需要把它們以正序壓到堆堆疊上（第一個返回值最先壓入），
然後返回這些返回值的個數。
在這些返回值之下的，堆堆疊上的東西都會被 Lua 丟掉。
和 Lua 函式一樣，從 Lua 中調用 C 函式也可以有很多返回值。

<p>
下面這個例子中的函式將接收若干數字參數，並返回它們的平均數與和：

<pre>
     static int foo (lua_State *L) {
       int n = lua_gettop(L);    /* 參數的個數 */
       lua_Number sum = 0.0;
       int i;
       for (i = 1; i &lt;= n; i++) {
         if (!lua_isnumber(L, i)) {
           lua_pushliteral(L, "incorrect argument");
           lua_error(L);
         }
         sum += lua_tonumber(L, i);
       }
       lua_pushnumber(L, sum/n);        /* 第一個返回值 */
       lua_pushnumber(L, sum);         /* 第二個返回值 */
       return 2;                   /* 返回值的個數 */
     }
</pre>




<hr><h3><a name="lua_checkstack"><code>lua_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_checkstack (lua_State *L, int n);</pre>

<p>
確保堆堆疊上至少有 <code>n</code> 個額外空位。
如果不能把堆堆疊擴展到相應的尺寸，函式返回假。
失敗的原因包括將把堆疊擴展到比固定最大尺寸還大
（至少是幾千個元素）或分配記憶體失敗。
這個函式永遠不會縮小堆堆疊；
如果堆堆疊已經比需要的大了，那麼就保持原樣。




<hr><h3><a name="lua_close"><code>lua_close</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_close (lua_State *L);</pre>

<p>
銷毀指定 Lua 狀態機中的所有對象
（如果有垃圾收集相關的元方法的話，會調用它們），
並且釋放狀態機中使用的所有動態記憶體。
在一些平台上，你可以不必調用這個函式， 
因為當宿主程序結束的時候，所有的資源就自然被釋放掉了。
另一方面，長期運行的程序，比如一個後台程序或是一個網站服務器，
會創建出多個 Lua 狀態機。那麼就應該在不需要時趕緊關閉它們。




<hr><h3><a name="lua_compare"><code>lua_compare</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_compare (lua_State *L, int index1, int index2, int op);</pre>

<p>
比較兩個 Lua 值。
當索引 <code>index1</code> 處的值通過 <code>op</code>
和索引 <code>index2</code> 處的值做比較後條件滿足，函式返回 1 。
這個函式遵循 Lua 對應的操作規則（即有可能觸發元方法）。
反之，函式返回 0。
當任何一個索引無效時，函式也會返回 0 。


<p>
<code>op</code> 值必須是下列常量中的一個：

<ul>

<li><b><a name="pdf-LUA_OPEQ"><code>LUA_OPEQ</code></a>: </b> 相等比較 (<code>==</code>)</li>
<li><b><a name="pdf-LUA_OPLT"><code>LUA_OPLT</code></a>: </b> 小於比較 (<code>&lt;</code>)</li>
<li><b><a name="pdf-LUA_OPLE"><code>LUA_OPLE</code></a>: </b> 小於等於比較 (<code>&lt;=</code>)</li>

</ul>




<hr><h3><a name="lua_concat"><code>lua_concat</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_concat (lua_State *L, int n);</pre>

<p>
連接堆疊頂的 <code>n</code> 個值，
然後將這些值出堆疊，並把結果放在堆疊頂。
如果 <code>n</code> 為 1 ，結果就是那個值放在堆疊上（即，函式什麼都不做）；
如果 <code>n</code> 為 0 ，結果是一個空串。 
連接依照 Lua 中通常語義完成（參見 <a href="#3.4.6">&sect;3.4.6</a> ）。




<hr><h3><a name="lua_copy"><code>lua_copy</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_copy (lua_State *L, int fromidx, int toidx);</pre>

<p>
從索引 <code>fromidx</code> 處複製一個值到一個有效索引
<code>toidx</code> 處，覆蓋那裡的原有值。
不會影響其它位置的值。



<hr><h3><a name="lua_createtable"><code>lua_createtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_createtable (lua_State *L, int narr, int nrec);</pre>

<p>
創建一張新的空表壓堆疊。
參數 <code>narr</code> 建議了這張表作為序列使用時會有多少個元素；
參數 <code>nrec</code> 建議了這張表可能擁有多少序列之外的元素。
Lua 會使用這些建議來預分配這張新表。
如果你知道這張表用途的更多信息，預分配可以提高性能。
否則，你可以使用函式 <a href="#lua_newtable"><code>lua_newtable</code></a> 。



<hr><h3><a name="lua_dump"><code>lua_dump</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_dump (lua_State *L,
                        lua_Writer writer,
                        void *data,
                        int strip);</pre>

<p>
把函式導出成二進制代碼塊 。
函式接收堆疊頂的 Lua 函式做參數，
然後生成它的二進制代碼塊。
若被導出的東西被再次加載，
加載的結果就相當於原來的函式。
當它在產生代碼塊的時候，
<a href="#lua_dump"><code>lua_dump</code></a>
通過調用函式 <code>writer</code>
（參見 <a href="#lua_Writer"><code>lua_Writer</code></a> ）
來寫入數據，後面的 <code>data</code> 參數會被傳入 <code>writer</code> 。

<p>
如果 <code>strip</code> 為真，
二進制代碼塊將不包含該函式的調試信息。


<p>
最後一次由 <code>writer</code> 的返回值將作為這個函式的返回值返回；
0 表示沒有錯誤。


<p>
該函式不會把 Lua 函式彈出堆堆疊。



<hr><h3><a name="lua_error"><code>lua_error</code></a></h3><p>
<span class="apii">[-1, +0, <em>v</em>]</span>
<pre>int lua_error (lua_State *L);</pre>

<p>
以堆疊頂的值作為錯誤對象，拋出一個 Lua 錯誤。
這個函式將做一次長跳轉，所以一定不會返回
（參見 <a href="#luaL_error"><code>luaL_error</code></a>）。




<hr><h3><a name="lua_gc"><code>lua_gc</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>int lua_gc (lua_State *L, int what, int data);</pre>

<p>
控制垃圾收集器。


<p>
這個函式根據其參數 <code>what</code> 發起幾種不同的任務：

<ul>

<li><b><code>LUA_GCSTOP</code>: </b>
停止垃圾收集器。
</li>

<li><b><code>LUA_GCRESTART</code>: </b>
重啟垃圾收集器。
</li>

<li><b><code>LUA_GCCOLLECT</code>: </b>
發起一次完整的垃圾收集循環。
</li>

<li><b><code>LUA_GCCOUNT</code>: </b>
返回 Lua 使用的記憶體總量（以 K 字節為單位）。
</li>

<li><b><code>LUA_GCCOUNTB</code>: </b>
返回當前記憶體使用量除以 1024 的餘數。
</li>

<li><b><code>LUA_GCSTEP</code>: </b>
發起一步增量垃圾收集。
</li>

<li><b><code>LUA_GCSETPAUSE</code>: </b>
把 <code>data</code> 設為 <em>垃圾收集器間歇率</em> 
（參見 <a href="#2.5">&sect;2.5</a>），並返回之前設置的值。
</li>

<li><b><code>LUA_GCSETSTEPMUL</code>: </b>
把 <code>data</code> 設為 <em>垃圾收集器步進倍率</em> 
（參見 <a href="#2.5">&sect;2.5</a>），並返回之前設置的值。
</li>

<li><b><code>LUA_GCISRUNNING</code>: </b>
返回收集器是否在運行（即沒有停止）。
</li>

</ul>

<p>
關於這些選項的細節，參見 <a href="#pdf-collectgarbage"><code>collectgarbage</code></a> 。





<hr><h3><a name="lua_getallocf"><code>lua_getallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Alloc lua_getallocf (lua_State *L, void **ud);</pre>

<p>
返回給定狀態機的記憶體分配器函式。
如果 <code>ud</code> 不是 <code>NULL</code> ，
Lua 把設置記憶體分配函式時設置的那個指針置入 <code>*ud</code> 。




<hr><h3><a name="lua_getfield"><code>lua_getfield</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getfield (lua_State *L, int index, const char *k);</pre>

<p>
把 <code>t[k]</code> 的值壓堆疊，
這裡的 <code>t</code> 是索引指向的值。
在 Lua 中，這個函式可能觸發對應 "index" 事件對應的元方法
（參見 <a href="#2.4">&sect;2.4</a> ）。


<p>
函式將返回壓入值的型別。




<hr><h3><a name="lua_getextraspace"><code>lua_getextraspace</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_getextraspace (lua_State *L);</pre>

<p>
返回一個 Lua 狀態機中關聯的記憶體塊指針。
程序可以把這塊記憶體用於任何用途；而 Lua 不會使用它。


<p>
每一個新線程都會攜帶一塊記憶體，
初始化為主線程的這塊記憶體的副本。


<p>
默認配置下，這塊記憶體的大小為空指針的大小。
不過你可以重新編譯 Lua 設定這塊記憶體不同的大小。
（參見 <code>luaconf.h</code> 中的 <code>LUA_EXTRASPACE</code>。）




<hr><h3><a name="lua_getglobal"><code>lua_getglobal</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_getglobal (lua_State *L, const char *name);</pre>

<p>
把全局變量 <name>name</name> 裡的值壓堆疊，返回該值的型別。





<hr><h3><a name="lua_geti"><code>lua_geti</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int lua_geti (lua_State *L, int index, lua_Integer i);</pre>

<p>
把 <code>t[i]</code> 的值壓堆疊，
這裡的 <code>t</code> 指給定的索引指代的值。
和在 Lua 裡一樣，這個函式可能會觸發 "index" 事件的元方法
（參見 <a href="#2.4">&sect;2.4</a>）。


<p>
返回壓入值的型別。





<hr><h3><a name="lua_getmetatable"><code>lua_getmetatable</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>int lua_getmetatable (lua_State *L, int index);</pre>

<p>
如果該索引處的值有元表，則將其元表壓堆疊，返回 1 。
否則不會將任何東西入堆疊，返回 0 。




<hr><h3><a name="lua_gettable"><code>lua_gettable</code></a></h3><p>
<span class="apii">[-1, +1, <em>e</em>]</span>
<pre>int lua_gettable (lua_State *L, int index);</pre>

<p>
把 <code>t[k]</code> 的值壓堆疊，
這裡的 <code>t</code> 是指索引指向的值，
而 <code>k</code> 則是堆疊頂放的值。


<p>
這個函式會彈出堆堆疊上的鍵，把結果放在堆疊上相同位置。
和在 Lua 中一樣，
這個函式可能觸發對應 "index" 事件的元方法 
（參見 <a href="#2.4">&sect;2.4</a> ）。


<p>
返回壓入值的型別。




<hr><h3><a name="lua_gettop"><code>lua_gettop</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gettop (lua_State *L);</pre>

<p>
返回堆疊頂元素的索引。 
因為索引是從 1 開始編號的，
所以這個結果等於堆疊上的元素個數；
特別指出，0 表示堆疊為空。



<hr><h3><a name="lua_getuservalue"><code>lua_getuservalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_getuservalue (lua_State *L, int index);</pre>

<p>
將給定索引處的用戶數據所關聯的 Lua 值壓堆疊。

<p>
返回壓入值的型別。




<hr><h3><a name="lua_insert"><code>lua_insert</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>void lua_insert (lua_State *L, int index);</pre>

<p>
把堆疊頂元素移動到指定的有效索引處，
依次移動這個索引之上的元素。
不要用偽索引來調用這個函式，
因為偽索引沒有真正指向堆疊上的位置。



<hr><h3><a name="lua_Integer"><code>lua_Integer</code></a></h3>
<pre>typedef ... lua_Integer;</pre>

<p>
Lua 中的整數型別。


<p>
缺省時，這個就是 <code>long long</code>，
（通常是一個 64 位以二為補碼的整數），
也可以修改它為 <code>long</code> 或 <code>int</code>
（通常是一個 32 位以二為補碼的整數）。
（參見 <code>luaconf.h</code> 中的 <code>LUA_INT</code> 。）

<p>
Lua 定義了兩個常量：
<a name="pdf-LUA_MININTEGER"><code>LUA_MININTEGER</code></a> 和
<a name="pdf-LUA_MAXINTEGER"><code>LUA_MAXINTEGER</code></a>
來表示這個型別可以表示的最小和最大值。




<hr><h3><a name="lua_isboolean"><code>lua_isboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isboolean (lua_State *L, int index);</pre>

<p>
當給定索引的值是一個布爾量時，返回 1 ，否則返回 0 。



<hr><h3><a name="lua_iscfunction"><code>lua_iscfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_iscfunction (lua_State *L, int index);</pre>

<p>
當給定索引的值是一個 C 函式時，返回 1 ，否則返回 0 。



<hr><h3><a name="lua_isfunction"><code>lua_isfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isfunction (lua_State *L, int index);</pre>

<p>
當給定索引的值是一個函式（ C 或 Lua 函式均可）時，返回 1 ，否則返回 0 。



<hr><h3><a name="lua_isinteger"><code>lua_isinteger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isinteger (lua_State *L, int index);</pre>

<p>
當給定索引的值是一個整數
（其值是一個數字，且內部以整數儲存），
時，返回 1 ，否則返回 0 。



<hr><h3><a name="lua_islightuserdata"><code>lua_islightuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_islightuserdata (lua_State *L, int index);</pre>

<p>
當給定索引的值是一個輕量用戶數據時，返回 1 ，否則返回 0 。




<hr><h3><a name="lua_isnil"><code>lua_isnil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnil (lua_State *L, int index);</pre>

<p>
當給定索引的值是 <b>nil</b> 時，返回 1 ，否則返回 0 。




<hr><h3><a name="lua_isnone"><code>lua_isnone</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnone (lua_State *L, int index);</pre>

<p>
當給定索引無效時，返回 1 ，否則返回 0 。




<hr><h3><a name="lua_isnoneornil"><code>lua_isnoneornil</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnoneornil (lua_State *L, int index);</pre>

<p>
當給定索引無效或其值是 <b>nil</b> 時，
返回 1 ，否則返回 0 。



<hr><h3><a name="lua_isnumber"><code>lua_isnumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isnumber (lua_State *L, int index);</pre>

<p>
當給定索引的值是一個數字，或是一個可轉換為數字的字串時，返回 1 ，否則返回 0 。




<hr><h3><a name="lua_isstring"><code>lua_isstring</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isstring (lua_State *L, int index);</pre>

<p>
當給定索引的值是一個字串或是一個數字
（數字總能轉換成字串）時，返回 1 ，否則返回 0 。




<hr><h3><a name="lua_istable"><code>lua_istable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_istable (lua_State *L, int index);</pre>

<p>
當給定索引的值是一張表時，返回 1 ，否則返回 0 。



<hr><h3><a name="lua_isthread"><code>lua_isthread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isthread (lua_State *L, int index);</pre>

<p>
當給定索引的值是一條線程時，返回 1 ，否則返回 0 。



<hr><h3><a name="lua_isuserdata"><code>lua_isuserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isuserdata (lua_State *L, int index);</pre>

<p>
當給定索引的值是一個用戶數據（無論是完全的還是輕量的）時，
返回 1 ，否則返回 0 。



<hr><h3><a name="lua_isyieldable"><code>lua_isyieldable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_isyieldable (lua_State *L);</pre>

<p>
如果給定的協程可以讓出，返回 1 ，否則返回 0 。


<hr><h3><a name="lua_KContext"><code>lua_KContext</code></a></h3>
<pre>typedef ... lua_KContext;</pre>

<p>
延續函式上下文參數的型別。
這一定是一個數字型別。
當有 <code>intptr_t</code> 時，被定義為 <code>intptr_t</code> ，
因此它也可以保存指針。
否則，它被定義為 <code>ptrdiff_t</code>。



<hr><h3><a name="lua_KFunction"><code>lua_KFunction</code></a></h3>
<pre>typedef int (*lua_KFunction) (lua_State *L, int status, lua_KContext ctx);</pre>

<p>
延續函式的型別（參見 <a href="#4.7">&sect;4.7</a> ）。




<hr><h3><a name="lua_len"><code>lua_len</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_len (lua_State *L, int index);</pre>

<p>
返回給定索引的值的長度。
它等價於 Lua 中的 '<code>#</code>' 操作符
（參見 <a href="#3.4.7">&sect;3.4.7</a>）。
它有可能觸發 "length" 事件對應的元方法
（參見 <a href="#2.4">&sect;2.4</a> ）。
結果壓堆疊。




<hr><h3><a name="lua_load"><code>lua_load</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_load (lua_State *L,
              lua_Reader reader,
              void *data,
              const char *chunkname,
              const char *mode);</pre>

<p>
加載一段 Lua 代碼塊，但不運行它。
如果沒有錯誤，
<code>lua_load</code> 把一個編譯好的代碼塊作為一個 Lua 函式壓到堆疊頂。
否則，壓入錯誤消息。


<p>
<code>lua_load</code> 的返回值可以是：

<ul>

<li><b><a href="#pdf-LUA_OK"><code>LUA_OK</code></a>: </b> 沒有錯誤；</li>

<li><b><a name="pdf-LUA_ERRSYNTAX"><code>LUA_ERRSYNTAX</code></a>: </b>
在預編譯時碰到語法錯誤；</li>

<li><b><a href="#pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
記憶體分配錯誤；</li>

<li><b><a href="#pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
在運行 <code>__gc</code> 元方法時出錯了。
（這個錯誤和代碼塊加載過程無關，它是由垃圾收集器引發的。）
</li>

</ul>

<p>
<code>lua_load</code> 函式使用一個用戶提供的 <code>reader</code>
函式來讀取代碼塊（參見 <a href="#lua_Reader"><code>lua_Reader</code></a> ）。
<code>data</code> 參數會被傳入 <code>reader</code> 函式。


<p>
<code>chunkname</code> 這個參數可以賦予代碼塊一個名字，
這個名字被用於出錯信息和調試信息（參見  <a href="#4.9">&sect;4.9</a>）。


<p>
<code>lua_load</code> 會自動檢測代碼塊是文本的還是二進制的，
然後做對應的加載操作（參見程序 <code>luac</code> ）。
字串 <code>mode</code> 的作用和函式 <a href="#pdf-load"><code>load</code></a> 一致。
它還可以是 <code>NULL</code> 等價於字串 "<code>bt</code>"。


<p>
<code>lua_load</code> 的內部會使用堆疊，
因此 reader 函式必須永遠在每次返回時保留堆疊的原樣。


<p>
如果返回的函式有上值，
第一個上值會被設置為
保存在註冊表（參見 <a href="#4.5">&sect;4.5</a>）
<code>LUA_RIDX_GLOBALS</code> 索引處的全局環境。
在加載主代碼塊時，這個上值是 <code>_ENV</code> 變量（參見 <a href="#2.2">&sect;2.2</a>）。
其它上值均被初始化為 <b>nil</b>。




<hr><h3><a name="lua_newstate"><code>lua_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_newstate (lua_Alloc f, void *ud);</pre>

<p>
創建一個運行在新的獨立的狀態機中的線程。
如果無法創建線程或狀態機（由於記憶體有限）則返回 <code>NULL</code>。
參數 <code>f</code> 是一個分配器函式； 
Lua 將通過這個函式做狀態機內所有的記憶體分配操作。
第二個參數 <code>ud</code> ，這個指針將在每次調用分配器時被轉入。



<hr><h3><a name="lua_newtable"><code>lua_newtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void lua_newtable (lua_State *L);</pre>

<p>
創建一張空表，並將其壓堆疊。
它等價於 <code>lua_createtable(L, 0, 0)</code> 。




<hr><h3><a name="lua_newthread"><code>lua_newthread</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>lua_State *lua_newthread (lua_State *L);</pre>

<p>
創建一條新線程，並將其壓堆疊，
並返回維護這個線程的 <a href="#lua_State"><code>lua_State</code></a> 指針。
這個函式返回的新線程共享原線程的全局環境， 但是它有獨立的運行堆疊。



<p>
沒有顯式的函式可以用來關閉或銷毀掉一個線程。
線程跟其它 Lua 對像一樣是垃圾收集的條目之一。




<hr><h3><a name="lua_newuserdata"><code>lua_newuserdata</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void *lua_newuserdata (lua_State *L, size_t size);</pre>

<p>
這個函式分配分配一塊指定大小的記憶體塊，
把記憶體塊地址作為一個完全用戶數據壓堆疊，
並返回這個地址。

宿主程序可以隨意使用這塊記憶體。



<hr><h3><a name="lua_next"><code>lua_next</code></a></h3><p>
<span class="apii">[-1, +(2|0), <em>e</em>]</span>
<pre>int lua_next (lua_State *L, int index);</pre>

<p>
從堆疊頂彈出一個鍵，
然後把索引指定的表中的一個鍵值對壓堆疊 （彈出的鍵之後的 「下一」 對）。
如果表中以無更多元素，
那麼 <a href="#lua_next"><code>lua_next</code></a> 將返回 0 （什麼也不壓堆疊）。



<p>
典型的遍歷方法是這樣的：

<pre>
     /*  表放在索引 't' 處 */
     lua_pushnil(L);  /* 第一個鍵 */
     while (lua_next(L, t) != 0) {
       /* 使用 '鍵' （在索引 -2 處） 和 '值' （在索引 -1 處）*/
       printf("%s - %s\n",
              lua_typename(L, lua_type(L, -2)),
              lua_typename(L, lua_type(L, -1)));
       /* 移除 '值' ；保留 '鍵' 做下一次迭代 */
       lua_pop(L, 1);
     }
</pre>

<p>
在遍歷一張表的時候，
不要直接對鍵調用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> ，
除非你知道這個鍵一定是一個字串。
調用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> 有可能改變給定索引位置的值；
這會對下一次調用 <a href="#lua_next"><code>lua_next</code></a> 造成影響。


<p>
關於迭代過程中修改被迭代的表的注意事項參見 <a href="#pdf-next"><code>next</code></a> 函式。



<hr><h3><a name="lua_Number"><code>lua_Number</code></a></h3>
<pre>typedef double lua_Number;</pre>

<p>
Lua 中浮點數的型別。


<p>
Lua 中數字的型別。缺省是 double ，但是你可以改成 float 。
（參見 <code>luaconf.h</code> 中的 <code>LUA_REAL</code> 。）




<hr><h3><a name="lua_numbertointeger"><code>lua_numbertointeger</code></a></h3>
<pre>int lua_numbertointeger (lua_Number n, lua_Integer *p);</pre>

<p>
將一個 Lua 浮點數轉換為一個 Lua 整數。
這個宏假設 <code>n</code> 有對應的整數值。
如果該值在 Lua 整數可表示範圍內，
就將其轉換為一個整數賦給 <code>*p</code>。
宏的結果是一個布爾量，表示轉換是否成功。
（注意、由於圓整關係，這個範圍測試不用此宏很難做對。）


<p>
該宏有可能對其參數做多次取值。




<hr><h3><a name="lua_pcall"><code>lua_pcall</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcall (lua_State *L, int nargs, int nresults, int msgh);</pre>

<p>
以保護模式調用一個函式。


<p>
<code>nargs</code> 和 <code>nresults</code> 的含義與 <a href="#lua_call"><code>lua_call</code></a> 中的相同。
如果在調用過程中沒有發生錯誤，
<a href="#lua_pcall"><code>lua_pcall</code></a> 的行為和 <a href="#lua_call"><code>lua_call</code></a> 完全一致。 
但是，如果有錯誤發生的話，
<a href="#lua_pcall"><code>lua_pcall</code></a> 會捕獲它，
然後把唯一的值（錯誤消息）壓堆疊，然後返回錯誤碼。 
同 <a href="#lua_call"><code>lua_call</code></a> 一樣，
<a href="#lua_pcall"><code>lua_pcall</code></a> 總是把函式本身和它的參數從堆疊上移除。


<p>
如果 <code>msgh</code> 是 0 ，
返回在堆疊頂的錯誤消息就和原始錯誤消息完全一致。
否則， <code>msgh</code> 就被當成是 <em>錯誤處理函式</em> 在堆疊上的索引位置。 
（在當前的實現裡，這個索引不能是偽索引。）
在發生運行時錯誤時，
這個函式會被調用而參數就是錯誤消息。
錯誤處理函式的返回值將被 <a href="#lua_pcall"><code>lua_pcall</code></a>
作為錯誤消息返回在堆堆疊上。

<p>
典型的用法中，錯誤處理函式被用來給錯誤消息加上更多的調試信息，
比如堆疊跟蹤信息。
這些信息在 <a href="#lua_pcall"><code>lua_pcall</code></a> 返回後，
由於堆疊已經展開，所以收集不到了。

<p>
<a href="#lua_pcall"><code>lua_pcall</code></a> 函式會返回下列常數
（定義在 <code>lua.h</code> 內）中的一個：

<ul>

<li><b><a name="pdf-LUA_OK"><code>LUA_OK</code></a> (0): </b>
成功。</li>

<li><b><a name="pdf-LUA_ERRRUN"><code>LUA_ERRRUN</code></a>: </b>
運行時錯誤。
</li>

<li><b><a name="pdf-LUA_ERRMEM"><code>LUA_ERRMEM</code></a>: </b>
記憶體分配錯誤。對於這種錯，Lua 不會調用錯誤處理函式。
</li>

<li><b><a name="pdf-LUA_ERRERR"><code>LUA_ERRERR</code></a>: </b>
在運行錯誤處理函式時發生的錯誤。
</li>

<li><b><a name="pdf-LUA_ERRGCMM"><code>LUA_ERRGCMM</code></a>: </b>
在運行 <code>__gc</code> 元方法時發生的錯誤。
（這個錯誤和被調用的函式無關。）
</li>

</ul>




<hr><h3><a name="lua_pcallk"><code>lua_pcallk</code></a></h3><p>
<span class="apii">[-(nargs + 1), +(nresults|1), &ndash;]</span>
<pre>int lua_pcallk (lua_State *L,
                int nargs,
                int nresults,
                int msgh,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
這個函式的行為和 <a href="#lua_pcall"><code>lua_pcall</code></a>
完全一致，只不過它還允許被調用的函式讓出
（參見 <a href="#4.7">&sect;4.7</a>）。




<hr><h3><a name="lua_pop"><code>lua_pop</code></a></h3><p>
<span class="apii">[-n, +0, &ndash;]</span>
<pre>void lua_pop (lua_State *L, int n);</pre>

<p>
從堆疊中彈出 <code>n</code> 個元素。




<hr><h3><a name="lua_pushboolean"><code>lua_pushboolean</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushboolean (lua_State *L, int b);</pre>

<p>
把 <code>b</code> 作為一個布爾量壓堆疊。



<hr><h3><a name="lua_pushcclosure"><code>lua_pushcclosure</code></a></h3><p>
<span class="apii">[-n, +1, <em>e</em>]</span>
<pre>void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);</pre>

<p>
把一個新的 C Closure 壓堆疊。

<p>
當創建了一個 C 函式後，
你可以給它關聯一些值，
這就是在創建一個 C Closure（參見 <a href="#4.4">&sect;4.4</a>）；
接下來無論函式何時被調用，這些值都可以被這個函式訪問到。
為了將一些值關聯到一個 C 函式上，
首先這些值需要先被壓入堆堆疊（如果有多個值，第一個先壓）。
接下來調用 <a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a>
來創建出 Closure 並把這個 C 函式壓到堆疊上。
參數 <code>n</code> 告之函式有多少個值需要關聯到函式上。
<a href="#lua_pushcclosure"><code>lua_pushcclosure</code></a> 也會把這些值從堆疊上彈出。


<p>
<code>n</code> 的最大值是 255 。


<p>
當 <code>n</code> 為零時，
這個函式將創建出一個 <em>輕量 C 函式</em>，
它就是一個指向 C 函式的指針。
這種情況下，不可能拋出記憶體錯誤。



<hr><h3><a name="lua_pushcfunction"><code>lua_pushcfunction</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushcfunction (lua_State *L, lua_CFunction f);</pre>

<p>
將一個 C 函式壓堆疊。 
這個函式接收一個 C 函式指針，
並將一個型別為 <code>function</code> 的 Lua 值壓堆疊。
當這個堆疊頂的值被調用時，將觸發對應的 C 函式。


<p>
註冊到 Lua 中的任何函式都必須遵循正確的協議來接收參數和返回值
（參見 <a href="#lua_CFunction"><code>lua_CFunction</code></a> ）。


<p>
<code>lua_pushcfunction</code> 是作為一個宏定義出現的：

<pre>
     #define lua_pushcfunction(L,f)  lua_pushcclosure(L,f,0)
</pre>



<hr><h3><a name="lua_pushfstring"><code>lua_pushfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushfstring (lua_State *L, const char *fmt, ...);</pre>

<p>
把一個格式化過的字串壓堆疊，
然後返回這個字串的指針。 
它和 C 函式 <code>sprintf</code> 比較像，
不過有一些重要的區別：

<ul>

<li>
你不需要為結果分配空間：
其結果是一個 Lua 字串，由 Lua 來關心其記憶體分配 （同時通過垃圾收集來釋放記憶體）。
</li>

<li>
這個轉換非常的受限。
不支持符號、寬度、精度。
轉換符只支持
'<code>%%</code>' （插入一個字符 '<code>%</code>'），
'<code>%s</code>' （插入一個帶零終止符的字串，沒有長度限制）,
'<code>%f</code>' （插入一個 <a href="#lua_Number"><code>lua_Number</code></a>），
'<code>%L</code>' （插入一個 <a href="#lua_Integer"><code>lua_Integer</code></a>），
'<code>%p</code>' （插入一個指針或是一個十六進制數），
'<code>%d</code>' （插入一個 <code>int</code>），
'<code>%c</code>' （插入一個用 <code>int</code> 表示的單字節字符），以及
'<code>%U</code>' （插入一個用 <code>long int</code> 表示的 UTF-8 字）。
</li>

</ul>




<hr><h3><a name="lua_pushglobaltable"><code>lua_pushglobaltable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushglobaltable (lua_State *L);</pre>

<p>
將全局環境壓堆疊。




<hr><h3><a name="lua_pushinteger"><code>lua_pushinteger</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushinteger (lua_State *L, lua_Integer n);</pre>

<p>
把值為 <code>n</code> 的整數壓堆疊。





<hr><h3><a name="lua_pushlightuserdata"><code>lua_pushlightuserdata</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushlightuserdata (lua_State *L, void *p);</pre>

<p>
把一個輕量用戶數據壓堆疊。


<p>
用戶數據是保留在 Lua 中的 C 值。
<em>輕量用戶數據</em> 表示一個指針 <code>void*</code>。
它是一個像數字一樣的值：
你不需要專門創建它，它也沒有獨立的元表，而且也不會被收集（因為從來不需要創建）。
只要表示的 C 地址相同，兩個輕量用戶數據就相等。



<hr><h3><a name="lua_pushliteral"><code>lua_pushliteral</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushliteral (lua_State *L, const char *s);</pre>

<p>
這個宏等價於 <a href="#lua_pushlstring"><code>lua_pushlstring</code></a>，
區別僅在於只能在 <code>s</code> 是一個字面量時才能用它。
它會自動給出字串的長度。




<hr><h3><a name="lua_pushlstring"><code>lua_pushlstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushlstring (lua_State *L, const char *s, size_t len);</pre>

<p>
把指針 <code>s</code> 指向的長度為 <code>len</code> 的字串壓堆疊。
Lua 對這個字串做一個內部副本（或是復用一個副本），
因此 <code>s</code> 處的記憶體在函式返回後，可以釋放掉或是立刻重用於其它用途。
字串內可以是任意二進制數據，包括零字符。



<p>
返回內部副本的指針。





<hr><h3><a name="lua_pushnil"><code>lua_pushnil</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnil (lua_State *L);</pre>

<p>
將空值壓堆疊。




<hr><h3><a name="lua_pushnumber"><code>lua_pushnumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushnumber (lua_State *L, lua_Number n);</pre>

<p>
把一個值為 <code>n</code> 的浮點數壓堆疊。




<hr><h3><a name="lua_pushstring"><code>lua_pushstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushstring (lua_State *L, const char *s);</pre>

<p>
將指針 s 指向的零結尾的字串壓堆疊。
因此 <code>s</code> 處的記憶體在函式返回後，可以釋放掉或是立刻重用於其它用途。


<p>
返回內部副本的指針。


<p>
如果 <code>s</code> 為 <code>NULL</code>，將 <b>nil</b> 壓堆疊並返回 <code>NULL</code>。





<hr><h3><a name="lua_pushthread"><code>lua_pushthread</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_pushthread (lua_State *L);</pre>

<p>
把 <code>L</code> 表示的線程壓堆疊。
如果這個線程是當前狀態機的主線程的話，返回 1 。




<hr><h3><a name="lua_pushvalue"><code>lua_pushvalue</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>void lua_pushvalue (lua_State *L, int index);</pre>

<p>
把堆疊上給定索引處的元素作一個副本壓堆疊。




<hr><h3><a name="lua_pushvfstring"><code>lua_pushvfstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *lua_pushvfstring (lua_State *L,
                              const char *fmt,
                              va_list argp);</pre>

<p>
等價於 <a href="#lua_pushfstring"><code>lua_pushfstring</code></a> ，
不過是用 <code>va_list</code> 接收參數，而不是用可變數量的實際參數。



<hr><h3><a name="lua_rawequal"><code>lua_rawequal</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_rawequal (lua_State *L, int index1, int index2);</pre>

<p>
如果索引 <code>index1</code> 與索引 <code>index2</code> 處的值
本身相等（即不調用元方法），返回 1 。
否則返回 0 。
當任何一個索引無效時，也返回 0 。



<hr><h3><a name="lua_rawget"><code>lua_rawget</code></a></h3><p>
<span class="apii">[-1, +1, &ndash;]</span>
<pre>int lua_rawget (lua_State *L, int index);</pre>

<p>
類似於 <a href="#lua_gettable"><code>lua_gettable</code></a> ，
但是作一次直接訪問（不觸發元方法）。



<hr><h3><a name="lua_rawgeti"><code>lua_rawgeti</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgeti (lua_State *L, int index, lua_Integer n);</pre>

<p>
把 <code>t[n]</code> 的值壓堆疊，
這裡的 <code>t</code> 是指給定索引處的表。
這是一次直接訪問；就是說，它不會觸發元方法。


<p>
返回入堆疊值的型別。





<hr><h3><a name="lua_rawgetp"><code>lua_rawgetp</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int lua_rawgetp (lua_State *L, int index, const void *p);</pre>

<p>
把 <code>t[k]</code> 的值壓堆疊，
這裡的 <code>t</code> 是指給定索引處的表，
<code>k</code> 是指針 <code>p</code> 對應的輕量用戶數據。
這是一次直接訪問；就是說，它不會觸發元方法。



<p>
返回入堆疊值的型別。





<hr><h3><a name="lua_rawlen"><code>lua_rawlen</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>size_t lua_rawlen (lua_State *L, int index);</pre>

<p>
返回給定索引處值的固有「長度」：
對於字串，它指字串的長度；
對於表；它指不觸發元方法的情況下取長度操作（'<code>#</code>'）應得到的值；
對於用戶數據，它指為該用戶數據分配的記憶體塊的大小；
對於其它值，它為 0 。




<hr><h3><a name="lua_rawset"><code>lua_rawset</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_rawset (lua_State *L, int index);</pre>

<p>
類似於 <a href="#lua_settable"><code>lua_settable</code></a> ，
但是是做一次直接賦值（不觸發元方法）。





<hr><h3><a name="lua_rawseti"><code>lua_rawseti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawseti (lua_State *L, int index, lua_Integer i);</pre>

<p>
等價於 <code>t[i] = v</code> ，
這裡的 <code>t</code> 是指給定索引處的表，
而 <code>v</code> 是堆疊頂的值。

<p>
這個函式會將值彈出堆疊。
賦值是直接的；即不會觸發元方法。




<hr><h3><a name="lua_rawsetp"><code>lua_rawsetp</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_rawsetp (lua_State *L, int index, const void *p);</pre>

<p>
等價於 <code>t[k] = v</code> ，
這裡的 <code>t</code> 是指給定索引處的表，
<code>k</code> 是指針 <code>p</code> 對應的輕量用戶數據。
而 <code>v</code> 是堆疊頂的值。


<p>
這個函式會將值彈出堆疊。
賦值是直接的；即不會觸發元方法。




<hr><h3><a name="lua_Reader"><code>lua_Reader</code></a></h3>
<pre>typedef const char * (*lua_Reader) (lua_State *L,
                                    void *data,
                                    size_t *size);</pre>

<p>
<a href="#lua_load"><code>lua_load</code></a> 用到的讀取器函式，
每次它需要一塊新的代碼塊的時候，
<a href="#lua_load"><code>lua_load</code></a> 就調用讀取器，
每次都會傳入一個參數 <code>data</code> 。
讀取器需要返回含有新的代碼塊的一塊記憶體的指針，
並把 <code>size</code> 設為這塊記憶體的大小。
記憶體塊必須在下一次函式被調用之前一直存在。
讀取器可以通過返回 <code>NULL</code> 或設 <code>size</code> 為 0 來指示代碼塊結束。
讀取器可能返回多個塊，每個塊可以有任意的大於零的尺寸。




<hr><h3><a name="lua_register"><code>lua_register</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void lua_register (lua_State *L, const char *name, lua_CFunction f);</pre>

<p>
把 C 函式 <code>f</code> 設到全局變量 <code>name</code> 中。
它通過一個宏定義：

<pre>
     #define lua_register(L,n,f) \
            (lua_pushcfunction(L, f), lua_setglobal(L, n))
</pre>




<hr><h3><a name="lua_remove"><code>lua_remove</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_remove (lua_State *L, int index);</pre>

<p>
從給定有效索引處移除一個元素，
把這個索引之上的所有元素移下來填補上這個空隙。
不能用偽索引來調用這個函式，因為偽索引並不指向真實的堆疊上的位置。




<hr><h3><a name="lua_replace"><code>lua_replace</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_replace (lua_State *L, int index);</pre>

<p>
把堆疊頂元素放置到給定位置而不移動其它元素
（因此覆蓋了那個位置處的值），然後將堆疊頂元素彈出。



<hr><h3><a name="lua_resume"><code>lua_resume</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>int lua_resume (lua_State *L, lua_State *from, int nargs);</pre>

<p>
在給定線程中啟動或延續一條協程 。


<p>
要啟動一個協程的話，
你需要把主函式以及它需要的參數壓入線程堆疊；
然後調用 <a href="#lua_resume"><code>lua_resume</code></a> ，
把 <code>nargs</code> 設為參數的個數。
這次調用會在協程掛起時或是結束運行後返回。
當函式返回時，堆堆疊中會有傳給 <a href="#lua_yield"><code>lua_yield</code></a> 的所有值，
或是主函式的所有返回值。
當協程讓出， <a href="#lua_resume"><code>lua_resume</code></a>
返回 <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> ，
若協程結束運行且沒有任何錯誤時，返回 0 。
如果有錯則返回錯誤代碼（參見 <a href="#lua_pcall"><code>lua_pcall</code></a> ）。


<p>
在發生錯誤的情況下，
堆堆疊沒有展開，
因此你可以使用調試 API 來處理它。
錯誤消息放在堆疊頂在。


<p>
要延續一個協程，
你需要清除上次 <a href="#lua_yield"><code>lua_yield</code></a> 遺留下的所有結果，
你把需要傳給 <code>yield</code> 作結果的值壓堆疊，
然後調用 <a href="#lua_resume"><code>lua_resume</code></a> 。

<p>
參數 <code>from</code> 表示協程從哪個協程中來延續 <code>L</code> 的。
如果不存在這樣一個協程，這個參數可以是 <code>NULL</code> 。





<hr><h3><a name="lua_rotate"><code>lua_rotate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_rotate (lua_State *L, int idx, int n);</pre>

<p>
把從 <code>idx</code> 開始到堆疊頂的元素輪轉 <code>n</code> 個位置。
對於 <code>n</code> 為正數時，輪轉方向是向堆疊頂的；
當 <code>n</code> 為負數時，向堆疊底方向輪轉 <code>-n</code> 個位置。
<code>n</code> 的絕對值不可以比參於輪轉的切片長度大。





<hr><h3><a name="lua_setallocf"><code>lua_setallocf</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);</pre>

<p>
把指定狀態機的分配器函式換成帶上用戶數據 <code>ud</code> 的 <code>f</code> 。




<hr><h3><a name="lua_setfield"><code>lua_setfield</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setfield (lua_State *L, int index, const char *k);</pre>

<p>
做一個等價於 <code>t[k] = v</code> 的操作，
這裡 <code>t</code> 是給出的索引處的值，
而 <code>v</code> 是堆疊頂的那個值。


<p>
這個函式將把這個值彈出堆疊。
跟在 Lua 中一樣，這個函式可能觸發一個 "newindex" 事件的元方法
（參見 <a href="#2.4">&sect;2.4</a>）。




<hr><h3><a name="lua_setglobal"><code>lua_setglobal</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_setglobal (lua_State *L, const char *name);</pre>

<p>
從堆堆疊上彈出一個值，並將其設為全局變量 <code>name</code> 的新值。




<hr><h3><a name="lua_seti"><code>lua_seti</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>void lua_seti (lua_State *L, int index, lua_Integer n);</pre>

<p>
做一個等價於 <code>t[n] = v</code> 的操作，
這裡 <code>t</code> 是給出的索引處的值，
而 <code>v</code> 是堆疊頂的那個值。


<p>
這個函式將把這個值彈出堆疊。
跟在 Lua 中一樣，這個函式可能觸發一個 "newindex" 事件的元方法
（參見 <a href="#2.4">&sect;2.4</a>）。




<hr><h3><a name="lua_setmetatable"><code>lua_setmetatable</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setmetatable (lua_State *L, int index);</pre>

<p>
把一張表彈出堆疊，並將其設為給定索引處的值的元表。




<hr><h3><a name="lua_settable"><code>lua_settable</code></a></h3><p>
<span class="apii">[-2, +0, <em>e</em>]</span>
<pre>void lua_settable (lua_State *L, int index);</pre>

<p>
做一個等價於 <code>t[k] = v</code> 的操作，
這裡 <code>t</code> 是給出的索引處的值，
<code>v</code> 是堆疊頂的那個值，
<code>k</code> 是堆疊頂之下的值。

<p>
這個函式會將鍵和值都彈出堆疊。
跟在 Lua 中一樣，這個函式可能觸發一個 "newindex" 事件的元方法
（參見 <a href="#2.4">&sect;2.4</a>）。




<hr><h3><a name="lua_settop"><code>lua_settop</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_settop (lua_State *L, int index);</pre>

<p>
參數允許傳入任何索引以及 0 。
它將把堆堆疊的堆疊頂設為這個索引。
如果新的堆疊頂比原來的大，
超出部分的新元素將被填為 <b>nil</b> 。
如果 <code>index</code> 為 0 ，
把堆疊上所有元素移除。




<hr><h3><a name="lua_setuservalue"><code>lua_setuservalue</code></a></h3><p>
<span class="apii">[-1, +0, &ndash;]</span>
<pre>void lua_setuservalue (lua_State *L, int index);</pre>

<p>
從堆疊上彈出一個值並將其設為給定索引處用戶數據的關聯值。




<hr><h3><a name="lua_State"><code>lua_State</code></a></h3>
<pre>typedef struct lua_State lua_State;</pre>

<p>
一個不透明的結構，
它指向一條線程並間接（通過該線程）引用了整個 Lua 解釋器的狀態。
Lua 庫是完全可重入的：
它沒有任何全局變量。
狀態機所有的信息都可以通過這個結構訪問到。

<p>
這個結構的指針必須作為第一個參數傳遞給每一個庫函式。
<a href="#lua_newstate"><code>lua_newstate</code></a> 是一個例外，
這個函式會從頭創建一個 Lua 狀態機。



<hr><h3><a name="lua_status"><code>lua_status</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_status (lua_State *L);</pre>

<p>
返回線程 <code>L</code> 的狀態。


<p>
正常的線程狀態是 0 （<a href="#pdf-LUA_OK"><code>LUA_OK</code></a>）。
當線程用 <a href="#lua_resume"><code>lua_resume</code></a> 執行完畢並拋出了一個錯誤時，
狀態值是錯誤碼。
如果線程被掛起，狀態為 <a name="pdf-LUA_YIELD"><code>LUA_YIELD</code></a> 。


<p>
你只能在狀態為 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> 的線程中調用函式。
你可以延續一個狀態為 <a href="#pdf-LUA_OK"><code>LUA_OK</code></a> 的線程
（用於開始新協程）或是狀態為 <a href="#pdf-LUA_YIELD"><code>LUA_YIELD</code></a> 的線程
（用於延續協程）。




<hr><h3><a name="lua_stringtonumber"><code>lua_stringtonumber</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>size_t lua_stringtonumber (lua_State *L, const char *s);</pre>

<p>
將一個零結尾的字串 <code>s</code> 轉換為一個數字，
將這個數字壓堆疊，並返回字串的總長度（即長度加一）。
轉換的結果可能是整數也可能是浮點數，
這取決於 Lua 的轉換語法（參見 <a href="#3.1">&sect;3.1</a>）。
這個字串可以有前置和後置的空格以及符號。
如果字串並非一個有效的數字，返回 0 並不把任何東西壓堆疊。
（注意，這個結果可以當成一個布爾量使用，為真即轉換成功。）




<hr><h3><a name="lua_toboolean"><code>lua_toboolean</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_toboolean (lua_State *L, int index);</pre>

<p>
把給定索引處的 Lua 值轉換為一個 C 中的布爾量（ 0 或是 1 ）。
和 Lua 中做的所有測試一樣， 
<a href="#lua_toboolean"><code>lua_toboolean</code></a> 
會把任何不同於 <b>false</b> 和 <b>nil</b> 的值當作真返回；
否則就返回假。
（如果你想只接收真正的 boolean 值，
就需要使用 <a href="#lua_isboolean"><code>lua_isboolean</code></a> 來測試值的型別。）




<hr><h3><a name="lua_tocfunction"><code>lua_tocfunction</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_CFunction lua_tocfunction (lua_State *L, int index);</pre>

<p>
把給定索引處的 Lua 值轉換為一個 C 函式。
這個值必須是一個 C 函式；
如果不是就返回 <code>NULL</code> 。





<hr><h3><a name="lua_tointeger"><code>lua_tointeger</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointeger (lua_State *L, int index);</pre>

<p>
等價於調用 <a href="#lua_tointegerx"><code>lua_tointegerx</code></a>，
其參數 <code>isnum</code> 為 <code>NULL</code>。



<hr><h3><a name="lua_tointegerx"><code>lua_tointegerx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Integer lua_tointegerx (lua_State *L, int index, int *isnum);</pre>

<p>
將給定索引處的 Lua 值轉換為帶符號的整數型別
<a href="#lua_Integer"><code>lua_Integer</code></a>。
這個 Lua 值必須是一個整數，或是一個可以被轉換為整數
（參見 <a href="#3.4.3">&sect;3.4.3</a>）的數字或字串；
否則，<code>lua_tointegerx</code> 返回 0 。


<p>
如果 <code>isnum</code> 不是 <code>NULL</code>，
<code>*isnum</code> 會被設為操作是否成功。




<hr><h3><a name="lua_tolstring"><code>lua_tolstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tolstring (lua_State *L, int index, size_t *len);</pre>

<p>
把給定索引處的 Lua 值轉換為一個 C 字串。
如果 <code>len</code> 不為 <code>NULL</code> ，
它還把字串長度設到 <code>*len</code> 中。
這個 Lua 值必須是一個字串或是一個數字； 
否則返回返回 <code>NULL</code> 。
如果值是一個數字， <code>lua_tolstring</code>
還會 <em>把堆堆疊中的那個值的實際型別轉換為一個字串</em>。
（當遍歷一張表的時候，
若把 <code>lua_tolstring</code> 作用在鍵上，
這個轉換有可能導致 <a href="#lua_next"><code>lua_next</code></a> 弄錯。）


<p>
<code>lua_tolstring</code> 返回一個已對齊指針
指向 Lua 狀態機中的字串。
這個字串總能保證 （ C 要求的）最後一個字符為零 ('\0') ，
而且它允許在字串內包含多個這樣的零。 


<p>
因為 Lua 中可能發生垃圾收集，
所以不保證 <code>lua_tolstring</code> 返回的指針，
在對應的值從堆堆疊中移除後依然有效。



<hr><h3><a name="lua_tonumber"><code>lua_tonumber</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumber (lua_State *L, int index);</pre>

<p>
等價於調用 <a href="#lua_tonumberx"><code>lua_tonumberx</code></a>，
其參數 <code>isnum</code> 為 <code>NULL</code>。





<hr><h3><a name="lua_tonumberx"><code>lua_tonumberx</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Number lua_tonumberx (lua_State *L, int index, int *isnum);</pre>

<p>
把給定索引處的 Lua 值轉換為 <a href="#lua_Number"><code>lua_Number</code></a> 這樣一個 C 型別
（參見 lua_Number ）。
這個 Lua 值必須是一個數字或是一個可轉換為數字的字串 
（參見 <a href="#3.4.3">&sect;3.4.3</a>）；
否則， <a href="#lua_tonumberx"><code>lua_tonumberx</code></a> 返回 0 。


<p>
如果 <code>isnum</code> 不是 <code>NULL</code>，
<code>*isnum</code> 會被設為操作是否成功。




<hr><h3><a name="lua_topointer"><code>lua_topointer</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const void *lua_topointer (lua_State *L, int index);</pre>

<p>
把給定索引處的值轉換為一般的 C 指針 (<code>void*</code>) 。
這個值可以是一個用戶對象，表 ，線程或是一個函式；
否則， <code>lua_topointer</code> 返回 <code>NULL</code> 。
不同的對象有不同的指針。
不存在把指針再轉回原有型別的方法。


<p>
這個函式通常只用於調試信息。




<hr><h3><a name="lua_tostring"><code>lua_tostring</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>const char *lua_tostring (lua_State *L, int index);</pre>

<p>
等價於調用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> ，
其參數 <code>len</code> 為 <code>NULL</code> 。




<hr><h3><a name="lua_tothread"><code>lua_tothread</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *lua_tothread (lua_State *L, int index);</pre>

<p>
把給定索引處的值轉換為一個 Lua 線程
（表示為 <code>lua_State*</code>）。
這個值必須是一個線程；
否則函式返回 <code>NULL</code>。




<hr><h3><a name="lua_touserdata"><code>lua_touserdata</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_touserdata (lua_State *L, int index);</pre>

<p>
如果給定索引處的值是一個完全用戶數據，
函式返回其記憶體塊的地址。
如果值是一個輕量用戶數據，
那麼就返回它表示的指針。
否則，返回 <code>NULL</code> 。




<hr><h3><a name="lua_type"><code>lua_type</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_type (lua_State *L, int index);</pre>

<p>
返回給定有效索引處值的型別，
當索引無效（或無法訪問）時則返回 <code>LUA_TNONE</code>。
<a href="#lua_type"><code>lua_type</code></a> 返回的型別被編碼為一些個在
<code>lua.h</code> 中定義的常量：
<a name="pdf-LUA_TNIL"><code>LUA_TNIL</code></a>，
<a name="pdf-LUA_TNUMBER"><code>LUA_TNUMBER</code></a>，
<a name="pdf-LUA_TBOOLEAN"><code>LUA_TBOOLEAN</code></a>，
<a name="pdf-LUA_TSTRING"><code>LUA_TSTRING</code></a>，
<a name="pdf-LUA_TTABLE"><code>LUA_TTABLE</code></a>，
<a name="pdf-LUA_TFUNCTION"><code>LUA_TFUNCTION</code></a>，
<a name="pdf-LUA_TUSERDATA"><code>LUA_TUSERDATA</code></a>，
<a name="pdf-LUA_TTHREAD"><code>LUA_TTHREAD</code></a>，
<a name="pdf-LUA_TLIGHTUSERDATA"><code>LUA_TLIGHTUSERDATA</code></a>。





<hr><h3><a name="lua_typename"><code>lua_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *lua_typename (lua_State *L, int tp);</pre>

<p>
返回 <code>tp</code> 表示的型別名，
這個 <code>tp</code> 必須是 <a href="#lua_type"><code>lua_type</code></a>
可能返回的值中之一。




<hr><h3><a name="lua_Unsigned"><code>lua_Unsigned</code></a></h3>
<pre>typedef ... lua_Unsigned;</pre>

<p>
<a href="#lua_Integer"><code>lua_Integer</code></a> 的無符號版本。





<hr><h3><a name="lua_upvalueindex"><code>lua_upvalueindex</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_upvalueindex (int i);</pre>

<p>
返回當前運行的函式（參見 <a href="#4.4">&sect;4.4</a>）的第 <code>i</code> 個上值的偽索引。




<hr><h3><a name="lua_version"><code>lua_version</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const lua_Number *lua_version (lua_State *L);</pre>

<p>
返回保存在 Lua 內核中儲存的版本數字的地址。
當調用時傳入一個合法的 <a href="#lua_State"><code>lua_State</code></a> ，
返回創建該狀態機時的版本地址。
如果用 <code>NULL</code> 調用，
返回調用者的版本地址。




<hr><h3><a name="lua_Writer"><code>lua_Writer</code></a></h3>
<pre>typedef int (*lua_Writer) (lua_State *L,
                           const void* p,
                           size_t sz,
                           void* ud);</pre>

<p>
被 <a href="#lua_dump"><code>lua_dump</code></a> 用到的寫入器函式。
每次 <a href="#lua_dump"><code>lua_dump</code></a> 產生了一段新的代碼塊，
它都會調用寫入器。
傳入要寫入的緩衝區 (<code>p</code>) 和它的尺寸 (<code>sz</code>) ，
以及傳給 <a href="#lua_dump"><code>lua_dump</code></a> 的參數 <code>data</code> 。



<p>
寫入器會返回一個錯誤碼：
0 表示沒有錯誤； 別的值均表示一個錯誤，
並且會讓 <a href="#lua_dump"><code>lua_dump</code></a> 停止再次調用寫入器。




<hr><h3><a name="lua_xmove"><code>lua_xmove</code></a></h3><p>
<span class="apii">[-?, +?, &ndash;]</span>
<pre>void lua_xmove (lua_State *from, lua_State *to, int n);</pre>

<p>
交換同一個狀態機下不同線程中的值。


<p>
這個函式會從 <code>from</code> 的堆疊上彈出 <code>n</code> 個值，
然後把它們壓入 <code>to</code> 的堆疊上。





<hr><h3><a name="lua_yield"><code>lua_yield</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yield (lua_State *L, int nresults);</pre>

<p>
這個函式等價於調用 <a href="#lua_yieldk"><code>lua_yieldk</code></a>，
不同的是不提供延續函式（參見 <a href="#4.7">&sect;4.7</a>）。
因此，當線程被延續，線程會繼續運行調用 <code>lua_yield</code> 函式的函式。




<hr><h3><a name="lua_yieldk"><code>lua_yieldk</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>int lua_yieldk (lua_State *L,
                int nresults,
                lua_KContext ctx,
                lua_KFunction k);</pre>

<p>
讓出協程（線程）。


<p>
當 C 函式調用了 <a href="#lua_yieldk"><code>lua_yieldk</code></a>，
當前運行的協程會掛起，
啟動這個線程的 <a href="#lua_resume"><code>lua_resume</code></a> 調用返回。
參數 <code>nresults</code> 指堆疊上需返回給
<a href="#lua_resume"><code>lua_resume</code></a> 的返回值的個數。


<p>
當協程再次被延續時，
Lua 調用延續函式 <code>k</code> 繼續運行被掛起（參見 <a href="#4.7">&sect;4.7</a>）的 C 函式。
延續函式會從前一個函式中接收到相同的堆疊，
堆疊中的 <code>n</code> 個返回值被移除而壓入了從
<a href="#lua_resume"><code>lua_resume</code></a> 傳入的參數。
此外，延續函式還會收到傳給 <a href="#lua_yieldk"><code>lua_yieldk</code></a>
的參數 <code>ctx</code>。


<p>
通常，這個函式不會返回；
當協程一次次延續，將從延續函式繼續運行。
然而，有一個例外：
當這個函式從一個逐行運行的鉤子函式（參見 <a href="#4.9">&sect;4.9</a>）
中調用時，<code>lua_yieldk</code> 不可以提供延續函式。
（也就是類似 <a href="#lua_yield"><code>lua_yield</code></a> 的形式），
而此時，鉤子函式在調用完讓出後將立刻返回。
Lua 會使協程讓出，一旦協程再次被延續，
觸發鉤子的函式會繼續正常運行。


<p>
當一個線程處於未提供延續函式的 C 調用中，調用它會拋出一個錯誤。
從並非用延續方式（例如：主線程）啟動的線程中調用它也會這樣。





<h2>4.9 &ndash; <a name="4.9">調試接口</a></h2>

<p>
Lua 沒有內置的調試機制。
但是它提供了一組特殊的函式接口以及 <em>鉤子</em>。
這組接口可用於構建出不同的調試器、性能剖析器、
或是其它需要從解釋器獲取「內部信息」的工具。


<hr><h3><a name="lua_Debug"><code>lua_Debug</code></a></h3>
<pre>typedef struct lua_Debug {
  int event;
  const char *name;           /* (n) */
  const char *namewhat;       /* (n) */
  const char *what;           /* (S) */
  const char *source;         /* (S) */
  int currentline;            /* (l) */
  int linedefined;            /* (S) */
  int lastlinedefined;        /* (S) */
  unsigned char nups;         /* (u) 上值的數量 */
  unsigned char nparams;      /* (u) 參數的數量 */
  char isvararg;              /* (u) */
  char istailcall;            /* (t) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* 私有部分 */
  <em>其它域</em>
} lua_Debug;</pre>

<p>
這是一個攜帶有有關函式或活動記錄的各種信息的結構。
<a href="#lua_getstack"><code>lua_getstack</code></a> 只會填充結構的私有部分供後面使用。
調用 <a href="#lua_getinfo"><code>lua_getinfo</code></a> 可以在
<a href="#lua_Debug"><code>lua_Debug</code></a> 中填充那些可被使用的信息域。


<p>
下面對 <a href="#lua_Debug"><code>lua_Debug</code></a> 的各個域做一個說明：

<ul>

<li><b><code>source</code>: </b>
創建這個函式的代碼塊的名字。
如果 <code>source</code> 以 '<code>@</code>' 打頭，
指這個函式定義在一個文件中，而 '<code>@</code>' 之後的部分就是文件名。
若 <code>source</code> 以 '<code>=</code>' 打頭，
剩餘的部分由用戶行為來決定如何表示源碼。
其它的情況下，這個函式定義在一個字串中，
而 <code>source</code> 正是那個字串。
</li>

<li><b><code>short_src</code>: </b>
一個「可打印版本」的 <code>source</code> ，用於出錯信息。
</li>

<li><b><code>linedefined</code>: </b>
函式定義開始處的行號。
</li>

<li><b><code>lastlinedefined</code>: </b>
函式定義結束處的行號。
</li>

<li><b><code>what</code>: </b>
如果函式是一個 Lua 函式，則為一個字串 <code>"Lua"</code> ；
如果是一個 C 函式，則為 <code>"C"</code>；
如果它是一個代碼塊的主體部分，則為 <code>"main"</code>。
</li>

<li><b><code>currentline</code>: </b>
給定函式正在執行的那一行。 
當提供不了行號信息的時候， <code>currentline</code> 被設為 -1 。
</li>

<li><b><code>name</code>: </b>
給定函式的一個合理的名字。
因為 Lua 中的函式是一等公民，
所以它們沒有固定的名字：
一些函式可能是全局復合變量的值，
另一些可能僅僅只是被保存在一張表的某個域中。
<code>lua_getinfo</code> 函式會檢查函式是怎樣被調用的，
以此來找到一個適合的名字。 
如果它找不到名字，
<code>name</code> 就被設置為 <code>NULL</code> 。
</li>

<li><b><code>namewhat</code>: </b>
用於解釋 <code>name</code> 域。
<code>namewhat</code> 的值可以是
<code>"global"</code>, <code>"local"</code>, <code>"method"</code>, <code>"field"</code>, <code>"upvalue"</code>, 或是 <code>""</code> （空串）。
這取決於函式怎樣被調用。
（Lua 用空串表示其它選項都不符合。）
</li>

<li><b><code>istailcall</code>: </b>
如果函式以尾調用形式調用，這個值就為真。
在這種情況下，當層的調用者不在堆疊中。
</li>

<li><b><code>nups</code>: </b>
函式的上值個數。
</li>

<li><b><code>nparams</code>: </b>
函式固定行參個數
（對於 C 函式永遠是 0 ）。
</li>

<li><b><code>isvararg</code>: </b>
如果函式是一個可變參數函式則為真
（對於 C 函式永遠為真）。
</li>

</ul>




<hr><h3><a name="lua_gethook"><code>lua_gethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_Hook lua_gethook (lua_State *L);</pre>

<p>
返回當前的鉤子函式。





<hr><h3><a name="lua_gethookcount"><code>lua_gethookcount</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookcount (lua_State *L);</pre>

<p>
返回當前的鉤子計數。




<hr><h3><a name="lua_gethookmask"><code>lua_gethookmask</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_gethookmask (lua_State *L);</pre>

<p>
返回當前的鉤子掩碼。





<hr><h3><a name="lua_getinfo"><code>lua_getinfo</code></a></h3><p>
<span class="apii">[-(0|1), +(0|1|2), <em>e</em>]</span>
<pre>int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);</pre>

<p>
返回一個指定的函式或函式調用的信息。


<p>
當用於取得一次函式調用的信息時，
參數 <code>ar</code> 必須是一個有效的活動的記錄。
這條記錄可以是前一次調用 <a href="#lua_getstack"><code>lua_getstack</code></a> 得到的，
或是一個鉤子 （參見 <a href="#lua_Hook"><code>lua_Hook</code></a> ）得到的參數。


<p>
用於獲取一個函式的信息時，
可以把這個函式壓入堆堆疊， 
然後把 <code>what</code> 字串以字符 '<code>&gt;</code>' 起頭。
（這會讓 <code>lua_getinfo</code> 從堆疊頂上彈出函式。）
例如，想知道函式 <code>f</code> 是在哪一行定義的，
你可以使用下列代碼：

<pre>
     lua_Debug ar;
     lua_getglobal(L, "f");  /* 取得全局變量 'f' */
     lua_getinfo(L, "&gt;S", &amp;ar);
     printf("%d\n", ar.linedefined);
</pre>

<p>
<code>what</code> 字串中的每個字符都篩選出結構
<code>ar</code> 結構中一些域用於填充，
或是把一個值壓入堆堆疊：

<ul>

<li><b>'<code>n</code>': </b> 填充 <code>name</code> 及 <code>namewhat</code> 域；
</li>

<li><b>'<code>S</code>': </b>
填充 <code>source</code> ， <code>short_src</code> ， <code>linedefined</code> ， <code>lastlinedefined</code> ，以及 <code>what</code> 域；
</li>

<li><b>'<code>l</code>': </b> 填充 <code>currentline</code> 域；
</li>

<li><b>'<code>t</code>': </b> 填充 <code>istailcall</code> 域；
</li>

<li><b>'<code>u</code>': </b> 填充 <code>nups</code>， <code>nparams</code>，及 <code>isvararg</code> 域；
</li>

<li><b>'<code>f</code>': </b>
把正在運行中指定層次處函式壓堆疊；
</li>

<li><b>'<code>L</code>': </b>
將一張表壓堆疊，這張表中的整數索引用於描述函式中哪些行是有效行。
（<em>有效行</em>指有實際代碼的行，即你可以置入斷點的行。 無效行包括空行和只有註釋的行。）


<p>
如果這個選項和選項 '<code>f</code>' 同時使用，
這張表在函式之後壓堆疊。
</li>

</ul>

<p>
這個函式出錯會返回 0 （例如，<code>what</code> 中有一個無效選項）。



<hr><h3><a name="lua_getlocal"><code>lua_getlocal</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
從給定活動記錄或從一個函式中獲取一個局部變量的信息。


<p>
對於第一種情況，
參數 <code>ar</code> 必須是一個有效的活動的記錄。 
這條記錄可以是前一次調用 <a href="#lua_getstack"><code>lua_getstack</code></a> 得到的，
或是一個鉤子 （參見 <a href="#lua_Hook"><code>lua_Hook</code></a> ）的參數。
索引 <code>n</code> 用於選擇要檢閱哪個局部變量；
參見 <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a> 
中關於變量的索引和名字的介紹。


<p>
<a href="#lua_getlocal"><code>lua_getlocal</code></a> 將變量的值壓堆疊，並返回其名字。


<p>
對於第二種情況，<code>ar</code> 必須填 <code>NULL</code> 。
需要探知的函式必須放在堆疊頂。
對於這種情況，只有 Lua 函式的形參是可見的
（沒有關於還有哪些活動變量的信息）
也不會有任何值壓堆疊。


<p>
當索引大於活動的局部變量的數量，
返回 <code>NULL</code> （無任何壓堆疊）




<hr><h3><a name="lua_getstack"><code>lua_getstack</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>int lua_getstack (lua_State *L, int level, lua_Debug *ar);</pre>

<p>
獲取解釋器的運行時堆疊的信息。


<p>
這個函式用正在運行中的指定層次處函式的 <em>活動記錄</em> 來填寫
<a href="#lua_Debug"><code>lua_Debug</code></a> 結構的一部分。
0 層表示當前運行的函式，
<em>n+1</em> 層的函式就是調用第 <em>n</em> 層
（尾調用例外，它不算在堆疊層次中）
函式的那一個。
如果沒有錯誤， <a href="#lua_getstack"><code>lua_getstack</code></a> 返回 1 ；
當調用傳入的層次大於堆堆疊深度的時候，返回 0 。




<hr><h3><a name="lua_getupvalue"><code>lua_getupvalue</code></a></h3><p>
<span class="apii">[-0, +(0|1), &ndash;]</span>
<pre>const char *lua_getupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
獲取一個 Closure 的上值信息。
（對於 Lua 函式，上值是函式需要使用的外部局部變量，
因此這些變量被包含在 Closure 中。）
<a href="#lua_getupvalue"><code>lua_getupvalue</code></a> 獲取第 <code>n</code> 個上值，
把這個上值的值壓堆疊，
並且返回它的名字。 
<code>funcindex</code> 指向 Closure 在堆疊上的位置。
（ 因為上值在整個函式中都有效，所以它們沒有特別的次序。
因此，它們以字母次序來編號。）


<p>
當索引號比上值數量大的時候，
返回 <code>NULL</code>（而且不會壓入任何東西）。
對於 C 函式，所有上值的名字都是空串 <code>""</code>。



<hr><h3><a name="lua_Hook"><code>lua_Hook</code></a></h3>
<pre>typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);</pre>

<p>
用於調試的鉤子函式型別。


<p>
無論何時鉤子被調用，它的參數 <code>ar</code> 
中的 <code>event</code> 域都被設為觸發鉤子的事件。
Lua 把這些事件定義為以下常量：
<a name="pdf-LUA_HOOKCALL"><code>LUA_HOOKCALL</code></a>，<a name="pdf-LUA_HOOKRET"><code>LUA_HOOKRET</code></a>，
<a name="pdf-LUA_HOOKTAILCALL"><code>LUA_HOOKTAILCALL</code></a>，<a name="pdf-LUA_HOOKLINE"><code>LUA_HOOKLINE</code></a>，
<a name="pdf-LUA_HOOKCOUNT"><code>LUA_HOOKCOUNT</code></a>。
除此之外，對於 line 事件， <code>currentline</code> 域也被設置。
要想獲得 <code>ar</code> 中的其他域，
鉤子必須調用 <a href="#lua_getinfo"><code>lua_getinfo</code></a> 。

<p>
對於 call 事件，<code>event</code> 可以是 <code>LUA_HOOKCALL</code> 這個通常值，
或是 <code>LUA_HOOKTAILCALL</code> 表示尾調用；
後一種情況，沒有對應的返回事件。


<p>
當 Lua 運行在一個鉤子內部時，
它將屏蔽掉其它對鉤子的調用。
也就是說，如果一個鉤子函式內再調回 Lua 來執行一個函式或是一個代碼塊 ，
這個執行操作不會觸發任何的鉤子。


<p>
鉤子函式不能有延續點，
即不能用一個非空的 <code>k</code> 調用
<a href="#lua_yieldk"><code>lua_yieldk</code></a>，
<a href="#lua_pcallk"><code>lua_pcallk</code></a>，或 <a href="#lua_callk"><code>lua_callk</code></a>。

<p>
鉤子函式可以在滿足下列條件時讓出：
只有行計數事件可以讓出，且不能在讓出時傳出任何值；
從鉤子裡讓出必須用 <a href="#lua_yield"><code>lua_yield</code></a>
來結束鉤子的運行，且 <code>nresults</code> 必須為零。



<hr><h3><a name="lua_sethook"><code>lua_sethook</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</pre>

<p>
設置一個調試用鉤子函式。


<p>
參數 <code>f</code> 是鉤子函式。
<code>mask</code> 指定在哪些事件時會調用：
它由下列一組位常量構成
<a name="pdf-LUA_MASKCALL"><code>LUA_MASKCALL</code></a>，
<a name="pdf-LUA_MASKRET"><code>LUA_MASKRET</code></a>，
<a name="pdf-LUA_MASKLINE"><code>LUA_MASKLINE</code></a>，
<a name="pdf-LUA_MASKCOUNT"><code>LUA_MASKCOUNT</code></a>。
參數 <code>count</code> 只在掩碼中包含有 <code>LUA_MASKCOUNT</code> 才有意義。
對於每個事件，鉤子被調用的情況解釋如下：

<ul>

<li><b>call hook: </b>
在解釋器調用一個函式時被調用。
鉤子將於 Lua 進入一個新函式後，
函式獲取參數前被調用。
</li>

<li><b>return hook: </b>
在解釋器從一個函式中返回時調用。
鉤子將於 Lua 離開函式之前的那一刻被調用。
沒有標準方法來訪問被函式返回的那些值。
</li>

<li><b>line hook: </b>
在解釋器準備開始執行新的一行代碼時，
或是跳轉到這行代碼中時（即使在同一行內跳轉）被調用。
（這個事件僅僅在 Lua 執行一個 Lua 函式時發生。）
</li>

<li><b>count hook: </b>
在解釋器每執行 <code>count</code> 條指令後被調用。
（這個事件僅僅在 Lua 執行一個 Lua 函式時發生。）
</li>

</ul>

<p>
鉤子可以通過設置 <code>mask</code> 為零屏蔽。




<hr><h3><a name="lua_setlocal"><code>lua_setlocal</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);</pre>

<p>
設置給定活動記錄中的局部變量的值。
參數 <code>ar</code> 與 <code>n</code> 和
<a href="#lua_getlocal"><code>lua_getlocal</code></a> 中的一樣 
（參見 <a href="#lua_getlocal"><code>lua_getlocal</code></a> ）。
<a href="#lua_setlocal"><code>lua_setlocal</code></a> 把堆疊頂的值賦給變量然後返回變量的名字。
它會將值從堆疊頂彈出。



<p>
當索引大於活動局部變量的數量時，返回 <code>NULL</code> （什麼也不彈出）。




<hr><h3><a name="lua_setupvalue"><code>lua_setupvalue</code></a></h3><p>
<span class="apii">[-(0|1), +0, &ndash;]</span>
<pre>const char *lua_setupvalue (lua_State *L, int funcindex, int n);</pre>

<p>
設置 Closure 上值的值。
它把堆疊頂的值彈出並賦於上值並返回上值的名字。
參數 <code>funcindex</code> 與 <code>n</code> 和
<a href="#lua_getupvalue"><code>lua_getupvalue</code></a> 中的一樣
（參見 <a href="#lua_getupvalue"><code>lua_getupvalue</code></a> ）。


<p>
當索引大於上值的數量時，返回 <code>NULL</code> （什麼也不彈出）。




<hr><h3><a name="lua_upvalueid"><code>lua_upvalueid</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void *lua_upvalueid (lua_State *L, int funcindex, int n);</pre>

<p>
返回索引 <code>funcindex</code> 處的 Closure 中
編號為 <code>n</code> 的上值的一個唯一標識符。
參數 <code>funcindex</code> 與 <code>n</code> 和
<a href="#lua_getupvalue"><code>lua_getupvalue</code></a> 中的一樣
（參見 <a href="#lua_getupvalue"><code>lua_getupvalue</code></a> ）。
（但 <code>n</code> 不可以大於上值的數量）。


<p>
這些唯一標識符可用於檢測不同的 Closure 是否共享了相同的上值。
共享同一個上值的 Lua Closure（即它們指的同一個外部局部變量）
會針對這個上值返回相同的標識。




<hr><h3><a name="lua_upvaluejoin"><code>lua_upvaluejoin</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void lua_upvaluejoin (lua_State *L, int funcindex1, int n1,
                                    int funcindex2, int n2);</pre>

<p>
讓索引 <code>funcindex1</code> 處的 Lua Closure 的第 <code>n1</code> 個上值
引用索引 <code>funcindex2</code> 處的 Lua Closure 的第 <code>n2</code> 個上值。





<h1>5 &ndash; <a name="5">輔助庫</a></h1>

<p>
<em>輔助庫</em> 提供了一些便捷函式，方便在 C 中為 Lua 編程。
基礎 API 提供了 C 和 Lua 交互用的主要函式，
而輔助庫則為一些常見的任務提供了高階函式。


<p>
所有輔助庫中的函式和型別都定義在頭文件 <code>lauxlib.h</code> 中，
它們均帶有前綴 <code>luaL_</code>。


<p>
輔助庫中的所有函式都基於基礎 API 實現。
故而它們並沒有提供任何基礎 API 實現不了的功能。
雖然如此，使用輔助庫可以讓你的代碼更為健壯。


<p>
一些輔助庫函式會在內部使用一些額外的堆疊空間。
當輔助庫使用的堆疊空間少於五個時，
它們不去檢查堆疊大小；而是簡單的假設堆疊夠用。


<p>
一些輔助庫中的函式用於檢查 C 函式的參數。
因為錯誤信息格式化為指代參數
（例如，"<code>bad argument #1</code>"），
你就不要把這些函式用於參數之外的值了。

<p>
如果檢查無法通過，
<code>luaL_check*</code> 這些函式一定會拋出錯誤。



<h2>5.1 &ndash; <a name="5.1">函式和型別</a></h2>

<p>
這裡我們按字母表次序列出了輔助庫中的所有函式和型別。



<hr><h3><a name="luaL_addchar"><code>luaL_addchar</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addchar (luaL_Buffer *B, char c);</pre>

<p>
向緩存 <code>B</code> （參見 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> ）
添加一個字節 <code>c</code>。




<hr><h3><a name="luaL_addlstring"><code>luaL_addlstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addlstring (luaL_Buffer *B, const char *s, size_t l);</pre>

<p>
向緩存 <code>B</code> （參見 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> ）
添加一個長度為 <code>l</code> 的字串 <code>s</code>。
這個字串可以包含零。




<hr><h3><a name="luaL_addsize"><code>luaL_addsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addsize (luaL_Buffer *B, size_t n);</pre>

<p>
向緩存 <code>B</code> （參見 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> ）
添加一個已在之前複製到緩衝區（參見 <a href="#luaL_prepbuffer"><code>luaL_prepbuffer</code></a>）
的長度為 <code>n</code> 的字串。




<hr><h3><a name="luaL_addstring"><code>luaL_addstring</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>void luaL_addstring (luaL_Buffer *B, const char *s);</pre>

<p>
向緩存 <code>B</code> （參見 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> ）
添加一個零結尾的字串 <code>s</code>。




<hr><h3><a name="luaL_addvalue"><code>luaL_addvalue</code></a></h3><p>
<span class="apii">[-1, +?, <em>e</em>]</span>
<pre>void luaL_addvalue (luaL_Buffer *B);</pre>

<p>
向緩存 <code>B</code> （參見 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> ）
添加堆疊頂的一個值，隨後將其彈出。


<p>
這個函式是操作字串緩存的函式中，唯一一個會（且必須）在堆疊上放置額外元素的。
這個元素將被加入緩存。




<hr><h3><a name="luaL_argcheck"><code>luaL_argcheck</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_argcheck (lua_State *L,
                    int cond,
                    int arg,
                    const char *extramsg);</pre>

<p>
檢查 <code>cond</code> 是否為真。
如果不為真，以標準信息形式拋出一個錯誤
（參見 <a href="#luaL_argerror"><code>luaL_argerror</code></a>）。





<hr><h3><a name="luaL_argerror"><code>luaL_argerror</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_argerror (lua_State *L, int arg, const char *extramsg);</pre>

<p>
拋出一個錯誤報告調用的 C 函式的第 <code>arg</code> 個參數的問題。
它使用下列標準信息並包含了一段 <code>extramsg</code> 作為註解：

<pre>
     bad argument #<em>arg</em> to '<em>funcname</em>' (<em>extramsg</em>)
</pre><p>
這個函式永遠不會返回。





<hr><h3><a name="luaL_Buffer"><code>luaL_Buffer</code></a></h3>
<pre>typedef struct luaL_Buffer luaL_Buffer;</pre>

<p>
<em>字串緩存</em> 的型別。


<p>
字串緩存可以讓 C 代碼分段構造一個 Lua 字串。
使用模式如下：

<ul>

<li>首先定義一個型別為 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 的變量 <code>b</code>。</li>

<li>調用 <code>luaL_buffinit(L, &amp;b)</code> 初始化它。</li>

<li>
然後調用 <code>luaL_add*</code> 這組函式向其添加字串片斷。
</li>

<li>
最後調用 <code>luaL_pushresult(&amp;b)</code> 。
最後這次調用會在堆疊頂留下最終的字串。
</li>

</ul>

<p>
如果你預先知道結果串的長度，
你可以這樣使用緩存：

<ul>

<li>首先定義一個型別為 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a> 的變量 <code>b</code>。</li>

<li>然後調用 <code>luaL_buffinitsize(L, &amp;b, sz)</code> 預分配 <code>sz</code> 大小的空間。</li>

<li>接著將字串複製入這個空間。</li>

<li>
最後調用 <code>luaL_pushresultsize(&amp;b, sz)</code>，
這裡的 <code>sz</code> 指已經複製到緩存內的字串長度。
</li>

</ul>

<p>
一般的操作過程中，字串緩存會使用不定量的堆疊槽。
因此，在使用緩存中，你不能假定目前堆疊頂在哪。
在對緩存操作的函式調用間，你都可以使用堆疊，只需要保證堆疊平衡即可；
即，在你做一次緩存操作調用時，當時的堆疊位置和上次調用緩存操作後的位置相同。
（對於 <a href="#luaL_addvalue"><code>luaL_addvalue</code></a> 是個唯一的例外。）
在調用完 <a href="#luaL_pushresult"><code>luaL_pushresult</code></a> 後，
堆疊會恢復到緩存初始化時的位置上，並在頂部壓入最終的字串。




<hr><h3><a name="luaL_buffinit"><code>luaL_buffinit</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_buffinit (lua_State *L, luaL_Buffer *B);</pre>

<p>
初始化緩存 <code>B</code>。
這個函式不會分配任何空間；
緩存必須以一個變量的形式聲明
（參見 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。





<hr><h3><a name="luaL_buffinitsize"><code>luaL_buffinitsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_buffinitsize (lua_State *L, luaL_Buffer *B, size_t sz);</pre>

<p>
等價於調用序列
<a href="#luaL_buffinit"><code>luaL_buffinit</code></a>，
<a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>。





<hr><h3><a name="luaL_callmeta"><code>luaL_callmeta</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_callmeta (lua_State *L, int obj, const char *e);</pre>

<p>
調用一個元方法。


<p>
如果在索引 <code>obj</code> 處的對象有元表，
且元表有域 <code>e</code> 。
這個函式會以該對像為參數調用這個域。
這種情況下，函式返回真並將調用返回值壓堆疊。
如果那個位置沒有元表，或沒有對應的元方法，
此函式返回假（並不會將任何東西壓堆疊）。




<hr><h3><a name="luaL_checkany"><code>luaL_checkany</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkany (lua_State *L, int arg);</pre>

<p>
檢查函式在 <code>arg</code> 位置是否有任何型別（包括 <b>nil</b>）的參數。




<hr><h3><a name="luaL_checkinteger"><code>luaL_checkinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_checkinteger (lua_State *L, int arg);</pre>

<p>
檢查函式的第 <code>arg</code> 個參數是否是一個
整數（或是可以被轉換為一個整數）
並以  <a href="#lua_Integer"><code>lua_Integer</code></a> 型別返回這個整數值。



<hr><h3><a name="luaL_checklstring"><code>luaL_checklstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checklstring (lua_State *L, int arg, size_t *l);</pre>

<p>
檢查函式的第 <code>arg</code> 個參數是否是一個
字串，並返回該字串；
如果 <code>l</code> 不為 <code>NULL</code> ，
將字串的長度填入 <code>*l</code>。


<p>
這個函式使用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> 來獲取結果。
所以該函式有可能引發的轉換都同樣有效。




<hr><h3><a name="luaL_checknumber"><code>luaL_checknumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_checknumber (lua_State *L, int arg);</pre>

<p>
檢查函式的第 <code>arg</code> 個參數是否是一個
數字，並返回這個數字。




<hr><h3><a name="luaL_checkoption"><code>luaL_checkoption</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_checkoption (lua_State *L,
                      int arg,
                      const char *def,
                      const char *const lst[]);</pre>

<p>
檢查函式的第 <code>arg</code> 個參數是否是一個
字串，並在數組 <code>lst</code> 
（比如是零結尾的字串數組）
中查找這個字串。
返回匹配到的字串在數組中的索引號。
如果參數不是字串，或是字串在數組中匹配不到，都將拋出錯誤。


<p>
如果 <code>def</code> 不為 <code>NULL</code>，
函式就把 <code>def</code> 當作默認值。
默認值在參數 <code>arg</code> 不存在，或該參數是 <b>nil</b> 時生效。


<p>
這個函式通常用於將字串映射為 C 枚舉量。
（在 Lua 庫中做這個轉換可以讓其使用字串，而不是數字來做一些選項。）



<hr><h3><a name="luaL_checkstack"><code>luaL_checkstack</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checkstack (lua_State *L, int sz, const char *msg);</pre>

<p>
將堆疊空間擴展到 <code>top + sz</code> 個元素。
如果擴展不了，則拋出一個錯誤。
<code>msg</code> 是用於錯誤消息的額外文本
（<code>NULL</code> 表示不需要額外文本）。





<hr><h3><a name="luaL_checkstring"><code>luaL_checkstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_checkstring (lua_State *L, int arg);</pre>

<p>
檢查函式的第 <code>arg</code> 個參數是否是一個
字串並返回這個字串。


<p>
這個函式使用 <a href="#lua_tolstring"><code>lua_tolstring</code></a> 來獲取結果。
所以該函式有可能引發的轉換都同樣有效。




<hr><h3><a name="luaL_checktype"><code>luaL_checktype</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void luaL_checktype (lua_State *L, int arg, int t);</pre>

<p>
檢查函式的第 <code>arg</code> 個參數的型別是否是 <code>t</code>。
參見 <a href="#lua_type"><code>lua_type</code></a> 查閱型別 <code>t</code> 的編碼。





<hr><h3><a name="luaL_checkudata"><code>luaL_checkudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>void *luaL_checkudata (lua_State *L, int arg, const char *tname);</pre>

<p>
檢查函式的第 <code>arg</code> 個參數是否是一個型別為
<code>tname</code> 的用戶數據
（參見 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a> )。
它會返回該用戶數據的地址
（參見 <a href="#lua_touserdata"><code>lua_touserdata</code></a>）。




<hr><h3><a name="luaL_checkversion"><code>luaL_checkversion</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_checkversion (lua_State *L);</pre>

<p>
檢查調用它的內核是否是創建這個 Lua 狀態機的內核。
以及調用它的代碼是否使用了相同的 Lua 版本。
同時也檢查調用它的內核與創建該 Lua  狀態機的內核
是否使用了同一片地址空間。




<hr><h3><a name="luaL_dofile"><code>luaL_dofile</code></a></h3><p>
<span class="apii">[-0, +?, <em>e</em>]</span>
<pre>int luaL_dofile (lua_State *L, const char *filename);</pre>

<p>
加載並運行指定的文件。
它是用下列宏定義出來：

<pre>
     (luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
如果沒有錯誤，函式返回假；
有錯則返回真。




<hr><h3><a name="luaL_dostring"><code>luaL_dostring</code></a></h3><p>
<span class="apii">[-0, +?, &ndash;]</span>
<pre>int luaL_dostring (lua_State *L, const char *str);</pre>

<p>
加載並運行指定的字串。
它是用下列宏定義出來：

<pre>
     (luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
</pre><p>
如果沒有錯誤，函式返回假；
有錯則返回真。





<hr><h3><a name="luaL_error"><code>luaL_error</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>int luaL_error (lua_State *L, const char *fmt, ...);</pre>

<p>
拋出一個錯誤。
錯誤消息的格式由 <code>fmt</code> 給出。
後面需提供若干參數，
這些參數遵循 <a href="#lua_pushfstring"><code>lua_pushfstring</code></a> 中的規則。
如果能獲得相關信息，它還會在消息前面加上錯誤發生時的文件名及行號。


<p>
這個函式永遠不會返回。
但是在 C 函式中通常遵循慣用法：
<code>return luaL_error(<em>args</em>)</code> 。





<hr><h3><a name="luaL_execresult"><code>luaL_execresult</code></a></h3><p>
<span class="apii">[-0, +3, <em>e</em>]</span>
<pre>int luaL_execresult (lua_State *L, int stat);</pre>

<p>
這個函式用於生成標準庫中和進程相關函式的返回值。
（指 <a href="#pdf-os.execute"><code>os.execute</code></a> 和 <a href="#pdf-io.close"><code>io.close</code></a>）。




<hr><h3><a name="luaL_fileresult"><code>luaL_fileresult</code></a></h3><p>
<span class="apii">[-0, +(1|3), <em>e</em>]</span>
<pre>int luaL_fileresult (lua_State *L, int stat, const char *fname);</pre>

<p>
這個函式用於生成標準庫中和文件相關的函式的返回值。
（指 (<a href="#pdf-io.open"><code>io.open</code></a>，
<a href="#pdf-os.rename"><code>os.rename</code></a>，
<a href="#pdf-file:seek"><code>file:seek</code></a>，等。)。





<hr><h3><a name="luaL_getmetafield"><code>luaL_getmetafield</code></a></h3><p>
<span class="apii">[-0, +(0|1), <em>e</em>]</span>
<pre>int luaL_getmetafield (lua_State *L, int obj, const char *e);</pre>

<p>
將索引 <code>obj</code> 處對象的元表中 <code>e</code> 域的值壓堆疊。
如果該對像沒有元表，或是該元表沒有相關域，
此函式什麼也不會壓堆疊並返回 <code>LUA_TNIL</code>。





<hr><h3><a name="luaL_getmetatable"><code>luaL_getmetatable</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_getmetatable (lua_State *L, const char *tname);</pre>

<p>
將註冊表中 <code>tname</code> 對應的元表
（參見 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）壓堆疊。
如果沒有 <code>tname</code> 對應的元表，則將 <b>nil</b> 壓堆疊並返回假。




<hr><h3><a name="luaL_getsubtable"><code>luaL_getsubtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_getsubtable (lua_State *L, int idx, const char *fname);</pre>

<p>
確保 <code>t[fname]</code> 是一張表，並將這張表壓堆疊。
這裡的 <code>t</code> 指索引 <code>idx</code> 處的值。
如果它原來就是一張表，返回真；
否則為它創建一張新表，返回假。




<hr><h3><a name="luaL_gsub"><code>luaL_gsub</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_gsub (lua_State *L,
                       const char *s,
                       const char *p,
                       const char *r);</pre>

<p>
將字串 <code>s</code> 生成一個副本，
並將其中的所有字串 <code>p</code>
都替換為字串 <code>r</code> 。
將結果串壓堆疊並返回它。




<hr><h3><a name="luaL_len"><code>luaL_len</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>lua_Integer luaL_len (lua_State *L, int index);</pre>

<p>
以數字形式返回給定索引處值的「長度」；
它等價於在 Lua 中調用 '<code>#</code>' 的操作
（參見 <a href="#3.4.7">&sect;3.4.7</a>）。
如果操作結果不是一個整數，則拋出一個錯誤。
（這種情況只發生在觸發元方法時。）




<hr><h3><a name="luaL_loadbuffer"><code>luaL_loadbuffer</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbuffer (lua_State *L,
                     const char *buff,
                     size_t sz,
                     const char *name);</pre>

<p>
等價於 <a href="#luaL_loadbufferx"><code>luaL_loadbufferx</code></a>，
其 <code>mode</code> 參數等於 <code>NULL</code>。





<hr><h3><a name="luaL_loadbufferx"><code>luaL_loadbufferx</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadbufferx (lua_State *L,
                      const char *buff,
                      size_t sz,
                      const char *name,
                      const char *mode);</pre>

<p>
把一段緩存加載為一個 Lua 代碼塊。
這個函式使用 <a href="#lua_load"><code>lua_load</code></a> 
來加載 <code>buff</code> 指向的長度為 <code>sz</code> 的記憶體區。


<p>
這個函式和 <a href="#lua_load"><code>lua_load</code></a> 返回值相同。
<code>name</code> 作為代碼塊的名字，用於調試信息和錯誤消息。
<code>mode</code> 字串的作用同函式 <a href="#lua_load"><code>lua_load</code></a>。





<hr><h3><a name="luaL_loadfile"><code>luaL_loadfile</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_loadfile (lua_State *L, const char *filename);</pre>

<p>
等價於 <a href="#luaL_loadfilex"><code>luaL_loadfilex</code></a>，
其 <code>mode</code> 參數等於 <code>NULL</code>。





<hr><h3><a name="luaL_loadfilex"><code>luaL_loadfilex</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_loadfilex (lua_State *L, const char *filename,
                                            const char *mode);</pre>

<p>
把一個文件加載為 Lua 代碼塊。
這個函式使用 <a href="#lua_load"><code>lua_load</code></a> 加載文件中的數據。
代碼塊的名字被命名為 <code>filename</code>。
如果 <code>filename</code> 為 <code>NULL</code>，
它從標準輸入加載。
如果文件的第一行以 <code>#</code> 打頭，則忽略這一行。

<p>
<code>mode</code> 字串的作用同函式 <a href="#lua_load"><code>lua_load</code></a>。


<p>
此函式的返回值和 <a href="#lua_load"><code>lua_load</code></a> 相同，
不過它還可能產生一個叫做 <a name="pdf-LUA_ERRFILE"><code>LUA_ERRFILE</code></a>
的出錯碼。這種錯誤發生於無法打開或讀入文件時，或是文件的模式錯誤。


<p>
和 <a href="#lua_load"><code>lua_load</code></a> 一樣，這個函式僅加載代碼塊不運行。




<hr><h3><a name="luaL_loadstring"><code>luaL_loadstring</code></a></h3><p>
<span class="apii">[-0, +1, &ndash;]</span>
<pre>int luaL_loadstring (lua_State *L, const char *s);</pre>

<p>
將一個字串加載為 Lua 代碼塊。
這個函式使用 <a href="#lua_load"><code>lua_load</code></a> 加載一個零結尾的字串
<code>s</code>。


<p>
此函式的返回值和 <a href="#lua_load"><code>lua_load</code></a> 相同。


<p>
也和 <a href="#lua_load"><code>lua_load</code></a> 一樣，這個函式僅加載代碼塊不運行。




<hr><h3><a name="luaL_newlib"><code>luaL_newlib</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_newlib (lua_State *L, const luaL_Reg l[]);</pre>

<p>
創建一張新的表，並把列表 <code>l</code> 中的函式註冊進去。


<p>
它是用下列宏實現的：

<pre>
     (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
</pre><p>
數組 <code>l</code> 必須是一個數組，而不能是一個指針。





<hr><h3><a name="luaL_newlibtable"><code>luaL_newlibtable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_newlibtable (lua_State *L, const luaL_Reg l[]);</pre>

<p>
創建一張新的表，並預分配足夠保存下數組 <code>l</code>
內容的空間（但不填充）。
這是給 <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>
一起用的
（參見 <a href="#luaL_newlib"><code>luaL_newlib</code></a>）。


<p>
它以宏形式實現，
數組 <code>l</code> 必須是一個數組，而不能是一個指針。




<hr><h3><a name="luaL_newmetatable"><code>luaL_newmetatable</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>int luaL_newmetatable (lua_State *L, const char *tname);</pre>

<p>
如果註冊表中已存在鍵 <code>tname</code>，返回 0 。
否則，
為用戶數據的元表創建一張新表。
向這張表加入 <code>__name = tname</code> 鍵值對，
並將 <code>[tname] = new table</code> 添加到註冊表中，
返回 1 。
（<code>__name</code>項可用於一些錯誤輸出函式。）


<p>
這兩種情況都會把最終的註冊表中關聯 <code>tname</code> 的值壓堆疊。




<hr><h3><a name="luaL_newstate"><code>luaL_newstate</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>lua_State *luaL_newstate (void);</pre>

<p>
創建一個新的 Lua 狀態機。
它以一個基於標準 C 的 <code>realloc</code> 函式實現的記憶體分配器
調用 <a href="#lua_newstate"><code>lua_newstate</code></a> 。
並把可打印一些出錯信息到標準錯誤輸出的 panic 函式（參見 <a href="#4.6">&sect;4.6</a>）
設置好，用於處理致命錯誤。


<p>
返回新的狀態機。
如果記憶體分配失敗，則返回 <code>NULL</code> 。





<hr><h3><a name="luaL_openlibs"><code>luaL_openlibs</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void luaL_openlibs (lua_State *L);</pre>

<p>
打開指定狀態機中的所有 Lua 標準庫。





<hr><h3><a name="luaL_optinteger"><code>luaL_optinteger</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Integer luaL_optinteger (lua_State *L,
                             int arg,
                             lua_Integer d);</pre>

<p>
如果函式的第 <code>arg</code> 個參數是一個
整數（或可以轉換為一個整數），
返回該整數。
若該參數不存在或是 <b>nil</b>，
返回 <code>d</code>。
除此之外的情況，拋出錯誤。




<hr><h3><a name="luaL_optlstring"><code>luaL_optlstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optlstring (lua_State *L,
                             int arg,
                             const char *d,
                             size_t *l);</pre>

<p>
如果函式的第 <code>arg</code> 個參數是一個
字串，返回該字串。
若該參數不存在或是 <b>nil</b>，
返回 <code>d</code>。
除此之外的情況，拋出錯誤。


<p>
若 <code>l</code> 不為 <code>NULL</code>，
將結果的長度填入 <code>*l</code> 。





<hr><h3><a name="luaL_optnumber"><code>luaL_optnumber</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>lua_Number luaL_optnumber (lua_State *L, int arg, lua_Number d);</pre>

<p>
如果函式的第 <code>arg</code> 個參數是一個
數字，返回該數字。
若該參數不存在或是 <b>nil</b>，
返回 <code>d</code>。
除此之外的情況，拋出錯誤。




<hr><h3><a name="luaL_optstring"><code>luaL_optstring</code></a></h3><p>
<span class="apii">[-0, +0, <em>v</em>]</span>
<pre>const char *luaL_optstring (lua_State *L,
                            int arg,
                            const char *d);</pre>

<p>
如果函式的第 <code>arg</code> 個參數是一個
字串，返回該字串。
若該參數不存在或是 <b>nil</b>，
返回 <code>d</code>。
除此之外的情況，拋出錯誤。



<hr><h3><a name="luaL_prepbuffer"><code>luaL_prepbuffer</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_prepbuffer (luaL_Buffer *B);</pre>

<p>
等價於 <a href="#luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a>，
其預定義大小為 <a name="pdf-LUAL_BUFFERSIZE"><code>LUAL_BUFFERSIZE</code></a>。





<hr><h3><a name="luaL_prepbuffsize"><code>luaL_prepbuffsize</code></a></h3><p>
<span class="apii">[-?, +?, <em>e</em>]</span>
<pre>char *luaL_prepbuffsize (luaL_Buffer *B, size_t sz);</pre>

<p>
返回一段大小為 <code>sz</code> 的空間地址。
你可以將字串複製其中以加到緩存 <code>B</code> 內
（參見 <a href="#luaL_Buffer"><code>luaL_Buffer</code></a>）。
將字串複製其中後，你必須調用 <a href="#luaL_addsize"><code>luaL_addsize</code></a>
傳入字串的大小，才會真正把它加入緩存。





<hr><h3><a name="luaL_pushresult"><code>luaL_pushresult</code></a></h3><p>
<span class="apii">[-?, +1, <em>e</em>]</span>
<pre>void luaL_pushresult (luaL_Buffer *B);</pre>

<p>
結束對緩存 <code>B</code> 的使用，將最終的字串留在堆疊頂。




<hr><h3><a name="luaL_pushresultsize"><code>luaL_pushresultsize</code></a></h3><p>
<span class="apii">[-?, +1, <em>e</em>]</span>
<pre>void luaL_pushresultsize (luaL_Buffer *B, size_t sz);</pre>

<p>
等價於 <a href="#luaL_addsize"><code>luaL_addsize</code></a>，<a href="#luaL_pushresult"><code>luaL_pushresult</code></a>。





<hr><h3><a name="luaL_ref"><code>luaL_ref</code></a></h3><p>
<span class="apii">[-1, +0, <em>e</em>]</span>
<pre>int luaL_ref (lua_State *L, int t);</pre>

<p>
針對堆疊頂的對象，創建並返回一個在索引 <code>t</code> 指向的表中的 <em>引用</em>
（最後會彈出堆疊頂對像）。


<p>
此引用是一個唯一的整數鍵。
只要你不向表 <code>t</code> 手工添加整數鍵，
<a href="#luaL_ref"><code>luaL_ref</code></a> 可以保證它返回的鍵的唯一性。
你可以通過調用 <code>lua_rawgeti(L, t, r)</code> 來找回由
<code>r</code> 引用的對象。
函式 <a href="#luaL_unref"><code>luaL_unref</code></a> 用來釋放一個引用關聯的對象


<p>
如果堆疊頂的對象是 <b>nil</b>，
<a href="#luaL_ref"><code>luaL_ref</code></a> 將返回常量
<a name="pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>。
常量 <a name="pdf-LUA_NOREF"><code>LUA_NOREF</code></a> 可以保證和
<a href="#luaL_ref"><code>luaL_ref</code></a> 能返回的其它引用值不同。




<hr><h3><a name="luaL_Reg"><code>luaL_Reg</code></a></h3>
<pre>typedef struct luaL_Reg {
  const char *name;
  lua_CFunction func;
} luaL_Reg;</pre>

<p>
用於 <a href="#luaL_setfuncs"><code>luaL_setfuncs</code></a>
註冊函式的數組型別。
<code>name</code> 指函式名，<code>func</code> 是函式指針。
任何 <a href="#luaL_Reg"><code>luaL_Reg</code></a> 數組必須以一對
<code>name</code> 與 <code>func</code> 皆為 <code>NULL</code> 結束。




<hr><h3><a name="luaL_requiref"><code>luaL_requiref</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_requiref (lua_State *L, const char *modname,
                    lua_CFunction openf, int glb);</pre>

<p>
如果 <code>modname</code> 不在 <a href="#pdf-package.loaded"><code>package.loaded</code></a> 中，
則調用函式 <code>openf</code> ，並傳入字串 <code>modname</code>。
將其返回值置入 <code>package.loaded[modname]</code>。
這個行為好似該函式通過 <a href="#pdf-require"><code>require</code></a> 調用過一樣。


<p>
如果 <code>glb</code> 為真，
同時也講模塊設到全局變量 <code>modname</code> 裡。


<p>
在堆疊上留下該模塊的副本。




<hr><h3><a name="luaL_setfuncs"><code>luaL_setfuncs</code></a></h3><p>
<span class="apii">[-nup, +0, <em>e</em>]</span>
<pre>void luaL_setfuncs (lua_State *L, const luaL_Reg *l, int nup);</pre>

<p>
把數組 <code>l</code> 中的所有函式
（參見 <a href="#luaL_Reg"><code>luaL_Reg</code></a>）
註冊到堆疊頂的表中（該表在可選的上值之下，見下面的解說）。

<p>
若 <code>nup</code> 不為零，
所有的函式都共享 <code>nup</code> 個上值。
這些值必須在調用之前，壓在表之上。
這些值在註冊完畢後都會從堆疊彈出。




<hr><h3><a name="luaL_setmetatable"><code>luaL_setmetatable</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_setmetatable (lua_State *L, const char *tname);</pre>

<p>
將註冊表中 <code>tname</code> 關聯元表
（參見 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）
設為堆疊頂對象的元表。




<hr><h3><a name="luaL_Stream"><code>luaL_Stream</code></a></h3>
<pre>typedef struct luaL_Stream {
  FILE *f;
  lua_CFunction closef;
} luaL_Stream;</pre>

<p>
標準輸入輸出庫中用到的標準文件句柄結構。

<p>
文件句柄實現為一個完全用戶數據，
其元表被稱為 <code>LUA_FILEHANDLE</code>
（<code>LUA_FILEHANDLE</code> 是一個代表真正元表的名字的宏）。
這張元表由標準輸入輸出庫（參見 <a href="#luaL_newmetatable"><code>luaL_newmetatable</code></a>）創建。


<p>
用戶數據必須以結構 <code>luaL_Stream</code> 開頭；
此結構其後可以包含任何其它數據。
<code>f</code> 域指向一個 C 數據流
（如果它為 <code>NULL</code> 表示一個沒有創建好的句柄）。
<code>closef</code> 域指向一個在關閉或回收該流時需要調用的 Lua 函式。
該函式將收到一個參數，即文件句柄。
它需要返回 <b>true</b>（操作成功）或
<b>nil</b> 加錯誤消息（出錯的時候）。
一旦 Lua 調用過這個域，該域的值就會修改為 <code>NULL</code>
以提示這個句柄已經被關閉了。




<hr><h3><a name="luaL_testudata"><code>luaL_testudata</code></a></h3><p>
<span class="apii">[-0, +0, <em>e</em>]</span>
<pre>void *luaL_testudata (lua_State *L, int arg, const char *tname);</pre>

<p>
此函式和 <a href="#luaL_checkudata"><code>luaL_checkudata</code></a> 類似。
但它在測試失敗時會返回 <code>NULL</code> 而不是拋出錯誤。





<hr><h3><a name="luaL_tolstring"><code>luaL_tolstring</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>const char *luaL_tolstring (lua_State *L, int idx, size_t *len);</pre>

<p>
將給定索引處的 Lua 值轉換為一個相應格式的 C 字串。
結果串不僅會壓堆疊，還會由函式返回。
如果 <code>len</code> 不為 <code>NULL</code> ，
它還把字串長度設到 <code>*len</code> 中。


<p>
如果該值有一個帶 <code>"__tostring"</code> 域的元表，
<code>luaL_tolstring</code> 會以該值為參數去調用對應的元方法，
並將其返回值作為結果。



<hr><h3><a name="luaL_traceback"><code>luaL_traceback</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
                     int level);</pre>

<p>
將堆疊 <code>L1</code> 的堆疊回溯信息壓堆疊。
如果 <code>msg</code> 不為 <code>NULL</code> ，它會附加到堆疊回溯信息之前。
<code>level</code> 參數指明從第幾層開始做堆疊回溯。




<hr><h3><a name="luaL_typename"><code>luaL_typename</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>const char *luaL_typename (lua_State *L, int index);</pre>

<p>
返回給定索引處值的型別名。





<hr><h3><a name="luaL_unref"><code>luaL_unref</code></a></h3><p>
<span class="apii">[-0, +0, &ndash;]</span>
<pre>void luaL_unref (lua_State *L, int t, int ref);</pre>

<p>
釋放索引 <code>t</code> 處表的 <code>ref</code> 引用對像
（參見 <a href="#luaL_ref"><code>luaL_ref</code></a> ）。
此條目會從表中移除以讓其引用的對象可被垃圾收集。
而引用 <code>ref</code> 也被回收再次使用。


<p>
如果 <code>ref</code> 為 <a href="#pdf-LUA_NOREF"><code>LUA_NOREF</code></a> 
或 <a href="#pdf-LUA_REFNIL"><code>LUA_REFNIL</code></a>，
<a href="#luaL_unref"><code>luaL_unref</code></a> 什麼也不做。





<hr><h3><a name="luaL_where"><code>luaL_where</code></a></h3><p>
<span class="apii">[-0, +1, <em>e</em>]</span>
<pre>void luaL_where (lua_State *L, int lvl);</pre>

<p>
將一個用於表示 <code>lvl</code> 層堆疊的控制點位置的字串壓堆疊。
這個字串遵循下面的格式：

<pre>
     <em>chunkname</em>:<em>currentline</em>:
</pre><p>
0 層指當前正在運行的函式，
1 層指調用正在運行函式的函式，
依次類推。


<p>
這個函式用於構建錯誤消息的前綴。






<h1>6 &ndash; <a name="6">標準庫</a></h1>

<p>
標準庫提供了一些有用的函式,
它們都是直接用 C API 實現的。
其中一些函式提供了原本語言就有的服務
（例如，<a href="#pdf-type"><code>type</code></a> 與 <a href="#pdf-getmetatable"><code>getmetatable</code></a>）；
另一些提供和「外部」打交道的服務（例如 I/O ）；
還有些本可以用 Lua 本身來實現，但在 C 中實現可以滿足關鍵點上的性能需求
（例如 <a href="#pdf-table.sort"><code>table.sort</code></a>）。

<p>
所有的庫都是直接用 C API 實現的，並以分離的 C 模塊形式提供。
目前，Lua 有下列標準庫：

<ul>

<li>基礎庫 (<a href="#6.1">&sect;6.1</a>);</li>

<li>協程庫 (<a href="#6.2">&sect;6.2</a>);</li>

<li>包管理庫 (<a href="#6.3">&sect;6.3</a>);</li>

<li>字串控制 (<a href="#6.4">&sect;6.4</a>);</li>

<li>基礎 UTF-8 支持 (<a href="#6.5">&sect;6.5</a>);</li>

<li>表控制 (<a href="#6.6">&sect;6.6</a>);</li>

<li>數學函式 (<a href="#6.7">&sect;6.7</a>) (sin ，log 等);</li>

<li>輸入輸出 (<a href="#6.8">&sect;6.8</a>);</li>

<li>操作系統設施 (<a href="#6.9">&sect;6.9</a>);</li>

<li>調試設施 (<a href="#6.10">&sect;6.10</a>).</li>

</ul><p>
除了基礎庫和包管理庫，
其它庫都把自己的函式放在一張全局表的域中，
或是以對像方法的形式提供。


<p>
要使用這些庫，
C 的宿主程序需要先調用一下
<a href="#luaL_openlibs"><code>luaL_openlibs</code></a> 這個函式，
這樣就能打開所有的標準庫。
或者宿主程序也可以用
<a href="#luaL_requiref"><code>luaL_requiref</code></a> 分別打開這些庫：
<a name="pdf-luaopen_base"><code>luaopen_base</code></a> （基礎庫），
<a name="pdf-luaopen_package"><code>luaopen_package</code></a> （包管理庫），
<a name="pdf-luaopen_coroutine"><code>luaopen_coroutine</code></a> （協程庫），
<a name="pdf-luaopen_string"><code>luaopen_string</code></a> （字串庫），
<a name="pdf-luaopen_utf8"><code>luaopen_utf8</code></a> （UTF8 庫），
<a name="pdf-luaopen_table"><code>luaopen_table</code></a> （表處理庫），
<a name="pdf-luaopen_math"><code>luaopen_math</code></a> （數學庫），
<a name="pdf-luaopen_io"><code>luaopen_io</code></a> （I/O 庫），
<a name="pdf-luaopen_os"><code>luaopen_os</code></a> （操作系統庫），
<a name="pdf-luaopen_debug"><code>luaopen_debug</code></a> （調試庫）。
這些函式都定義在 <a name="pdf-lualib.h"><code>lualib.h</code></a> 中。



<h2>6.1 &ndash; <a name="6.1">基礎函式</a></h2>

<p>
基礎庫提供了 Lua 核心函式。
如果你不將這個庫包含在你的程序中，
你就需要小心檢查程序是否需要自己提供其中一些特性的實現。

<p>
<hr><h3><a name="pdf-assert"><code>assert (v [, message])</code></a></h3>


<p>
如果其參數 <code>v</code> 的值為假（<b>nil</b> 或 <b>false</b>），
它就調用 <a href="#pdf-error"><code>error</code></a>；
否則，返回所有的參數。
在錯誤情況時，
<code>message</code> 指那個錯誤對像；
如果不提供這個參數，參數默認為 "<code>assertion failed!</code>" 。




<p>
<hr><h3><a name="pdf-collectgarbage"><code>collectgarbage ([opt [, arg]])</code></a></h3>


<p>
這個函式是垃圾收集器的通用接口。
通過參數 <code>opt</code> 它提供了一組不同的功能：

<ul>

<li><b>"<code>collect</code>": </b>
做一次完整的垃圾收集循環。
這是默認選項。
</li>

<li><b>"<code>stop</code>": </b>
停止垃圾收集器的運行。
在調用重啟前，收集器只會因顯式的調用運行。
</li>

<li><b>"<code>restart</code>": </b>
重啟垃圾收集器的自動運行。
</li>

<li><b>"<code>count</code>": </b>
以 K 字節數為單位返回 Lua 使用的總記憶體數。
這個值有小數部分，所以只需要乘上 1024 就能得到
Lua 使用的準確字節數（除非溢出）。
</li>

<li><b>"<code>step</code>": </b>
單步運行垃圾收集器。
步長「大小」由 <code>arg</code> 控制。
傳入 0 時，收集器步進（不可分割的）一步。
傳入非 0 值，
收集器收集相當於 Lua 分配這些多（K 字節）記憶體的工作。
如果收集器結束一個循環將返回 <b>true</b> 。
</li>

<li><b>"<code>setpause</code>": </b>
將 <code>arg</code> 設為收集器的 <em>間歇率</em>
（參見 <a href="#2.5">&sect;2.5</a>）。
返回 <em>間歇率</em> 的前一個值。
</li>

<li><b>"<code>setstepmul</code>": </b>
將 <code>arg</code> 設為收集器的 <em>步進倍率</em>
（參見 <a href="#2.5">&sect;2.5</a>）。
返回 <em>步進倍率</em> 的前一個值。
</li>

<li><b>"<code>isrunning</code>": </b>
返回表示收集器是否在工作的布爾值
（即未被停止）。
</li>

</ul>



<p>
<hr><h3><a name="pdf-dofile"><code>dofile ([filename])</code></a></h3>
打開該名字的文件，並執行文件中的 Lua 代碼塊。
不帶參數調用時， <code>dofile</code> 執行標準輸入的內容（<code>stdin</code>）。
返回該代碼塊的所有返回值。
對於有錯誤的情況，<code>dofile</code> 將錯誤反饋給調用者
（即，<code>dofile</code> 沒有運行在保護模式下）。




<p>
<hr><h3><a name="pdf-error"><code>error (message [, level])</code></a></h3>
中止上一次保護函式調用，
將錯誤對像 <code>message</code> 返回。
函式 <code>error</code> 永遠不會返回。


<p>
當 message 是一個字串時，通常 <code>error</code> 會把一些有關出錯位置的信息附加在消息的前頭。
<code>level</code> 參數指明了怎樣獲得出錯位置。
對於 level 1 （默認值），出錯位置指 <code>error</code> 函式調用的位置。
Level 2 將出錯位置指向調用 <code>error</code>的函式的函式；以此類推。
傳入 level 0 可以避免在消息前添加出錯位置信息。




<p>
<hr><h3><a name="pdf-_G"><code>_G</code></a></h3>
一個全局變量（非函式），
內部儲存有全局環境（參見 <a href="#2.2">&sect;2.2</a>）。
Lua 自己不使用這個變量；
改變這個變量的值不會對任何環境造成影響，反之亦然。




<p>
<hr><h3><a name="pdf-getmetatable"><code>getmetatable (object)</code></a></h3>


<p>
如果 <code>object</code> 不包含元表，返回 <b>nil</b> 。
否則，如果在該對象的元表中有 <code>"__metatable"</code> 域時返回其關聯值，
沒有時返回該對象的元表。



<p>
<hr><h3><a name="pdf-ipairs"><code>ipairs (t)</code></a></h3>


<p>
返回三個值（迭代函式、表 <code>t</code> 以及 0 ），
如此，以下代碼

<pre>
     for i,v in ipairs(t) do <em>body</em> end
</pre><p>
將迭代鍵值對（<code>1,t[1]</code>) ，(<code>2,t[2]</code>)， ... ，直到第一個空值。



<p>
<hr><h3><a name="pdf-load"><code>load (chunk [, chunkname [, mode [, env]]])</code></a></h3>


<p>
加載一個代碼塊。


<p>
如果 <code>chunk</code> 是一個字串，代碼塊指這個字串。
如果 <code>chunk</code> 是一個函式，
<code>load</code> 不斷地調用它獲取代碼塊的片斷。
每次對 <code>chunk</code> 的調用都必須返回一個字串緊緊連接在上次調用的返回串之後。
當返回空串、<b>nil</b>、或是不返回值時，都表示代碼塊結束。


<p>
如果沒有語法錯誤，
則以函式形式返回編譯好的代碼塊；
否則，返回 <b>nil</b> 加上錯誤消息。


<p>
如果結果函式有上值，
<code>env</code> 被設為第一個上值。
若不提供此參數，將全局環境替代它。
所有其它上值初始化為 <b>nil</b>。
（當你加載主代碼塊時候，結果函式一定有且僅有一個上值 <code>_ENV</code> 
（參見 <a href="#2.2">&sect;2.2</a>））。
然而，如果你加載一個用函式（參見 <a href="#pdf-string.dump"><code>string.dump</code></a>，
結果函式可以有任意數量的上值）
創建出來的二進制代碼塊時，所有的上值都是新創建出來的。
也就是說它們不會和別的任何函式共享。


<p>
<code>chunkname</code> 在錯誤消息和調試消息中（參見 <a href="#4.9">&sect;4.9</a>），用於代碼塊的名字。
如果不提供此參數，它默認為字串<code>chunk</code> 。
<code>chunk</code> 不是字串時，則為 "<code>=(load)</code>" 。


<p>
字串 <code>mode</code> 用於控制代碼塊是文本還是二進制（即預編譯代碼塊）。
它可以是字串 "<code>b</code>" （只能是二進制代碼塊），
"<code>t</code>" （只能是文本代碼塊），
或 "<code>bt</code>" （可以是二進制也可以是文本）。
默認值為 "<code>bt</code>"。


<p>
Lua 不會對二進制代碼塊做健壯性檢查。
惡意構造一個二進制塊有可能把解釋器弄崩潰。



<p>
<hr><h3><a name="pdf-loadfile"><code>loadfile ([filename [, mode [, env]]])</code></a></h3>


<p>
和 <a href="#pdf-load"><code>load</code></a> 類似，
不過是從文件 <code>filename</code> 或標準輸入（如果文件名未提供）中獲取代碼塊。




<p>
<hr><h3><a name="pdf-next"><code>next (table [, index])</code></a></h3>


<p>
運行程序來遍歷表中的所有域。
第一個參數是要遍歷的表，第二個參數是表中的某個鍵。
<code>next</code> 返回該鍵的下一個鍵及其關聯的值。
如果用 <b>nil</b> 作為第二個參數調用 <code>next</code>
將返回初始鍵及其關聯值。
當以最後一個鍵去調用，或是以 <b>nil</b> 調用一張空表時，
<code>next</code> 返回 <b>nil</b>。
如果不提供第二個參數，將認為它就是 <b>nil</b>。
特別指出，你可以用 <code>next(t)</code> 來判斷一張表是否是空的。


<p>
索引在遍歷過程中的次序無定義，
<em>即使是數字索引也是這樣</em>。
（如果想按數字次序遍歷表，可以使用數字形式的 <b>for</b> 。）


<p>
當在遍歷過程中你給表中並不存在的域賦值，
<code>next</code> 的行為是未定義的。
然而你可以去修改那些已存在的域。
特別指出，你可以清除一些已存在的域。



<p>
<hr><h3><a name="pdf-pairs"><code>pairs (t)</code></a></h3>


<p>
如果 <code>t</code> 有元方法 <code>__pairs</code>，
以 <code>t</code> 為參數調用它，並返回其返回的前三個值。


<p>
否則，返回三個值：<a href="#pdf-next"><code>next</code></a> 函式，
表 <code>t</code>，以及 <b>nil</b>。
因此以下代碼

<pre>
     for k,v in pairs(t) do <em>body</em> end
</pre><p>
能迭代表 <code>t</code> 中的所有鍵值對。


<p>
參見函式 <a href="#pdf-next"><code>next</code></a> 中關於迭代過程中修改表的風險。




<p>
<hr><h3><a name="pdf-pcall"><code>pcall (f [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
傳入參數，以 <em>保護模式</em> 調用函式 <code>f</code> 。
這意味著 <code>f</code> 中的任何錯誤不會拋出；
取而代之的是，<code>pcall</code> 會將錯誤捕獲到，並返回一個狀態碼。
第一個返回值是狀態碼（一個布爾量），
當沒有錯誤時，其為真。
此時，<code>pcall</code> 同樣會在狀態碼後返回所有調用的結果。
在有錯誤時，<code>pcall</code> 返回 <b>false</b> 加錯誤消息。




<p>
<hr><h3><a name="pdf-print"><code>print (&middot;&middot;&middot;)</code></a></h3>
接收任意數量的參數，並將它們的值打印到 <code>stdout</code>。
它用 <a href="#pdf-tostring"><code>tostring</code></a> 函式將每個參數都轉換為字串。
<code>print</code> 不用於做格式化輸出。僅作為看一下某個值的快捷方式。
多用於調試。
完整的對輸出的控制，請使用 <a href="#pdf-string.format"><code>string.format</code></a> 以及 <a href="#pdf-io.write"><code>io.write</code></a>。




<p>
<hr><h3><a name="pdf-rawequal"><code>rawequal (v1, v2)</code></a></h3>
在不觸發任何元方法的情況下
檢查 <code>v1</code> 是否和 <code>v2</code> 相等。
返回一個布爾量。



<p>
<hr><h3><a name="pdf-rawget"><code>rawget (table, index)</code></a></h3>
在不觸發任何元方法的情況下
獲取 <code>table[index]</code> 的值。
<code>table</code> 必須是一張表；
<code>index</code> 可以是任何值。




<p>
<hr><h3><a name="pdf-rawlen"><code>rawlen (v)</code></a></h3>
在不觸發任何元方法的情況下
返回對像 <code>v</code> 的長度。
<code>v</code> 可以是表或字串。
它返回一個整數。


<p>
<hr><h3><a name="pdf-rawset"><code>rawset (table, index, value)</code></a></h3>
在不觸發任何元方法的情況下
將 <code>table[index]</code> 設為 <code>value</code>。
<code>table</code> 必須是一張表，
<code>index</code> 可以是 <b>nil</b> 與 NaN 之外的任何值。
<code>value</code> 可以是任何 Lua 值。


<p>
這個函式返回 <code>table</code>。




<p>
<hr><h3><a name="pdf-select"><code>select (index, &middot;&middot;&middot;)</code></a></h3>


<p>
如果 <code>index</code> 是個數字，
那麼返回參數中第 <code>index</code> 個之後的部分；
負的數字會從後向前索引（-1 指最後一個參數）。
否則，<code>index</code> 必須是字串 <code>"#"</code>，
此時 <code>select</code> 返回參數的個數。




<p>
<hr><h3><a name="pdf-setmetatable"><code>setmetatable (table, metatable)</code></a></h3>


<p>
給指定表設置元表。
（你不能在 Lua 中改變其它型別值的元表，那些只能在 C 裡做。）
如果 <code>metatable</code> 是 <b>nil</b>，
將指定表的元表移除。
如果原來那張元表有 <code>"__metatable"</code> 域，拋出一個錯誤。


<p>
這個函式返回 <code>table</code>。




<p>
<hr><h3><a name="pdf-tonumber"><code>tonumber (e [, base])</code></a></h3>


<p>
如果調用的時候沒有 <code>base</code>，
<code>tonumber</code> 嘗試把參數轉換為一個數字。
如果參數已經是一個數字，或是一個可以轉換為數字的字串，
<code>tonumber</code> 就返回這個數字；
否則返回 <b>nil</b>。


<p>
字串的轉換結果可能是整數也可能是浮點數，
這取決於 Lua 的轉換文法（參見 <a href="#3.1">&sect;3.1</a>）。
（字串可以有前置和後置的空格，可以帶符號。）


<p>
當傳入 <code>base</code> 調用它時，
<code>e</code> 必須是一個以該進製表示的整數字串。
進制可以是 2 到 36 （包含 2 和 36）之間的任何整數。
大於 10 進制時，字母 '<code>A</code>' （大小寫均可）表示 10 ，
'<code>B</code>' 表示 11，依次到 '<code>Z</code>' 表示 35 。
如果字串 <code>e</code> 不是該進制下的合法數字，
函式返回 <b>nil</b>。




<p>
<hr><h3><a name="pdf-tostring"><code>tostring (v)</code></a></h3>
可以接收任何型別，它將其轉換為人可閱讀的字串形式。
浮點數總被轉換為浮點數的表現形式（小數點形式或是指數形式）。
（如果想完全控制數字如何被轉換，可以使用
<a href="#pdf-string.format"><code>string.format</code></a>。）


<p>
如果 <code>v</code> 有 <code>"__tostring"</code> 域的元表，
<code>tostring</code> 會以 <code>v</code> 為參數調用它。
並用它的結果作為返回值。



<p>
<hr><h3><a name="pdf-type"><code>type (v)</code></a></h3>
將參數的型別編碼為一個字串返回。
函式可能的返回值有
"<code>nil</code>" （一個字串，而不是 <b>nil</b> 值），
"<code>number</code>"，
"<code>string</code>"，
"<code>boolean</code>"，
"<code>table</code>"，
"<code>function</code>"，
"<code>thread</code>"，
"<code>userdata</code>"。




<p>
<hr><h3><a name="pdf-_VERSION"><code>_VERSION</code></a></h3>
一個包含有當前解釋器版本號的全局變量（並非函式）。
當前這個變量的值為 "<code>Lua 5.3</code>"。




<p>
<hr><h3><a name="pdf-xpcall"><code>xpcall (f, msgh [, arg1, &middot;&middot;&middot;])</code></a></h3>


<p>
這個函式和 <a href="#pdf-pcall"><code>pcall</code></a> 類似。
不過它可以額外設置一個消息處理器 <code>msgh</code>。







<h2>6.2 &ndash; <a name="6.2">協程管理</a></h2>

<p>
關於協程的操作作為基礎庫的一個子庫，
被放在一個獨立表 <a name="pdf-coroutine"><code>coroutine</code></a> 中。
協程的介紹參見 <a href="#2.6">&sect;2.6</a> 。


<p>
<hr><h3><a name="pdf-coroutine.create"><code>coroutine.create (f)</code></a></h3>


<p>
創建一個主體函式為 <code>f</code> 的新協程。
<code>f</code> 必須是一個 Lua 的函式。
返回這個新協程，它是一個型別為 <code>"thread"</code> 的對象。



<p>
<hr><h3><a name="pdf-coroutine.isyieldable"><code>coroutine.isyieldable ()</code></a></h3>


<p>
如果正在運行的協程可以讓出，則返回真。


<p>
不在主線程中或不在一個無法讓出的 C 函式中時，當前協程是可讓出的。




<p>
<hr><h3><a name="pdf-coroutine.resume"><code>coroutine.resume (co [, val1, &middot;&middot;&middot;])</code></a></h3>


<p>
開始或繼續協程 <code>co</code> 的運行。
當你第一次延續一個協程，它會從主體函式處開始運行。
<code>val1</code>, ... 這些值會以參數形式傳入主體函式。
如果該協程被讓出，<code>resume</code> 會重新啟動它；
<code>val1</code>, ... 這些參數會作為讓出點的返回值。


<p>
如果協程運行起來沒有錯誤，
<code>resume</code> 返回 <b>true</b> 加上傳給 <code>yield</code> 的所有值
（當協程讓出），
或是主體函式的所有返回值（當協程中止）。
如果有任何錯誤發生，
<code>resume</code> 返回 <b>false</b> 加錯誤消息。




<p>
<hr><h3><a name="pdf-coroutine.running"><code>coroutine.running ()</code></a></h3>


<p>
返回當前正在運行的協程加一個布爾量。
如果當前運行的協程是主線程，其為真。




<p>
<hr><h3><a name="pdf-coroutine.status"><code>coroutine.status (co)</code></a></h3>


<p>
以字串形式返回協程 <code>co</code> 的狀態：
當協程正在運行（它就是調用 <code>status</code> 的那個） ，返回 <code>"running"</code>；
如果協程調用 <code>yield</code> 掛起或是還沒有開始運行，返回 <code>"suspended"</code>；
如果協程是活動的，都並不在運行（即它正在延續其它協程），返回 <code>"normal"</code>；
如果協程運行完主體函式或因錯誤停止，返回 <code>"dead"</code>。




<p>
<hr><h3><a name="pdf-coroutine.wrap"><code>coroutine.wrap (f)</code></a></h3>


<p>
創建一個主體函式為 <code>f</code> 的新協程。
<code>f</code> 必須是一個 Lua 的函式。
返回一個函式，
每次調用該函式都會延續該協程。
傳給這個函式的參數都會作為 <code>resume</code> 的額外參數。
和 <code>resume</code> 返回相同的值，
只是沒有第一個布爾量。
如果發生任何錯誤，拋出這個錯誤。




<p>
<hr><h3><a name="pdf-coroutine.yield"><code>coroutine.yield (&middot;&middot;&middot;)</code></a></h3>


<p>
掛起正在調用的協程的執行。
傳遞給 <code>yield</code> 的參數都會轉為 <code>resume</code> 的額外返回值。






<h2>6.3 &ndash; <a name="6.3">模塊</a></h2>

<p>
包管理庫提供了從 Lua 中加載模塊的基礎設施。
只有一個導出函式直接放在全局環境中：
<a href="#pdf-require"><code>require</code></a>。
所有其它的部分都導出在表 <a name="pdf-package"><code>package</code></a> 中。


<p>
<hr><h3><a name="pdf-require"><code>require (modname)</code></a></h3>


<p>
加載一個模塊。
這個函式首先查找 <a href="#pdf-package.loaded"><code>package.loaded</code></a> 表，
檢測 <code>modname</code> 是否被加載過。
如果被加載過，<code>require</code> 返回 <code>package.loaded[modname]</code> 中保存的值。
否則，它試著為模塊尋找 <em>加載器</em> 。


<p>

<code>require</code> 遵循 <a href="#pdf-package.searchers"><code>package.searchers</code></a> 序列的指引來查找加載器。
如果改變這個序列，我們可以改變 <code>require</code> 如何查找一個模塊。
下列說明基於 <a href="#pdf-package.searchers"><code>package.searchers</code></a>
的默認配置。


<p>
首先 <code>require</code> 查找 <code>package.preload[modname]</code> 。
如果這裡有一個值，這個值（必須是一個函式）就是那個加載器。
否則 <code>require</code> 使用 Lua 加載器去查找
<a href="#pdf-package.path"><code>package.path</code></a> 的路徑。
如果查找失敗，接著使用 C 加載器去查找
<a href="#pdf-package.cpath"><code>package.cpath</code></a> 的路徑。
如果都失敗了，再嘗試 <em>一體化</em> 加載器 （參見 <a href="#pdf-package.searchers"><code>package.searchers</code></a>）。


<p>
每次找到一個加載器，<code>require</code> 都用兩個參數調用加載器：
<code>modname</code> 和一個在獲取加載器過程中得到的參數。
（如果通過查找文件得到的加載器，這個額外參數是文件名。）
如果加載器返回非空值，
<code>require</code> 將這個值賦給 <code>package.loaded[modname]</code>。
如果加載器沒能返回一個非空值用於賦給 <code>package.loaded[modname]</code>，
<code>require</code> 會在那裡設入 <b>true</b> 。
無論是什麼情況，<code>require</code> 都會返回
<code>package.loaded[modname]</code> 的最終值。


<p>
如果在加載或運行模塊時有錯誤，
或是無法為模塊找到加載器，
<code>require</code> 都會拋出錯誤。




<p>
<hr><h3><a name="pdf-package.config"><code>package.config</code></a></h3>


<p>
一個描述有一些為包管理準備的編譯期配置信息的串。
這個字串由一系列行構成：

<ul>

<li>第一行是目錄分割串。
對於 Windows 默認是 '<code>\</code>' ，對於其它系統是 '<code>/</code>' 。</li>

<li>第二行是用於路徑中的分割符。默認值是 '<code>;</code>' 。</li>

<li>第三行是用於標記模板替換點的字串。
默認是 '<code>?</code>' 。</li>

<li>第四行是在 Windows 中將被替換成執行程序所在目錄的路徑的字串。
默認是 '<code>!</code>' 。</li>

<li>第五行是一個記號，該記號之後的所有文本將在構建 <code>luaopen_</code> 函式名時被忽略掉。
默認是 '<code>-</code>'。</li>

</ul>



<p>
<hr><h3><a name="pdf-package.cpath"><code>package.cpath</code></a></h3>


<p>
這個路徑被 <a href="#pdf-require"><code>require</code></a> 在 C 加載器中做搜索時用到。


<p>
Lua 用和初始化 Lua 路徑 <a href="#pdf-package.path"><code>package.path</code></a>
相同的方式初始化 C 路徑 <a href="#pdf-package.cpath"><code>package.cpath</code></a> 。
它會使用環境變量 <a name="pdf-LUA_CPATH_5_3"><code>LUA_CPATH_5_3</code></a> 或
環境變量 <a name="pdf-LUA_CPATH"><code>LUA_CPATH</code></a> 初始化。
要麼就採用 <code>luaconf.h</code> 中定義的默認路徑。



<p>
<hr><h3><a name="pdf-package.loaded"><code>package.loaded</code></a></h3>


<p>
用於 <a href="#pdf-require"><code>require</code></a> 控制哪些模塊已經被加載的表。
當你請求一個 <code>modname</code> 模塊，且
<code>package.loaded[modname]</code> 不為假時，
<a href="#pdf-require"><code>require</code></a> 簡單返回儲存在內的值。


<p>
這個變量僅僅是對真正那張表的引用；
改變這個值並不會改變 <a href="#pdf-require"><code>require</code></a> 使用的表。




<p>
<hr><h3><a name="pdf-package.loadlib"><code>package.loadlib (libname, funcname)</code></a></h3>


<p>
讓宿主程序動態鏈接 C 庫 <code>libname</code> 。


<p>
當 <code>funcname</code> 為 "<code>*</code>"，
它僅僅連接該庫，讓庫中的符號都導出給其它動態鏈接庫使用。
否則，它查找庫中的函式 <code>funcname</code> ，以 C 函式的形式返回這個函式。
因此，<code>funcname</code> 必須遵循原型 <a href="#lua_CFunction"><code>lua_CFunction</code></a> 
（參見 <a href="#lua_CFunction"><code>lua_CFunction</code></a>）。


<p>
這是一個低階函式。
它完全繞過了包模塊系統。
和 <a href="#pdf-require"><code>require</code></a> 不同，
它不會做任何路徑查詢，也不會自動加擴展名。
<code>libname</code> 必須是一個 C 庫需要的完整的文件名，如果有必要，需要提供路徑和擴展名。
<code>funcname</code> 必須是 C 庫需要的準確名字
（這取決於使用的 C 編譯器和鏈接器）。


<p>
這個函式在標準 C 中不支持。
因此，它只在部分平台有效
（ Windows ，Linux ，Mac OS X, Solaris, BSD, 加上支持
<code>dlfcn</code> 標準的 Unix 系統）。




<p>
<hr><h3><a name="pdf-package.path"><code>package.path</code></a></h3>


<p>
這個路徑被 <a href="#pdf-require"><code>require</code></a> 在 Lua 加載器中做搜索時用到。


<p>
在啟動時，Lua 用環境變量 <a name="pdf-LUA_PATH_5_3"><code>LUA_PATH_5_3</code></a>
或環境變量 <a name="pdf-LUA_PATH"><code>LUA_PATH</code></a> 來初始化這個變量。
或採用 <code>luaconf.h</code> 中的默認路徑。
環境變量中出現的所有 "<code>;;</code>" 都會被替換成默認路徑。




<p>
<hr><h3><a name="pdf-package.preload"><code>package.preload</code></a></h3>


<p>
保存有一些特殊模塊的加載器
（參見 <a href="#pdf-require"><code>require</code></a>）。


<p>
這個變量僅僅是對真正那張表的引用；
改變這個值並不會改變 <a href="#pdf-require"><code>require</code></a> 使用的表。




<p>
<hr><h3><a name="pdf-package.searchers"><code>package.searchers</code></a></h3>


<p>
用於 <a href="#pdf-require"><code>require</code></a> 控制如何加載模塊的表。


<p>
這張表內的每一項都是一個 <em>查找器函式</em>。
當查找一個模塊時，
<a href="#pdf-require"><code>require</code></a> 按次序調用這些查找器，
並傳入模塊名（<a href="#pdf-require"><code>require</code></a> 的參數）作為唯一的一個參數。
此函式可以返回另一個函式（模塊的 <em>加載器</em>）加上另一個將傳遞給這個加載器的參數。
或是返回一個描述為何沒有找到這個模塊的字串
（或是返回 <b>nil</b> 什麼也不想說）。


<p>
Lua 用四個查找器函式初始化這張表。


<p>
第一個查找器就是簡單的在 <a href="#pdf-package.preload"><code>package.preload</code></a> 表中查找加載器。


<p>
第二個查找器用於查找 Lua 庫的加載庫。
它使用儲存在 <a href="#pdf-package.path"><code>package.path</code></a> 中的路徑來做查找工作。
查找過程和函式 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 描述的一致。


<p>
第三個查找器用於查找 C 庫的加載庫。
它使用儲存在 <a href="#pdf-package.path"><code>package.cpath</code></a> 中的路徑來做查找工作。
同樣，
查找過程和函式 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 描述的一致。
例如，如果 C 路徑是這樣一個字串

<pre>
     "./?.so;./?.dll;/usr/local/?/init.so"
</pre><p>
查找器查找模塊 <code>foo</code> 
會依次嘗試打開文件 <code>./foo.so</code>，<code>./foo.dll</code>，
以及 <code>/usr/local/foo/init.so</code>。
一旦它找到一個 C 庫，
查找器首先使用動態鏈接機制連接該庫。
然後嘗試在該庫中找到可以用作加載器的 C 函式。
這個 C 函式的名字是 "<code>luaopen_</code>" 緊接模塊名的字串，
其中字串中所有的下劃線都會被替換成點。
此外，如果模塊名中有橫線，
橫線後面的部分（包括橫線）都被去掉。
例如，如果模塊名為 <code>a.b.c-v2.1</code>，
函式名就是 <code>luaopen_a_b_c</code>。


<p>
第四個搜索器是　<em>一體化加載器</em>。
它從 C 路徑中查找指定模塊的根名字。
例如，當請求 <code>a.b.c</code>　時，
它將查找 <code>a</code> 這個 C 庫。
如果找得到，它會在裡面找子模塊的加載函式。
在我們的例子中，就是找　<code>luaopen_a_b_c</code>。
利用這個機制，可以把若干 C 子模塊打包進單個庫。
每個子模塊都可以有原本的加載函式名。


<p>
除了第一個（預加載）搜索器外，每個搜索器都會返回
它找到的模塊的文件名。
這和 <a href="#pdf-package.searchpath"><code>package.searchpath</code></a> 的返回值一樣。
第一個搜索器沒有返回值。



<p>
<hr><h3><a name="pdf-package.searchpath"><code>package.searchpath (name, path [, sep [, rep]])</code></a></h3>


<p>
在指定 <code>path</code> 中搜索指定的 <code>name</code> 。


<p>
路徑是一個包含有一系列以分號分割的 <em>模板</em> 構成的字串。
對於每個模板，都會用 <code>name</code> 替換其中的每個問號（如果有的話）。
且將其中的 <code>sep</code> （默認是點）替換為  <code>rep</code>
（默認是系統的目錄分割符）。
然後嘗試打開這個文件名。


<p>
例如，如果路徑是字串

<pre>
     "./?.lua;./?.lc;/usr/local/?/init.lua"
</pre><p>
搜索 <code>foo.a</code>　這個名字將
依次嘗試打開文件
<code>./foo/a.lua</code>　， <code>./foo/a.lc</code>　，以及
<code>/usr/local/foo/a/init.lua</code>。


<p>
返回第一個可以用讀模式打開（並馬上關閉該文件）的文件的名字。
如果不存在這樣的文件，返回 <b>nil</b> 加上錯誤消息。
（這條錯誤消息列出了所有嘗試打開的文件名。）






<h2>6.4 &ndash; <a name="6.4">字串處理</a></h2>

<p>
這個庫提供了字串處理的通用函式。
例如字串查找、子串、模式匹配等。
當在 Lua 中對字串做索引時，第一個字符從 1 開始計算（而不是 C 裡的 0 ）。
索引可以是負數，它指從字串末尾反向解析。
即，最後一個字符在 -1 位置處，等等。


<p>
字串庫中的所有函式都在表 <a name="pdf-string"><code>string</code></a> 中。
它還將其設置為字串元表的 <code>__index</code> 域。
因此，你可以以面向對象的形式使用字串函式。
例如，<code>string.byte(s,i)</code> 可以寫成 <code>s:byte(i)</code>。


<p>
字串庫假定採用單字節字符編碼。


<p>
<hr><h3><a name="pdf-string.byte"><code>string.byte (s [, i [, j]])</code></a></h3>
返回字符 <code>s[i]</code>，
<code>s[i+1]</code>， ...　，<code>s[j]</code>
的內部數字編碼。
<code>i</code> 的默認值是 1 ；
<code>j</code> 的默認值是 <code>i</code>。
這些索引以函式 <a href="#pdf-string.sub"><code>string.sub</code></a> 的規則修正。


<p>
數字編碼沒有必要跨平台。




<p>
<hr><h3><a name="pdf-string.char"><code>string.char (&middot;&middot;&middot;)</code></a></h3>
接收零或更多的整數。
返回和參數數量相同長度的字串。
其中每個字符的內部編碼值等於對應的參數值。

<p>
數字編碼沒有必要跨平台。



<p>
<hr><h3><a name="pdf-string.dump"><code>string.dump (function [, strip])</code></a></h3>


<p>
返回包含有以二進制方式表示的（一個 <em>二進制代碼塊</em> ）指定函式的字串。
之後可以用 <a href="#pdf-load"><code>load</code></a> 調用這個字串獲得
該函式的副本（但是綁定新的上值）。
如果　<code>strip</code> 為真值，
二進制代碼塊不攜帶該函式的調試信息
（局部變量名，行號，等等。）。


<p>
帶上值的函式只保存上值的數目。
當（再次）加載時，這些上值被更新為 <b>nil</b> 的實例。
（你可以使用調試庫按你需要的方式來序列化上值，並重載到函式中）



<p>
<hr><h3><a name="pdf-string.find"><code>string.find (s, pattern [, init [, plain]])</code></a></h3>


<p>
查找第一個字串 <code>s</code> 中匹配到的 <code>pattern</code>
（參見 <a href="#6.4.1">&sect;6.4.1</a>）。
如果找到一個匹配，<code>find</code> 會返回 <code>s</code>
中關於它起始及終點位置的索引；
否則，返回 <b>nil</b>。
第三個可選數字參數 <code>init</code>
指明從哪裡開始搜索；
默認值為 1 ，同時可以是負值。
第四個可選參數 <code>plain</code> 為 <b>true</b> 時，
關閉模式匹配機制。
此時函式僅做直接的 「查找子串」的操作，
而 <code>pattern</code> 中沒有字符被看作魔法字符。
注意，如果給定了 <code>plain</code>　，就必須寫上 <code>init</code> 。


<p>
如果在模式中定義了捕獲，捕獲到的若干值也會在兩個索引之後返回。



<p>
<hr><h3><a name="pdf-string.format"><code>string.format (formatstring, &middot;&middot;&middot;)</code></a></h3>


<p>
返回不定數量參數的格式化版本，
格式化串為第一個參數（必須是一個字串）。
格式化字串遵循 ISO C 函式 <code>sprintf</code> 的規則。
不同點在於選項
<code>*</code>, <code>h</code>, <code>L</code>, <code>l</code>, <code>n</code>,
<code>p</code> 不支持，
另外還增加了一個選項 <code>q</code>。
<code>q</code> 選項將一個字串格式化為兩個雙引號括起，對內部字符做恰當的轉義處理的字串。
該字串可以安全的被 Lua 解釋器讀回來。
例如，調用

<pre>
     string.format('%q', 'a string with "quotes" and \n new line')
</pre><p>
會產生字串：

<pre>
     "a string with \"quotes\" and \
      new line"
</pre>

<p>
選項
<code>A</code> and <code>a</code> （如果有的話），
<code>E</code>, <code>e</code>, <code>f</code>,
<code>G</code>, and <code>g</code> 都期待一個對應的數字參數。
選項 <code>c</code>, <code>d</code>,
<code>i</code>, <code>o</code>, <code>u</code>, <code>X</code>, and <code>x</code>
則期待一個整數。
選項 <code>q</code> 期待一個字串；
選項 <code>s</code> 期待一個沒有內嵌零的字串。
如果選項 <code>s</code> 對應的參數不是字串，它會用和
<a href="#pdf-tostring"><code>tostring</code></a> 一致的規則轉換成字串。



<p>
<hr><h3><a name="pdf-string.gmatch"><code>string.gmatch (s, pattern)</code></a></h3>
返回一個迭代器函式。
每次調用這個函式都會繼續以 <code>pattern</code> （參見　<a href="#6.4.1">&sect;6.4.1</a>）
對 <code>s</code> 做匹配，並返回所有捕獲到的值。
如果 <code>pattern</code> 中沒有指定捕獲，則每次捕獲整個 <code>pattern</code>。


<p>
下面這個例子會循環迭代字串 <code>s</code> 中所有的單詞，
並逐行打印：

<pre>
     s = "hello world from Lua"
     for w in string.gmatch(s, "%a+") do
       print(w)
     end
</pre><p>
下一個例子從指定的字串中收集所有的鍵值對
<code>key=value</code>
置入一張表：

<pre>
     t = {}
     s = "from=world, to=Lua"
     for k, v in string.gmatch(s, "(%w+)=(%w+)") do
       t[k] = v
     end
</pre>

<p>
對這個函式來說，模板前開始的 '<code>^</code>' 不會當成錨點。因為這樣會阻止迭代。



<p>
<hr><h3><a name="pdf-string.gsub"><code>string.gsub (s, pattern, repl [, n])</code></a></h3>
將字串 <code>s</code> 中，所有的（或是在 <code>n</code> 給出時的前 <code>n</code> 個）
<code>pattern</code> （參見
 <a href="#6.4.1">&sect;6.4.1</a>）都替換成 <code>repl</code> ，並返回其副本。
<code>repl</code> 可以是字串、表、或函式。
<code>gsub</code> 還會在第二個返回值返回一共發生了多少次匹配。
<code>gsub</code> 這個名字來源於 <em>Global SUBstitution</em> 。


<p>
如果 <code>repl</code> 是一個字串，那麼把這個字串作為替換品。
字符 <code>%</code> 是一個轉義符：
<code>repl</code> 中的所有形式為 <code>%<em>d</em></code> 的串表示
第 <em>d</em> 個捕獲到的子串，<em>d</em> 可以是 1 到 9 。
串 <code>%0</code> 表示整個匹配。
串 <code>%%</code> 表示單個 <code>%</code>。


<p>
如果 <code>repl</code> 是張表，每次匹配時都會用第一個捕獲物作為鍵去查這張表。


<p>
如果 <code>repl</code> 是個函式，則在每次匹配發生時都會調用這個函式。
所有捕獲到的子串依次作為參數傳入。


<p>
任何情況下，模板中沒有設定捕獲都看成是捕獲整個模板。


<p>
如果表的查詢結果或函式的返回結果是一個字串或是個數字，
都將其作為替換用串；
而在返回 <b>false</b> 或 <b>nil</b>　時不作替換
（即保留匹配前的原始串）。


<p>
這裡有一些用例：

<pre>
     x = string.gsub("hello world", "(%w+)", "%1 %1")
     --&gt; x="hello hello world world"
     
     x = string.gsub("hello world", "%w+", "%0 %0", 1)
     --&gt; x="hello hello world"
     
     x = string.gsub("hello world from Lua", "(%w+)%s*(%w+)", "%2 %1")
     --&gt; x="world hello Lua from"
     
     x = string.gsub("home = $HOME, user = $USER", "%$(%w+)", os.getenv)
     --&gt; x="home = /home/roberto, user = roberto"
     
     x = string.gsub("4+5 = $return 4+5$", "%$(.-)%$", function (s)
           return load(s)()
         end)
     --&gt; x="4+5 = 9"
     
     local t = {name="lua", version="5.3"}
     x = string.gsub("$name-$version.tar.gz", "%$(%w+)", t)
     --&gt; x="lua-5.3.tar.gz"
</pre>



<p>
<hr><h3><a name="pdf-string.len"><code>string.len (s)</code></a></h3>
接收一個字串，返回其長度。
空串 <code>""</code> 的長度為 0 。
內嵌零也統計在內，因此
<code>"a\000bc\000"</code> 的長度為 5 。




<p>
<hr><h3><a name="pdf-string.lower"><code>string.lower (s)</code></a></h3>
接收一個字串，將其中的大寫字符都轉為小寫後返回其副本。
其它的字串不會更改。
對大寫字符的定義取決於當前的區域設置。



<p>
<hr><h3><a name="pdf-string.match"><code>string.match (s, pattern [, init])</code></a></h3>
在字串 <code>s</code> 中找到第一個能用 <code>pattern</code>
（參見 <a href="#6.4.1">&sect;6.4.1</a>）匹配到的部分。
如果能找到，<code>match</code> 返回其中的捕獲物；
否則返回 <b>nil</b> 。
如果 <code>pattern</code> 中未指定捕獲，
返回整個 <code>pattern</code> 捕獲到的串。
第三個可選數字參數 <code>init</code>
指明從哪裡開始搜索；
它默認為 1 且可以是負數。



<p>
<hr><h3><a name="pdf-string.pack"><code>string.pack (fmt, v1, v2, &middot;&middot;&middot;)</code></a></h3>


<p>
返回一個打包了（即以二進制形式序列化） <code>v1</code>, <code>v2</code> 等值的二進制字串。
字串 <code>fmt</code> 為打包格式（參見 <a href="#6.4.2">&sect;6.4.2</a>）。




<p>
<hr><h3><a name="pdf-string.packsize"><code>string.packsize (fmt)</code></a></h3>


<p>
返回以指定格式用 <a href="#pdf-string.pack"><code>string.pack</code></a>
打包的字串的長度。
格式化字串中不可以有變長選項 '<code>s</code>' 或 '<code>z</code>'
（參見 <a href="#6.4.2">&sect;6.4.2</a>）。




<p>
<hr><h3><a name="pdf-string.rep"><code>string.rep (s, n [, sep])</code></a></h3>
返回 <code>n</code> 個字串 <code>s</code> 以字串 <code>sep</code>
為分割符連在一起的字串。
默認的 <code>sep</code> 值為空字串（即沒有分割符）。
如果 <code>n</code> 不是正數則返回空串。



<p>
<hr><h3><a name="pdf-string.reverse"><code>string.reverse (s)</code></a></h3>
返回字串 <code>s</code> 的翻轉串。




<p>
<hr><h3><a name="pdf-string.sub"><code>string.sub (s, i [, j])</code></a></h3>
返回 <code>s</code> 的子串，
該子串從 <code>i</code> 開始到 <code>j</code> 為止；
<code>i</code> 和 <code>j</code> 都可以為負數。
如果不給出 <code>j</code> ，就當它是 -1 
（和字串長度相同）。
特別是，
調用 <code>string.sub(s,1,j)</code> 可以返回 <code>s</code>
的長度為 <code>j</code> 的前綴串，
而 <code>string.sub(s, -i)</code> 返回長度為 <code>i</code>
的後綴串。


<p>
如果在對負數索引轉義後 <code>i</code> 小於 1 的話，就修正回 1 。
如果 <code>j</code> 比字串的長度還大，就修正為字串長度。
如果在修正之後，<code>i</code> 大於 <code>j</code>，
函式返回空串。



<p>
<hr><h3><a name="pdf-string.unpack"><code>string.unpack (fmt, s [, pos])</code></a></h3>


<p>
返回以格式 <code>fmt</code> （參見 <a href="#6.4.2">&sect;6.4.2</a>）
打包在字串 <code>s</code> （參見 <a href="#pdf-string.pack"><code>string.pack</code></a>）
中的值。
選項 <code>pos</code>（默認為 1 ）標記了從 <code>s</code>
中哪裡開始讀起。
讀完所有的值後，函式返回 <code>s</code> 中第一個未讀字節的位置。



<p>
<hr><h3><a name="pdf-string.upper"><code>string.upper (s)</code></a></h3>
接收一個字串，將其中的小寫字符都轉為大寫後返回其副本。
其它的字串不會更改。
對小寫字符的定義取決於當前的區域設置。




<h3>6.4.1 &ndash; <a name="6.4.1">匹配模式</a></h3>

<p>
Lua 中的匹配模式直接用常規的字串來描述。
它用於模式匹配函式
<a href="#pdf-string.find"><code>string.find</code></a>,
<a href="#pdf-string.gmatch"><code>string.gmatch</code></a>,
<a href="#pdf-string.gsub"><code>string.gsub</code></a>,
<a href="#pdf-string.match"><code>string.match</code></a>。
這一節表述了這些字串的語法及含義（即它能匹配到什麼）。



<h4>字符類：</h4><p>
<em>字符類</em> 用於表示一個字符集合。
下列組合可用於字符類：

<ul>

<li><b><em>x</em>: </b>
（這裡 <em>x</em> 不能是 <em>魔法字符</em> <code>^$()%.[]*+-?</code> 中的一員）
表示字符 <em>x</em> 自身。
</li>

<li><b><code>.</code>: </b> （一個點）可表示任何字符。</li>

<li><b><code>%a</code>: </b> 表示任何字母。</li>

<li><b><code>%c</code>: </b> 表示任何控制字符。</li>

<li><b><code>%d</code>: </b> 表示任何數字。</li>

<li><b><code>%g</code>: </b> 表示任何除空白符外的可打印字符。</li>

<li><b><code>%l</code>: </b> 表示所有小寫字母。</li>

<li><b><code>%p</code>: </b> 表示所有標點符號。</li>

<li><b><code>%s</code>: </b> 表示所有空白字符。</li>

<li><b><code>%u</code>: </b> 表示所有大寫字母。</li>

<li><b><code>%w</code>: </b> 表示所有字母及數字。</li>

<li><b><code>%x</code>: </b> 表示所有 16 進制數字符號。</li>

<li><b><code>%<em>x</em></code>: </b> 
（這裡的 <em>x</em> 是任意非字母或數字的字符）
表示字符 <em>x</em>。
這是對魔法字符轉義的標準方法。
所有非字母或數字的字符
（包括所有標點，也包括非魔法字符）
都可以用前置一個 '<code>%</code>' 放在模式串中表示自身。
</li>

<li><b><code>[<em>set</em>]</code>: </b>
表示 <em>set</em>　中所有字符的聯合。
可以以 '<code>-</code>' 連接，升序書寫範圍兩端的字符來表示一個範圍的字符集。
上面提到的 <code>%</code><em>x</em> 形式也可以在 <em>set</em> 中使用
表示其中的一個元素。
其它出現在 <em>set</em> 中的字符則代表它們自己。
例如，<code>[%w_]</code> （或 <code>[_%w]</code>）
表示所有的字母數字加下劃線），
<code>[0-7]</code> 表示 8 進制數字，
<code>[0-7%l%-]</code>　表示 8 進制數字加小寫字母與 '<code>-</code>' 字符。


<p>
交叉使用類和範圍的行為未定義。
因此，像 <code>[%a-z]</code> 或 <code>[a-%%]</code>
這樣的模式串沒有意義。
</li>

<li><b><code>[^<em>set</em>]</code>: </b>
表示 <em>set</em> 的補集，
其中 <em>set</em> 如上面的解釋。
</li>

</ul><p>
所有單個字母表示的類別（<code>%a</code>，<code>%c</code>，等），
若將其字母改為大寫，均表示對應的補集。
例如，<code>%S</code> 表示所有非空格的字符。


<p>
如何定義字母、空格、或是其他字符組取決於當前的區域設置。
特別注意：<code>[a-z]</code>　未必等價於 <code>%l</code> 。




<h4>模式條目：</h4><p>
<em>模式條目</em> 可以是

<ul>

<li>
單個字符類匹配該類別中任意單個字符；
</li>

<li>
單個字符類跟一個 '<code>*</code>'，
將匹配零或多個該類的字符。
這個條目總是匹配盡可能長的串；
</li>

<li>
單個字符類跟一個 '<code>+</code>'，
將匹配一或更多個該類的字符。
這個條目總是匹配盡可能長的串；
</li>

<li>
單個字符類跟一個 '<code>-</code>'，
將匹配零或更多個該類的字符。
和 '<code>*</code>' 不同，
這個條目總是匹配盡可能短的串；
</li>

<li>
單個字符類跟一個 '<code>?</code>'，
將匹配零或一個該類的字符。
只要有可能，它會匹配一個；
</li>

<li>
<code>%<em>n</em></code>，
這裡的 <em>n</em> 可以從 1 到 9；
這個條目匹配一個等於 <em>n</em> 號捕獲物（後面有描述）的子串。
</li>

<li>
<code>%b<em>xy</em></code>，
這裡的 <em>x</em> 和 <em>y</em> 是兩個明確的字符；
這個條目匹配以 <em>x</em> 開始 <em>y</em> 結束，
且其中 <em>x</em> 和 <em>y</em> 保持 <em>平衡</em> 的字串。
意思是，如果從左到右讀這個字串，對每次讀到一個
<em>x</em> 就 <em>+1</em> ，讀到一個 <em>y</em> 就 <em>-1</em>，
最終結束處的那個 <em>y</em> 是第一個記數到 0 的 <em>y</em>。
舉個例子，條目 <code>%b()</code> 可以匹配到括號平衡的表達式。
</li>

<li>
<code>%f[<em>set</em>]</code>，
指 <em>邊境模式</em>；
這個條目會匹配到一個位於 <em>set</em> 內某個字符之前的一個空串，
且這個位置的前一個字符不屬於 <em>set</em> 。
集合 <em>set</em> 的含義如前面所述。
匹配出的那個空串之開始和結束點的計算就看成該處有個字符
'<code>\0</code>' 一樣。
</li>

</ul>




<h4>模式：</h4><p>
<em>模式</em> 指一個模式條目的序列。
在模式最前面加上符號 '<code>^</code>' 將錨定從字串的開始處做匹配。
在模式最後面加上符號 '<code>$</code>' 將使匹配過程錨定到字串的結尾。
如果 '<code>^</code>' 和 '<code>$</code>' 出現在其它位置，它們均沒有特殊含義，只表示自身。





<h4>捕獲：</h4><p>
模式可以在內部用小括號括起一個子模式；
這些子模式被稱為 <em>捕獲物</em>。
當匹配成功時，由 <em>捕獲物</em> 匹配到的字串中的子串被保存起來用於未來的用途。
捕獲物以它們左括號的次序來編號。
例如，對於模式 <code>"(a*(.)%w(%s*))"</code> ，
字串中匹配到 <code>"a*(.)%w(%s*)"</code> 的部分保存在第一個捕獲物中
（因此是編號 1 ）；
由 "<code>.</code>" 匹配到的字符是 2 號捕獲物，
匹配到 "<code>%s*</code>" 的那部分是 3 號。


<p>
作為一個特例，空的捕獲 <code>()</code> 將捕獲到當前字串的位置（它是一個數字）。
例如，如果將模式 <code>"()aa()"</code> 作用到字串
<code>"flaaap"</code> 上，將產生兩個捕獲物：
3 和 5 。






<h3>6.4.2 &ndash; <a name="6.4.2">打包和解包用到的格式串</a></h3>

<p>
用於 <a href="#pdf-string.pack"><code>string.pack</code></a>，
<a href="#pdf-string.packsize"><code>string.packsize</code></a>，
<a href="#pdf-string.unpack"><code>string.unpack</code></a>
的第一個參數。
它是一個描述了需要創建或讀取的結構之佈局。


<p>
格式串是由轉換選項構成的序列。
這些轉換選項列在後面：

<ul>
<li><b><code>&lt;</code>: </b>設為小端編碼</li>
<li><b><code>&gt;</code>: </b>設為大端編碼</li>
<li><b><code>=</code>: </b>大小端遵循本地設置</li>
<li><b><code>![<em>n</em>]</code>: </b>將最大對齊數設為 <code>n</code>
（默認遵循本地對齊設置）</li>
<li><b><code>b</code>: </b>一個有符號字節 (<code>char</code>)</li>
<li><b><code>B</code>: </b>一個無符號字節 (<code>char</code>)</li>
<li><b><code>h</code>: </b>一個有符號 <code>short</code> （本地大小）</li>
<li><b><code>H</code>: </b>一個無符號 <code>short</code> （本地大小）</li>
<li><b><code>l</code>: </b>一個有符號 <code>long</code> （本地大小）</li>
<li><b><code>L</code>: </b>一個無符號 <code>long</code> （本地大小）</li>
<li><b><code>j</code>: </b>一個 <code>lua_Integer</code></li>
<li><b><code>J</code>: </b>一個 <code>lua_Unsigned</code></li>
<li><b><code>T</code>: </b>一個 <code>size_t</code> （本地大小）</li>
<li><b><code>i[<em>n</em>]</code>: </b>一個 <code>n</code> 字節長（默認為本地大小）的有符號 <code>int</code></li>
<li><b><code>I[<em>n</em>]</code>: </b>一個 <code>n</code> 字節長（默認為本地大小）的無符號 <code>int</code></li>
<li><b><code>f</code>: </b>一個 <code>float</code> （本地大小）</li>
<li><b><code>d</code>: </b>一個 <code>double</code> （本地大小）</li>
<li><b><code>n</code>: </b>一個 <code>lua_Number</code></li>
<li><b><code>c<em>n</em></code>: </b><code>n</code>字節固定長度的字串</li>
<li><b><code>z</code>: </b>零結尾的字串</li>
<li><b><code>s[<em>n</em>]</code>: </b>長度加內容的字串，其長度編碼為一個 <code>n</code> 字節（默認是個 <code>size_t</code>） 長的無符號整數。</li>
<li><b><code>x</code>: </b>一個字節的填充</li>
<li><b><code>X<em>op</em></code>: </b>按選項 <code>op</code> 的方式對齊（忽略它的其它方面）的一個空條目</li>
<li><b>'<code> </code>': </b>（空格）忽略</li>
</ul><p>
（ "<code>[<em>n</em>]</code>" 表示一個可選的整數。）
除填充、空格、配置項（選項 "<code>xX &lt;=&gt;!</code>"）外，
每個選項都關聯一個參數（對於 <a href="#pdf-string.pack"><code>string.pack</code></a>）
或結果（對於 <a href="#pdf-string.unpack"><code>string.unpack</code></a>）。


<p>
對於選項 "<code>!<em>n</em></code>", "<code>s<em>n</em></code>", "<code>i<em>n</em></code>", "<code>I<em>n</em></code>",
<code>n</code> 可以是 1 到 16 間的整數。
所有的整數選項都將做溢出檢查；
<a href="#pdf-string.pack"><code>string.pack</code></a> 檢查提供的值是否能用指定的字長表示；
<a href="#pdf-string.unpack"><code>string.unpack</code></a> 檢查讀出的值能否置入 Lua 整數中。


<p>
任何格式串都假設有一個 "<code>!1=</code>" 前綴，
即最大對齊為 1 （無對齊）且採用本地大小端設置。


<p>
對齊行為按如下規則工作：
對每個選項，格式化時都會填充一些字節直到數據從一個特定偏移處開始，
這個位置是該選項的大小和最大對齊數中較小的那個數的倍數；
這個較小值必須是 2 個整數次方。
選項 "<code>c</code>" 及 "<code>z</code>" 不做對齊處理；
選項 "<code>s</code>" 對對齊遵循其開頭的整數。


<p>
<a href="#pdf-string.pack"><code>string.pack</code></a> 用零去填充
（<a href="#pdf-string.unpack"><code>string.unpack</code></a> 則忽略它）。






<h2>6.5 &ndash; <a name="6.5">UTF-8 支持</a></h2>

<p>
這個庫提供了對 UTF-8 編碼的基礎支持。
所有的函式都放在表 <a name="pdf-utf8"><code>utf8</code></a> 中。
此庫不提供除編碼處理之外的任何 Unicode 支持。
所有需要瞭解字符含義的操作，比如字符分類，都不在此範疇。


<p>
除非另有說明，
當一個函式需要一個字節位置的參數時，
都假定這個位置要麼從字節序列的開始計算，
要麼從字串長度加一的位置算。
和字串庫一樣，負的索引從字串末尾計起。


<p>
<hr><h3><a name="pdf-utf8.char"><code>utf8.char (&middot;&middot;&middot;)</code></a></h3>
接收零或多個整數，
將每個整數轉換成對應的 UTF-8 字節序列，並返回這些序列連接到一起的字串。



<p>
<hr><h3><a name="pdf-utf8.charpattern"><code>utf8.charpattern</code></a></h3>
用於精確匹配到一個 UTF-8 字節序列的模式（是一個字串，並非函式）"<code>[\0-\x7F\xC2-\xF4][\x80-\xBF]*</code>"
（參見 <a href="#6.4.1">&sect;6.4.1</a>）。
它假定處理的對象是一個合法的 UTF-8 字串。



<p>
<hr><h3><a name="pdf-utf8.codes"><code>utf8.codes (s)</code></a></h3>


<p>
返回一系列的值，可以讓

<pre>
     for p, c in utf8.codes(s) do <em>body</em> end
</pre><p>
迭代出字串 <code>s</code> 中所有的字符。
這裡的 <code>p</code> 是位置（按字節數）而 <code>c</code> 是每個字符的編號。
如果處理到一個不合法的字節序列，將拋出一個錯誤。



<p>
<hr><h3><a name="pdf-utf8.codepoint"><code>utf8.codepoint (s [, i [, j]])</code></a></h3>
一整數形式返回 <code>s</code> 中
從位置 <code>i</code> 到 <code>j</code> 間（包括兩端）
所有字符的編號。
默認的 <code>i</code> 為 1 ，默認的 <code>j</code> 為 <code>i</code>。
如果碰上不合法的字節序列，拋出一個錯誤。



<p>
<hr><h3><a name="pdf-utf8.len"><code>utf8.len (s [, i [, j]])</code></a></h3>
返回字串 <code>s</code> 中
從位置 <code>i</code> 到 <code>j</code> 間 （包括兩端）
UTF-8 字符的個數。
默認的 <code>i</code> 為 1 ，默認的 <code>j</code> 為 -1 。
如果它找到任何不合法的字節序列，
返回假值加上第一個不合法字節的位置。



<p>
<hr><h3><a name="pdf-utf8.offset"><code>utf8.offset (s, n [, i])</code></a></h3>
返回編碼在 <code>s</code> 中的第 <code>n</code> 個字符的開始位置（按字節數）
（從位置 <code>i</code> 處開始統計）。
負 <code>n</code> 則取在位置 <code>i</code> 前的字符。
當 <code>n</code> 是非負數時，默認的 <code>i</code> 是 1，
否則默認為 <code>#s + 1</code>。
因此，<code>utf8.offset(s, -n)</code> 取字串的倒數第
<code>n</code> 個字符的位置。
如果指定的字符不在其中或在結束點之後，函式返回 <b>nil</b>。


<p>
作為特例，當 <code>n</code> 等於 0 時，
此函式返回含有 <code>s</code> 第 <code>i</code> 字節的那個字符的開始位置。


<p>
這個函式假定 <code>s</code> 是一個合法的 UTF-8 字串。






<h2>6.6 &ndash; <a name="6.6">表處理</a></h2>

<p>
這個庫提供了表處理的通用函式。
所有函式都放在表 <a name="pdf-table"><code>table</code></a> 中。


<p>
記住，無論何時，若一個操作需要取表的長度，
這張表必須是一個真序列，或是擁有 <code>__len</code> 元方法
（參見 <a href="#3.4.7">&sect;3.4.7</a> ）。
所有的函式都忽略傳入參數的那張表中的非數字鍵。


<p>
<hr><h3><a name="pdf-table.concat"><code>table.concat (list [, sep [, i [, j]]])</code></a></h3>


<p>
提供一個列表，其所有元素都是字串或數字，返回字串
<code>list[i]..sep..list[i+1] &middot;&middot;&middot; sep..list[j]</code>。
<code>sep</code> 的默認值是空串，
<code>i</code> 的默認值是 1 ，
<code>j</code> 的默認值是 <code>#list</code> 。
如果 <code>i</code> 比 <code>j</code> 大，返回空串。




<p>
<hr><h3><a name="pdf-table.insert"><code>table.insert (list, [pos,] value)</code></a></h3>


<p>
在 <code>list</code> 的位置 <code>pos</code> 處插入元素 <code>value</code> ，
並後移元素 <code>list[pos], list[pos+1], &middot;&middot;&middot;, list[#list]</code> 。
<code>pos</code> 的默認值為 <code>#list+1</code> ，
因此調用 <code>table.insert(t,x)</code> 會將 <code>x</code> 插在列表 <code>t</code> 的末尾。



<p>
<hr><h3><a name="pdf-table.move"><code>table.move (a1, f, e, t [,a2])</code></a></h3>


<p>
將元素從表 <code>a1</code> 移到表 <code>a2</code>。
這個函式做了次等價於後面這個多重賦值的等價操作：
<code>a2[t],&middot;&middot;&middot; = a1[f],&middot;&middot;&middot;,a1[e]</code>。
<code>a2</code> 的默認值為 <code>a1</code>。
目標區間可以和源區間重疊。
索引 <code>f</code> 必須是正數。




<p>
<hr><h3><a name="pdf-table.pack"><code>table.pack (&middot;&middot;&middot;)</code></a></h3>


<p>
返回用所有參數以鍵 1,2, 等填充的新表，
並將 "<code>n</code>" 這個域設為參數的總數。
注意這張返回的表不一定是一個序列。



<p>
<hr><h3><a name="pdf-table.remove"><code>table.remove (list [, pos])</code></a></h3>


<p>
移除 <code>list</code> 中 <code>pos</code> 位置上的元素，並返回這個被移除的值。
當 <code>pos</code> 是在 1 到 <code>#list</code> 之間的整數時，
它向前移動元素　<code>list[pos+1], list[pos+2], &middot;&middot;&middot;, list[#list]</code>
並刪除元素 <code>list[#list]</code>；
索引 <code>pos</code> 可以是 <code>#list + 1</code> ，或在 <code>#list</code> 為 0 時可以是 0 ；
在這些情況下，函式刪除元素 <code>list[pos]</code>。


<p>
<code>pos</code> 默認為 <code>#list</code>，
因此調用 <code>table.remove(l)</code> 將移除表 <code>l</code> 的最後一個元素。



<p>
<hr><h3><a name="pdf-table.sort"><code>table.sort (list [, comp])</code></a></h3>


<p>
在表內從 <code>list[1]</code> 到 <code>list[#list]</code> <em>原地</em> 
對其間元素按指定次序排序。
如果提供了 <code>comp</code> ，
它必須是一個可以接收兩個列表內元素為參數的函式。
當第一個元素需要排在第二個元素之前時，返回真
（因此 <code>not comp(list[i+1],list[i])</code> 在排序結束後將為真）。
如果沒有提供 <code>comp</code>，
將使用標準 Lua 操作 <code>&lt;</code> 作為替代品。


<p>
排序算法並不穩定；
即當兩個元素次序相等時，它們在排序後的相對位置可能會改變。




<p>
<hr><h3><a name="pdf-table.unpack"><code>table.unpack (list [, i [, j]])</code></a></h3>


<p>
返回列表中的元素。
這個函式等價於

<pre>
     return list[i], list[i+1], &middot;&middot;&middot;, list[j]
</pre><p>
<code>i</code> 默認為 1 ，<code>j</code> 默認為 <code>#list</code>。






<h2>6.7 &ndash; <a name="6.7">數學函式</a></h2>

<p>
這個庫提供了基本的數學函式。
所以函式都放在表 <a name="pdf-math"><code>math</code></a> 中。
註解有 "<code>integer/float</code>" 的函式會對整數參數返回整數結果，
對浮點（或混合）參數返回浮點結果。
圓整函式（<a href="#pdf-math.ceil"><code>math.ceil</code></a>, <a href="#pdf-math.floor"><code>math.floor</code></a>, <a href="#pdf-math.modf"><code>math.modf</code></a>）
在結果在整數範圍內時返回整數，否則返回浮點數。

<p>
<hr><h3><a name="pdf-math.abs"><code>math.abs (x)</code></a></h3>


<p>
返回 <code>x</code> 的絕對值。(integer/float)




<p>
<hr><h3><a name="pdf-math.acos"><code>math.acos (x)</code></a></h3>


<p>
返回 <code>x</code> 的反餘弦值（用弧度表示）。




<p>
<hr><h3><a name="pdf-math.asin"><code>math.asin (x)</code></a></h3>


<p>
返回 <code>x</code> 的反正弦值（用弧度表示）。



<p>
<hr><h3><a name="pdf-math.atan"><code>math.atan (y [, x])</code></a></h3>


<p>
返回 <code>y/x</code> 的反正切值（用弧度表示）。
它會使用兩個參數的符號來找到結果落在哪個象限中。
（即使 <code>x</code> 為零時，也可以正確的處理。）

<p>
默認的 <code>x</code> 是 1 ，
因此調用 <code>math.atan(y)</code> 將返回
<code>y</code> 的反正切值。




<p>
<hr><h3><a name="pdf-math.ceil"><code>math.ceil (x)</code></a></h3>


<p>
返回不小於 <code>x</code> 的最小整數值。



<p>
<hr><h3><a name="pdf-math.cos"><code>math.cos (x)</code></a></h3>


<p>
返回 <code>x</code> 的餘弦（假定參數是弧度）。



<p>
<hr><h3><a name="pdf-math.deg"><code>math.deg (x)</code></a></h3>


<p>
將角 <code>x</code> 從弧度轉換為角度。


<p>
<hr><h3><a name="pdf-math.exp"><code>math.exp (x)</code></a></h3>


<p>
返回 <em>e<sup>x</sup></em> 的值
（<code>e</code> 為自然對數的底）。



<p>
<hr><h3><a name="pdf-math.floor"><code>math.floor (x)</code></a></h3>


<p>
返回不大於 <code>x</code> 的最大整數值。



<p>
<hr><h3><a name="pdf-math.fmod"><code>math.fmod (x, y)</code></a></h3>


<p>
返回 <code>x</code> 除以 <code>y</code>，將商向零圓整後的餘數。
(integer/float)




<p>
<hr><h3><a name="pdf-math.huge"><code>math.huge</code></a></h3>


<p>
浮點數 <code>HUGE_VAL</code>，
這個數比任何數字值都大。


<p>
<hr><h3><a name="pdf-math.log"><code>math.log (x [, base])</code></a></h3>


<p>
返回以指定底的 <code>x</code> 的對數。
默認的 <code>base</code> 是 <em>e</em>
（因此此函式返回 <code>x</code> 的自然對數）。


<p>
<hr><h3><a name="pdf-math.max"><code>math.max (x, &middot;&middot;&middot;)</code></a></h3>


<p>
返回參數中最大的值，
大小由 Lua 操作 <code>&lt;</code> 決定。
(integer/float)




<p>
<hr><h3><a name="pdf-math.maxinteger"><code>math.maxinteger</code></a></h3>
最大值的整數。




<p>
<hr><h3><a name="pdf-math.min"><code>math.min (x, &middot;&middot;&middot;)</code></a></h3>


<p>
返回參數中最小的值，
大小由 Lua 操作 <code>&lt;</code> 決定。
(integer/float)



<p>
<hr><h3><a name="pdf-math.mininteger"><code>math.mininteger</code></a></h3>
最小值的整數。



<p>
<hr><h3><a name="pdf-math.modf"><code>math.modf (x)</code></a></h3>


<p>
返回 <code>x</code> 的整數部分和小數部分。
第二個結果一定是浮點數。



<p>
<hr><h3><a name="pdf-math.pi"><code>math.pi</code></a></h3>


<p>
<em>&pi;</em> 的值。




<p>
<hr><h3><a name="pdf-math.rad"><code>math.rad (x)</code></a></h3>


<p>
將角 <code>x</code> 從角度轉換為弧度。



<p>
<hr><h3><a name="pdf-math.random"><code>math.random ([m [, n]])</code></a></h3>


<p>
當不帶參數調用時，
返回一個 <em>[0,1)</em> 區間內一致分佈的浮點偽隨機數。
當以兩個整數 <code>m</code> 與 <code>n</code> 調用時，
<code>math.random</code> 返回一個 <em>[m, n]</em> 區間
內一致分佈的整數偽隨機數。
（值 <em>m-n</em> 不能是負數，且必須在 Lua 整數的表示範圍內。）
調用 <code>math.random(n)</code> 等價於 <code>math.random(1,n)</code>。


<p>
這個函式是對 C 提供的位隨機數函式的封裝。
對其統計屬性不作擔保。



<p>
<hr><h3><a name="pdf-math.randomseed"><code>math.randomseed (x)</code></a></h3>


<p>
把 <code>x</code> 設為偽隨機數發生器的「種子」：
相同的種子產生相同的隨機數列。



<p>
<hr><h3><a name="pdf-math.sin"><code>math.sin (x)</code></a></h3>


<p>
返回 <code>x</code> 的正弦值（假定參數是弧度）。



<p>
<hr><h3><a name="pdf-math.sqrt"><code>math.sqrt (x)</code></a></h3>


<p>
返回 <code>x</code> 的平方根。
（你也可以使用乘方 <code>x^0.5</code> 來計算這個值。）



<p>
<hr><h3><a name="pdf-math.tan"><code>math.tan (x)</code></a></h3>


<p>
返回 <code>x</code> 的正切值（假定參數是弧度）。




<p>
<hr><h3><a name="pdf-math.tointeger"><code>math.tointeger (x)</code></a></h3>


<p>
如果 <code>x</code> 可以轉換為一個整數，
返回該整數。
否則返回 <b>nil</b>。




<p>
<hr><h3><a name="pdf-math.type"><code>math.type (x)</code></a></h3>


<p>
如果 <code>x</code> 是整數，返回 "<code>integer</code>"，
如果它是浮點數，返回 "<code>float</code>"，
如果 <code>x</code> 不是數字，返回 <b>nil</b>。



<p>
<hr><h3><a name="pdf-math.ult"><code>math.ult (m, n)</code></a></h3>


<p>
如果整數 <code>m</code> 和 <code>n</code> 以無符號整數形式比較，
<code>m</code> 在 <code>n</code> 之下，返回布爾真否則返回假。





<h2>6.8 &ndash; <a name="6.8">輸入輸出設施</a></h2>

<p>
I/O 庫提供了兩套不同風格的文件處理接口。
第一種風格使用隱式的文件句柄；
它提供設置默認輸入文件及默認輸出文件的操作，
所有的輸入輸出操作都針對這些默認文件。
第二種風格使用顯式的文件句柄。


<p>
當使用隱式文件句柄時，
所有的操作都由表 <a name="pdf-io"><code>io</code></a> 提供。
若使用顯式文件句柄，
<a href="#pdf-io.open"><code>io.open</code></a> 
會返回一個文件句柄，且所有的操作都由該文件句柄的方法來提供。


<p>
表 <code>io</code> 中也提供了三個
和 C 中含義相同的預定義文件句柄：
<a name="pdf-io.stdin"><code>io.stdin</code></a>， <a name="pdf-io.stdout"><code>io.stdout</code></a>， 以及 <a name="pdf-io.stderr"><code>io.stderr</code></a>。
I/O 庫永遠不會關閉這些文件。


<p>
除非另有說明，
I/O 函式在出錯時都返回 <b>nil</b>
（第二個返回值為錯誤消息，第三個返回值為系統相關的錯誤碼）。
成功時返回與 <b>nil</b> 不同的值。
在非 POSIX 系統上，
根據錯誤碼取出錯誤消息的過程可能並非線程安全的，
因為這使用了 C 的全局變量 <code>errno</code> 。

<p>
<hr><h3><a name="pdf-io.close"><code>io.close ([file])</code></a></h3>


<p>
等價於 <code>file:close()</code>。
不給出 <code>file</code> 時將關閉默認輸出文件。




<p>
<hr><h3><a name="pdf-io.flush"><code>io.flush ()</code></a></h3>


<p>
等價於 <code>io.output():flush()</code>。




<p>
<hr><h3><a name="pdf-io.input"><code>io.input ([file])</code></a></h3>


<p>
用文件名調用它時，（以文本模式）來打開該名字的文件，
並將文件句柄設為默認輸入文件。
如果用文件句柄去調用它，
就簡單的將該句柄設為默認輸入文件。
如果調用時不傳參數，它返回當前的默認輸入文件。


<p>
在出錯的情況下，函式拋出錯誤而不是返回錯誤碼。



<p>
<hr><h3><a name="pdf-io.lines"><code>io.lines ([filename &middot;&middot;&middot;])</code></a></h3>


<p>
以讀模式打開指定的文件名並返回一個迭代函式。
此迭代函式的工作方式和用一個已打開的文件去調用
<code>file:lines(&middot;&middot;&middot;)</code> 得到的迭代器相同。
當迭代函式檢測到文件結束，
它不返回值（讓循環結束）並自動關閉文件。


<p>
調用 <code>io.lines()</code> （不傳文件名）
等價於 <code>io.input():lines("*l")</code>；
即，它將按行迭代標準輸入文件。
在此情況下，循環結束後它不會關閉文件。


<p>
在出錯的情況下，函式拋出錯誤而不是返回錯誤碼。



<p>
<hr><h3><a name="pdf-io.open"><code>io.open (filename [, mode])</code></a></h3>


<p>
這個函式用字串 <code>mode</code> 指定的模式打開一個文件。
返回新的文件句柄。
當出錯時，返回 <b>nil</b> 加錯誤消息。


<p>
<code>mode</code> 字串可以是下列任意值：

<ul>
<li><b>"<code>r</code>": </b> 讀模式（默認）；</li>
<li><b>"<code>w</code>": </b> 寫模式；</li>
<li><b>"<code>a</code>": </b> 追加模式；</li>
<li><b>"<code>r+</code>": </b> 更新模式，所有之前的數據都保留；</li>
<li><b>"<code>w+</code>": </b> 更新模式，所有之前的數據都刪除；</li>
<li><b>"<code>a+</code>": </b> 追加更新模式，所有之前的數據都保留，只允許在文件尾部做寫入。</li>
</ul><p>
<code>mode</code> 字串可以在最後加一個 '<code>b</code>' ，
這會在某些系統上以二進制方式打開文件。



<p>
<hr><h3><a name="pdf-io.output"><code>io.output ([file])</code></a></h3>


<p>
類似於 <a href="#pdf-io.input"><code>io.input</code></a>。
不過都針對默認輸出文件操作。




<p>
<hr><h3><a name="pdf-io.popen"><code>io.popen (prog [, mode])</code></a></h3>


<p>
這個函式和系統有關，不是所有的平台都提供。

<p>
用一個分離進程開啟程序 <code>prog</code>，
返回的文件句柄可用於從這個程序中讀取數據
（如果 <code>mode</code> 為 <code>"r"</code>，這是默認值）
或是向這個程序寫入輸入（當
<code>mode</code> 為 <code>"w"</code> 時）。




<p>
<hr><h3><a name="pdf-io.read"><code>io.read (&middot;&middot;&middot;)</code></a></h3>


<p>
等價於 <code>io.input():read(&middot;&middot;&middot;)</code>。



<p>
<hr><h3><a name="pdf-io.tmpfile"><code>io.tmpfile ()</code></a></h3>


<p>
返回一個臨時文件的句柄。
這個文件以更新模式打開，在程序結束時會自動刪除。



<p>
<hr><h3><a name="pdf-io.type"><code>io.type (obj)</code></a></h3>


<p>
檢查 <code>obj</code> 是否是合法的文件句柄。
如果 <code>obj</code> 它是一個打開的文件句柄，返回字串 <code>"file"</code>。
如果 <code>obj</code> 是一個關閉的文件句柄，返回字串 <code>"closed file"</code>。
如果 <code>obj</code> 不是文件句柄，返回 <b>nil</b> 。



<p>
<hr><h3><a name="pdf-io.write"><code>io.write (&middot;&middot;&middot;)</code></a></h3>


<p>
等價於 <code>io.output():write(&middot;&middot;&middot;)</code>。



<p>
<hr><h3><a name="pdf-file:close"><code>file:close ()</code></a></h3>


<p>
關閉 <code>file</code>。
注意，文件在句柄被垃圾回收時會自動關閉，
但是多久以後發生，時間不可預期的。

<p>
當關閉用 <a href="#pdf-io.popen"><code>io.popen</code></a> 創建出來的文件句柄時，
<a href="#pdf-file:close"><code>file:close</code></a>
返回 <a href="#pdf-os.execute"><code>os.execute</code></a>
會返回的一樣的值。



<p>
<hr><h3><a name="pdf-file:flush"><code>file:flush ()</code></a></h3>


<p>
將寫入的數據保存到 <code>file</code> 中。




<p>
<hr><h3><a name="pdf-file:lines"><code>file:lines (&middot;&middot;&middot;)</code></a></h3>


<p>
返回一個迭代器函式，
每次調用迭代器時，都從文件中按指定格式讀數據。
如果沒有指定格式，使用默認值 "<code>l</code>" 。
看一個例子

<pre>
     for c in file:lines(1) do <em>body</em> end
</pre><p>
會從文件當前位置開始，中不斷讀出字符。
和 <a href="#pdf-io.lines"><code>io.lines</code></a> 不同，
這個函式在循環結束後不會關閉文件。


<p>
在出錯的情況下，函式拋出錯誤而不是返回錯誤碼。



<p>
<hr><h3><a name="pdf-file:read"><code>file:read (&middot;&middot;&middot;)</code></a></h3>


<p>
讀文件 <code>file</code>，
指定的格式決定了要讀什麼。
對於每種格式，函式返回讀出的字符對應的字串或數字。
若不能以該格式對應讀出數據則返回 <b>nil</b>。
（對於最後這種情況，
函式不會讀出後續的格式。）
當調用時不傳格式，它會使用默認格式讀下一行（見下面描述）。


<p>
提供的格式有

<ul>

<li><b>"<code>n</code>": </b>
讀取一個數字，根據 Lua 的轉換文法，可能返回浮點數或整數。
（數字可以有前置或後置的空格，以及符號。）
只要能構成合法的數字，這個格式總是去讀盡量長的串；
如果讀出來的前綴無法構成合法的數字
（比如空串，"<code>0x</code>" 或 "<code>3.4e-</code>"），
就中止函式運行，返回 <b>nil</b>。
</li>

<li><b>"<code>i</code>": </b>
讀取一個整數，返回整數值。
</li>

<li><b>"<code>a</code>": </b>
從當前位置開始讀取整個文件。
如果已在文件末尾，返回空串。
</li>

<li><b>"<code>l</code>": </b>
讀取一行並忽略行結束標記。
當在文件末尾時，返回 <b>nil</b>
這是默認格式。
</li>

<li><b>"<code>L</code>": </b>
讀取一行並保留行結束標記（如果有的話），
當在文件末尾時，返回 <b>nil</b>。
</li>

<li><b><em>number</em>: </b>
讀取一個不超過這個數量字節數的字串。
當在文件末尾時，返回 <b>nil</b>。
如果 <code>number</code> 為零，
它什麼也不讀，返回一個空串。
當在文件末尾時，返回 <b>nil</b>。
</li>

</ul><p>
格式 "<code>l</code>" 和 "<code>L</code>" 只能用於文本文件。



<p>
<hr><h3><a name="pdf-file:seek"><code>file:seek ([whence [, offset]])</code></a></h3>


<p>
設置及獲取基於文件開頭處計算出的位置。
設置的位置由 <code>offset</code> 和
<code>whence</code> 字串 <code>whence</code>
指定的基點決定。基點可以是：

<ul>
<li><b>"<code>set</code>": </b> 基點為 0 （文件開頭）；</li>
<li><b>"<code>cur</code>": </b> 基點為當前位置了；</li>
<li><b>"<code>end</code>": </b> 基點為文件尾；</li>
</ul><p>
當 <code>seek</code> 成功時，返回最終從文件開頭計算起的文件的位置。
當 <code>seek</code> 失敗時，返回 <b>nil</b> 加上一個錯誤描述字串。


<p>
<code>whence</code> 的默認值是 <code>"cur"</code>，
<code>offset</code> 默認為 0 。
因此，調用 <code>file:seek()</code> 可以返回文件當前位置，並不改變它；
調用 <code>file:seek("set")</code> 將位置設為文件開頭（並返回 0）；
調用 <code>file:seek("end")</code> 將位置設到文件末尾，並返回文件大小。



<p>
<hr><h3><a name="pdf-file:setvbuf"><code>file:setvbuf (mode [, size])</code></a></h3>


<p>
設置輸出文件的緩衝模式。
有三種模式：

<ul>

<li><b>"<code>no</code>": </b>
不緩衝；輸出操作立刻生效。
</li>

<li><b>"<code>full</code>": </b>
完全緩衝；只有在緩存滿或當你顯式的對文件調用
<code>flush</code>（參見 <a href="#pdf-io.flush"><code>io.flush</code></a>）
時才真正做輸出操作。
</li>

<li><b>"<code>line</code>": </b>
行緩衝；
輸出將到每次換行前，
對於某些特殊文件（例如終端設備）緩衝到任何輸入前。
</li>

</ul><p>
對於後兩種情況，<code>size</code> 以字節數為單位
指定緩衝區大小。
默認會有一個恰當的大小。




<p>
<hr><h3><a name="pdf-file:write"><code>file:write (&middot;&middot;&middot;)</code></a></h3>


<p>
將參數的值逐個寫入 <code>file</code>。
參數必須是字串或數字。


<p>
成功時，函式返回 <code>file</code>。
否則返回 <b>nil</b> 加錯誤描述字串。







<h2>6.9 &ndash; <a name="6.9">操作系統設施</a></h2>

<p>
這個庫都通過表 <a name="pdf-os"><code>os</code></a> 實現。


<p>
<hr><h3><a name="pdf-os.clock"><code>os.clock ()</code></a></h3>


<p>
返回程序使用的按秒計 CPU 時間的近似值。



<p>
<hr><h3><a name="pdf-os.date"><code>os.date ([format [, time]])</code></a></h3>


<p>
返回一個包含日期及時刻的字串或表。
格式化方法取決於所給字串 <code>format</code>。


<p>
如果提供了 <code>time</code> 參數，
格式化這個時間
（這個值的含義參見 <a href="#pdf-os.time"><code>os.time</code></a> 函式）。
否則，<code>date</code> 格式化當前時間。


<p>
如果 <code>format</code> 以 '<code>!</code>' 打頭，
日期以協調世界時格式化。
在這個可選字符項之後，
如果 <code>format</code> 為字串 "<code>*t</code>"，
<code>date</code> 返回有後續域的表：
<code>year</code> （四位數字），<code>month</code> （1&ndash;12），<code>day</code> （1&ndash;31），
<code>hour</code> （0&ndash;23），<code>min</code> （0&ndash;59），<code>sec</code> （0&ndash;61），
<code>wday</code> （星期幾，星期天為 1 ），
<code>yday</code> （當年的第幾天），
以及 <code>isdst</code> （夏令時標記，一個布爾量）。
對於最後一個域，如果該信息不提供的話就不存在。


<p>
如果 <code>format</code> 並非 "<code>*t</code>"，
<code>date</code> 以字串形式返回，
格式化方法遵循 ISO C 函式 <code>strftime</code> 的規則。


<p>
如果不傳參數調用，
<code>date</code> 返回一個合理的日期時間串，
格式取決於宿主程序以及當前的區域設置
（即，<code>os.date()</code> 等價於 <code>os.date("%c")</code>）。


<p>
在非 POSIX 系統上，
由於這個函式依賴 C 函式 <code>gmtime</code> 和 <code>localtime</code>，
它可能並非線程安全的。



<p>
<hr><h3><a name="pdf-os.difftime"><code>os.difftime (t2, t1)</code></a></h3>


<p>
返回以秒計算的時刻 <code>t1</code> 到 <code>t2</code> 的差值。
（這裡的時刻是由 <a href="#pdf-os.time"><code>os.time</code></a> 返回的值）。
在 POSIX，Windows，和其它一些系統中，這個值就等於
<code>t2</code><em>-</em><code>t1</code>。



<p>
<hr><h3><a name="pdf-os.execute"><code>os.execute ([command])</code></a></h3>


<p>
這個函式等價於 ISO C 函式 <code>system</code>。
它調用系統解釋器執行 <code>command</code>。
如果命令成功運行完畢，第一個返回值就是 <b>true</b>，
否則是 <b>nil</b> otherwise。
在第一個返回值之後，函式返回一個字串加一個數字。如下：
<ul>

<li><b>"<code>exit</code>": </b>
命令正常結束；
接下來的數字是命令的退出狀態碼。
</li>

<li><b>"<code>signal</code>": </b>
命令被信號打斷；
接下來的數字是打斷該命令的信號。
</li>

</ul>

<p>
如果不帶參數調用，
<code>os.execute</code> 在系統解釋器存在的時候返回真。



<p>
<hr><h3><a name="pdf-os.exit"><code>os.exit ([code [, close]])</code></a></h3>


<p>
調用 ISO C 函式 <code>exit</code> 終止宿主程序。
如果 <code>code</code> 為 <b>true</b>，
返回的狀態碼是 <code>EXIT_SUCCESS</code>；
如果 <code>code</code> 為 <b>false</b>，
返回的狀態碼是 <code>EXIT_FAILURE</code>；
如果 <code>code</code> 是一個數字，
返回的狀態碼就是這個數字。
<code>code</code> 的默認值為 <b>true</b>。


<p>
如果第二個可選參數 <code>close</code> 為真，
在退出前關閉 Lua 狀態機。



<p>
<hr><h3><a name="pdf-os.getenv"><code>os.getenv (varname)</code></a></h3>


<p>
返回進程環境變量 <code>varname</code> 的值，
如果該變量未定義，返回 <b>nil</b> 。




<p>
<hr><h3><a name="pdf-os.remove"><code>os.remove (filename)</code></a></h3>


<p>
刪除指定名字的文件（在 POSIX 系統上可以是一個空目錄）
如果函式失敗，返回 <b>nil</b>
加一個錯誤描述串及出錯碼。



<p>
<hr><h3><a name="pdf-os.rename"><code>os.rename (oldname, newname)</code></a></h3>


<p>
將名字為 <code>oldname</code> 的文件或目錄更名為 <code>newname</code>。
如果函式失敗，返回 <b>nil</b>
加一個錯誤描述串及出錯碼。



<p>
<hr><h3><a name="pdf-os.setlocale"><code>os.setlocale (locale [, category])</code></a></h3>


<p>
設置程序的當前區域。
<code>locale</code> 是一個區域設置的系統相關字串；
<code>category</code> 是一個描述有改變哪個分類的可選字串：
<code>"all"</code>，<code>"collate"</code>， <code>"ctype"</code>，
<code>"monetary"</code>， <code>"numeric"</code>， 或 <code>"time"</code>；
默認的分類為 <code>"all"</code>。
此函式返回新區域的名字。
如果請求未被獲准，返回 <b>nil</b> 。


<p>
當 <code>locale</code> 是一個空串，
當前區域被設置為一個在實現中定義好的本地區域。
當 <code>locale</code> 為字串 "<code>C</code>"，
當前區域被設置為標準 C 區域。


<p>
當第一個參數為 <b>nil</b> 時，
此函式僅返回當前區域指定分類的名字。


<p>
由於這個函式依賴 C 函式 <code>setlocale</code>，
它可能並非線程安全的。



<p>
<hr><h3><a name="pdf-os.time"><code>os.time ([table])</code></a></h3>


<p>
當不傳參數時，返回當前時刻。
如果傳入一張表，就返回由這張表表示的時刻。
這張表必須包含域 <code>year</code>，<code>month</code>，及 <code>day</code>；
可以包含有　<code>hour</code> （默認為 12 ），
<code>min</code> （默認為 0），
<code>sec</code> （默認為 0），以及 <code>isdst</code> （默認為 <b>nil</b>）。
關於這些域的詳細描述，參見 <a href="#pdf-os.date"><code>os.date</code></a> 函式。


<p>
返回值是一個含義由你的系統決定的數字。
在 POSIX，Windows，和其它一些系統中，
這個數字統計了從指定時間（"epoch"）開始經歷的秒數。
對於另外的系統，其含義未定義，
你只能把 <code>time</code> 的返回數字用於
<a href="#pdf-os.date"><code>os.date</code></a> 和 <a href="#pdf-os.difftime"><code>os.difftime</code></a>
的參數。



<p>
<hr><h3><a name="pdf-os.tmpname"><code>os.tmpname ()</code></a></h3>


<p>
返回一個可用於臨時文件的文件名字串。
這個文件在使用前必須顯式打開，不再使用時需要顯式刪除。

<p>
在 POSIX 系統上，
這個函式會以此文件名創建一個文件以迴避安全風險。
（別人可能未經允許在獲取到這個文件名到創建該文件之間的時刻創建此文件。）
你依舊需要在使用它的時候先打開，並最後刪除（即使你沒使用到）。

<p>
只有有可能，你更應該使用
<a href="#pdf-io.tmpfile"><code>io.tmpfile</code></a>，
因為該文件可以在程序結束時自動刪除。




<h2>6.10 &ndash; <a name="6.10">調試庫</a></h2>

<p>
這個庫提供了 Lua 程序調試接口（<a href="#4.9">&sect;4.9</a>）的功能。
其中一些函式違反了 Lua 代碼的基本假定
（例如，不會從函式之外訪問函式的局部變量；
用戶數據的元表不會被 Lua 代碼修改；
Lua 程序不會崩潰），
因此它們有可能危害到其它代碼的安全性。
此外，庫裡的一些函式可能運行的很慢。


<p>
這個庫裡的所有函式都提供在表 <a name="pdf-debug"><code>debug</code></a> 內。
所有操作線程的函式，可選的第一個參數都是針對的線程。
默認值永遠是當前線程。


<p>
<hr><h3><a name="pdf-debug.debug"><code>debug.debug ()</code></a></h3>


<p>
進入一個用戶交互模式，運行用戶輸入的每個字串。
使用簡單的命令以及其它調試設置，用戶可以檢閱全局變量和局部變量，
改變變量的值，計算一些表達式，等等。
輸入一行僅包含 <code>cont</code> 的字串將結束這個函式，
這樣調用者就可以繼續向下運行。


<p>
注意，<code>debug.debug</code> 輸入的命令在文法上並沒有內嵌到任何函式中，
因此不能直接去訪問局部變量。



<p>
<hr><h3><a name="pdf-debug.gethook"><code>debug.gethook ([thread])</code></a></h3>


<p>
返回三個表示線程鉤子設置的值：
當前鉤子函式，當前鉤子掩碼，當前鉤子計數
（<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> 設置的那些）。



<p>
<hr><h3><a name="pdf-debug.getinfo"><code>debug.getinfo ([thread,] f [, what])</code></a></h3>


<p>
返回關於一個函式信息的表。
你可以直接提供該函式，
也可以用一個數字 <code>f</code> 表示該函式。
數字 <code>f</code> 表示運行在指定線程的調用堆疊對應層次上的函式：
0 層表示當前函式（<code>getinfo</code> 自身）；
1 層表示調用 <code>getinfo</code> 的函式
（除非是尾調用，這種情況不計入堆疊）；等等。
如果 <code>f</code> 是一個比活動函式數量還大的數字，
<code>getinfo</code> 返回 <b>nil</b>。


<p>
只有字串 <code>what</code> 中有描述要填充哪些項，
返回的表可以包含 <a href="#lua_getinfo"><code>lua_getinfo</code></a> 能返回的所有項。
<code>what</code> 默認是返回提供的除合法行號表外的所有信息。
對於選項 '<code>f</code>' ，會在可能的情況下，增加
<code>func</code> 域保存函式自身。
對於選項 '<code>L</code>' ，會在可能的情況下，增加
<code>activelines</code> 域保存合法行號表。


<p>
例如,表達式 <code>debug.getinfo(1,"n")</code>
返回帶有當前函式名字信息的表（如果找的到名字的話），
表達式 <code>debug.getinfo(print)</code> 
返回關於 <a href="#pdf-print"><code>print</code></a> 函式的
包含有所有能提供信息的表。


<p>
<hr><h3><a name="pdf-debug.getlocal"><code>debug.getlocal ([thread,] f, local)</code></a></h3>


<p>
此函式返回在堆疊的 <code>f</code> 層處函式的索引為 <code>local</code> 的局部變量
的名字和值。
這個函式不僅用於訪問顯式定義的局部變量，也包括形參、臨時變量等。


<p>
第一個形參或是定義的第一個局部變量的索引為 1 ，
然後遵循在代碼中定義次序，以次類推。
其中只計算函式當前作用域的活動變量。
負索引指可變參數；
-1 指第一個可變參數。
如果該索引處沒有變量，函式返回 <b>nil</b>。
若指定的層次越界，拋出錯誤。
（你可以調用 <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> 來檢查層次是否合法。）


<p>
以 '<code>(</code>' （開括號）打頭的變量名表示沒有名字的變量
（比如是循環控制用到的控制變量，
或是去除了調試信息的代碼塊）。


<p>
參數 <code>f</code> 也可以是一個函式。
這種情況下，<code>getlocal</code> 僅返回函式形參的名字。




<p>
<hr><h3><a name="pdf-debug.getmetatable"><code>debug.getmetatable (value)</code></a></h3>


<p>
返回給定 <code>value</code> 的元表。
若其沒有元表則返回 <b>nil</b> 。




<p>
<hr><h3><a name="pdf-debug.getregistry"><code>debug.getregistry ()</code></a></h3>


<p>
返回註冊表（參見 <a href="#4.5">&sect;4.5</a>）。




<p>
<hr><h3><a name="pdf-debug.getupvalue"><code>debug.getupvalue (f, up)</code></a></h3>


<p>
此函式返回函式 <code>f</code> 的第 <code>up</code> 個上值的名字和值。
如果該函式沒有那個上值，返回 <b>nil</b> 。


<p>
以 '<code>(</code>' （開括號）打頭的變量名表示沒有名字的變量
（去除了調試信息的代碼塊）。



<p>
<hr><h3><a name="pdf-debug.getuservalue"><code>debug.getuservalue (u)</code></a></h3>


<p>
返回關聯在 <code>u</code> 上的 Lua 值。
如果 <code>u</code> 並非用戶數據，返回 <b>nil</b>。




<p>
<hr><h3><a name="pdf-debug.sethook"><code>debug.sethook ([thread,] hook, mask [, count])</code></a></h3>


<p>
將一個函式作為鉤子函式設入。
字串 <code>mask</code> 以及數字 <code>count</code> 決定了鉤子將在何時調用。
掩碼是由下列字符組合成的字串，每個字符有其含義：

<ul>
<li><b>'<code>c</code>': </b> 每當 Lua 調用一個函式時，調用鉤子；</li>
<li><b>'<code>r</code>': </b> 每當 Lua 從一個函式內返回時，調用鉤子；</li>
<li><b>'<code>l</code>': </b> 每當 Lua 進入新的一行時，調用鉤子。</li>
</ul><p>
此外，
傳入一個不為零的 <code>count</code> ，
鉤子將在每運行 <code>count</code> 條指令時調用。


<p>
如果不傳入參數，
<a href="#pdf-debug.sethook"><code>debug.sethook</code></a> 關閉鉤子。


<p>
當鉤子被調用時，
第一個參數是觸發這次調用的事件：
<code>"call"</code> （或 <code>"tail call"</code>），
<code>"return"</code>，
<code>"line"</code>， <code>"count"</code>。
對於行事件，
鉤子的第二個參數是新的行號。
在鉤子內，你可以調用 <code>getinfo</code> ，指定第 2 層，
來獲得正在運行的函式的詳細信息
（0 層指 <code>getinfo</code> 函式，
1 層指鉤子函式）。


<p>
<hr><h3><a name="pdf-debug.setlocal"><code>debug.setlocal ([thread,] level, local, value)</code></a></h3>


<p>
這個函式將 <code>value</code> 賦給
堆疊上第 <code>level</code> 層函式的第 <code>local</code> 個局部變量。
如果沒有那個變量，函式返回 <b>nil</b> 。
如果 <code>level</code> 越界，拋出一個錯誤。
（你可以調用 <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> 來檢查層次是否合法。）
否則，它返回局部變量的名字。


<p>
關於變量索引和名字，參見 <a href="#pdf-debug.getlocal"><code>debug.getlocal</code></a>。



<p>
<hr><h3><a name="pdf-debug.setmetatable"><code>debug.setmetatable (value, table)</code></a></h3>


<p>
將 <code>value</code> 的元表設為 <code>table</code> （可以是 <b>nil</b>）。
返回 <code>value</code>。




<p>
<hr><h3><a name="pdf-debug.setupvalue"><code>debug.setupvalue (f, up, value)</code></a></h3>


<p>
這個函式將 <code>value</code> 設為函式 <code>f</code> 的第
<code>up</code> 個上值。
如果函式沒有那個上值，返回 <b>nil</b>
否則，返回該上值的名字。



<p>
<hr><h3><a name="pdf-debug.setuservalue"><code>debug.setuservalue (udata, value)</code></a></h3>


<p>
將 <code>value</code> 設為 <code>udata</code> 的關聯值。
<code>udata</code> 必須是一個完全用戶數據。


<p>
返回 <code>udata</code>。




<p>
<hr><h3><a name="pdf-debug.traceback"><code>debug.traceback ([thread,] [message [, level]])</code></a></h3>


<p>
如果 <code>message</code> 有，且不是字串或 <b>nil</b>，
函式不做任何處理直接返回 <code>message</code>。
否則，它返回調用堆疊的堆疊回溯信息。
字串可選項 <code>message</code> 被添加在堆疊回溯信息的開頭。
數字可選項 <code>level</code> 指明從堆疊的哪一層開始回溯
（默認為 1 ，即調用 <code>traceback</code> 的那裡）。




<p>
<hr><h3><a name="pdf-debug.upvalueid"><code>debug.upvalueid (f, n)</code></a></h3>


<p>
返回指定函式第 <code>n</code>
個上值的唯一標識符（一個輕量用戶數據）。


<p>
這個唯一標識符可以讓程序檢查兩個不同的 Closure 是否共享了上值。
若 Lua Closure 之間共享的是同一個上值
（即指向一個外部局部變量），會返回相同的標識符。



<p>
<hr><h3><a name="pdf-debug.upvaluejoin"><code>debug.upvaluejoin (f1, n1, f2, n2)</code></a></h3>


<p>
讓 Lua Closure <code>f1</code> 的第 <code>n1</code> 個上值
引用  Lua Closure <code>f2</code> 的第 <code>n2</code> 個上值。






<h1>7 &ndash; <a name="7">獨立版 Lua</a></h1>

<p>
雖然 Lua 被設計成一門擴展式語言，用於嵌入一個宿主程序。
但經常也會被當成獨立語言使用。
獨立版的 Lua 語言解釋器隨標準包發佈，就叫 <code>lua</code>。
獨立版解釋器保留了所有的標準庫及調試庫。
其命令行用法為：

<pre>
     lua [options] [script [args]]
</pre><p>
選項有：

<ul>
<li><b><code>-e <em>stat</em></code>: </b> 執行一段字串 <em>stat</em> ；</li>
<li><b><code>-l <em>mod</em></code>: </b> 「請求模塊」 <em>mod</em> ；</li>
<li><b><code>-i</code>: </b> 在運行完 <em>腳本</em> 後進入交互模式；</li>
<li><b><code>-v</code>: </b> 打印版本信息；</li>
<li><b><code>-E</code>: </b> 忽略環境變量；</li>
<li><b><code>--</code>: </b> 中止對後面選項的處理；</li>
<li><b><code>-</code>: </b> 把 <code>stdin</code> 當作一個文件運行，並中止對後面選項的處理。</li>
</ul><p>
在處理完選項後，<code>lua</code> 運行指定的 <em>腳本</em>。
如果不帶參數調用，
在標準輸入（<code>stdin</code>）是終端時，<code>lua</code> 的行為和 <code>lua -v -i</code> 相同。
否則相當於 <code>lua -</code> 。


<p>
如果調用時不帶選項 <code>-E</code>，
解釋器會在運行任何參數前，檢查環境變量 <a name="pdf-LUA_INIT_5_3"><code>LUA_INIT_5_3</code></a>
（或在版本名未定義時，檢查 <a name="pdf-LUA_INIT"><code>LUA_INIT</code></a> ）。
如果該變量記憶體格式為 <code>@<em>filename</em></code>，
<code>lua</code> 執行該文件。
否則，<code>lua</code> 執行該字串。


<p>
如果調用時有選項 <code>-E</code>，
除了忽略 <code>LUA_INIT</code> 外，
Lua 還忽略 <code>LUA_PATH</code> 與 <code>LUA_CPATH</code> 的值。
將 <a href="#pdf-package.path"><code>package.path</code></a> 和 <a href="#pdf-package.cpath"><code>package.cpath</code></a>
的值設為定義在 <code>luaconf.h</code> 中的默認路徑。

<p>
除 <code>-i</code> 與 <code>-E</code> 外所有的選項都按次序處理。
例如，這樣調用

<pre>
     $ lua -e'a=1' -e 'print(a)' script.lua
</pre><p>
將先把 <code>a</code> 設為 1，然後打印 <code>a</code> 的值，
最後運行文件 <code>script.lua</code> 並不帶參數。
（這裡的 <code>$</code> 是命令行提示。你的命令行提示可能不一樣。）


<p>
在運行任何代碼前，
<code>lua</code> 會將所有命令行傳入的參數放到一張全局表 <code>arg</code> 中。
腳本的名字放在索引 0 的地方，
腳本名後緊跟的第一個參數在索引 1 處，依次類推。
在腳本名前面的任何參數
（即解釋器的名字以及各選項）
放在負索引處。
例如，調用

<pre>
     $ lua -la b.lua t1 t2
</pre><p>
這張表是這樣的：

<pre>
     arg = { [-2] = "lua", [-1] = "-la",
             [0] = "b.lua",
             [1] = "t1", [2] = "t2" }
</pre><p>
如果調用中沒提供腳本名，
解釋器的名字就放在索引 0 處，後面接著其它參數。
例如，調用

<pre>
     $ lua -e "print(arg[1])"
</pre><p>
將打印出 "<code>-e</code>" 。
如果提供了腳本名，
就以 <code>arg[1]</code>, &middot;&middot;&middot;, <code>arg[#arg]</code>
為參數調用腳本。
（和 Lua 所有的代碼塊一樣，
腳本被編譯成一個可變參數函式。）


<p>
在交互模式下，
Lua 不斷的顯示提示符，並等待下一行輸入。
一旦讀到一行，
首先試著把這行解釋為一個表達式。
如果成功解釋，就打印表達式的值。
否則，將這行解釋為語句。
如果你寫了一行未完成的語句，
解釋器會用一個不同的提示符來等待你寫完。


<p>
當腳本中出現了未保護的錯誤，
解釋器向標準錯誤流報告錯誤。
如果錯誤對象並非一個字串，但是卻有元方法
<code>__tostring</code> 的話，
解釋器會調用這個元方法生成最終的消息。
否則，解釋器將錯誤對像轉換為一個字串，並把堆疊回溯信息加在前面。


<p>
如果正常結束運行，
解釋器會關閉主 Lua 狀態機
（參見 <a href="#lua_close"><code>lua_close</code></a>）。
腳本可以通過調用
<a href="#pdf-os.exit"><code>os.exit</code></a>
來結束，以迴避這個步驟。


<p>
為了讓 Lua 可以用於 Unix 系統的腳本解釋器。
獨立版解釋器會忽略代碼塊的以 <code>#</code> 打頭的第一行。
因此，Lua 腳本可以通過
<code>chmod +x</code> 以及 <code>#!</code> 形式變成一個可執行文件。
類似這樣
<pre>
     #!/usr/local/bin/lua
</pre><p>
（當然，
Lua 解釋器的位置對於你的機器來說可能不一樣。
如果 <code>lua</code> 在你的 <code>PATH</code> 中，
寫成
<pre>
     #!/usr/bin/env lua
</pre><p>
更為通用。）


<h1>8 &ndash; <a name="8">與之前版本不兼容的地方</a></h1>

<p>
這裡我們列出了把程序從 Lua 5.2 遷移到 Lua 5.3 會碰到的不兼容的地方。
你可以在編譯 Lua 時定義一些恰當的選項（參見文件 <code>luaconf.h</code>），
來迴避一些不兼容性。
然而，這些兼容選項以後會移除。

<p>
Lua 的版本更替總是會修改一些 C API 並涉及源代碼的改變。
例如一些常量的數字值，用宏來實現一些函式。
因此，你不能假設在不同的 Lua 版本間可以做到二進制兼容。
當你使用新版時，一定要將使用了 Lua API 的客戶程序重新編譯。


<p>
同樣，Lua 版本更替還會改變預編譯代碼塊的內部呈現方式；
在不同的 Lua 版本間，預編譯代碼塊不兼容。

<p>
官方發佈版的標準路徑也可能隨版本變化。


<h2>8.1 &ndash; <a name="8.1">語言的變更</a></h2>
<ul>

<li>
Lua 5.2 到 Lua 5.3 最大的變化是引入了數字的整數子型別。
雖然這個變化不會影響「一般」計算，
但一些計算
（主要是涉及溢出的）
會得到不同的結果。


<p>
你可以通過把數字都強制轉換為浮點數來消除差異
（在 Lua 5.2 中，所有的數字都是浮點數）。
比如你可以將所有的常量都以 <code>.0</code> 結尾，
或是使用 <code>x = x + 0.0</code> 來轉換一個變量。
（這條建議僅用於偶爾快速解決一些不兼容問題；
這不是一條好的編程準則。
好好寫程序的話，你應該在需要使用浮點數的地方用浮點數，
需要整數的地方用整數。）
</li>

<li>
把浮點數轉為字串的地方，現在都對等於整數的浮點數加了 <code>.0</code> 後綴。
（例如，浮點數 2.0 會被打印成 <code>2.0</code>，
而不是 <code>2</code>。）
如果你需要定制數字的格式，就必須顯式的格式化它們。


<p>
（準確說這個不是兼容性問題，
因為 Lua 並沒有規定數字如何格式化成字串，
但一些程序假定遵循某種特別的格式。）
</li>

<li>
分代垃圾收集器沒有了。
（它是 Lua 5.2 中的一個試驗性特性。）
</li>

</ul>




<h2>8.2 &ndash; <a name="8.2">庫的變更</a></h2>
<ul>

<li>
<code>bit32</code> 庫廢棄了。
使用一個外部兼容庫很容易，
不過最好直接用對應的位操作符來替換它。
（注意 <code>bit32</code> 只能針對 32 位整數運算，
而標準 Lua 中的位操作可以用於 64 位整數。）
</li>

<li>
表處理庫現在在讀寫其中的元素時會考慮元方法。
</li>

<li>
<a href="#pdf-ipairs"><code>ipairs</code></a> 這個迭代器也會考慮元方法，而 <code>__ipairs</code> 元方法被廢棄了。
</li>

<li>
<a href="#pdf-io.read"><code>io.read</code></a> 的選項名不再用 '<code>*</code>' 打頭。
但出於兼容性考慮，Lua 會繼續忽略掉這個字符。
</li>

<li>
數學庫中的這些函式廢棄了：
<code>atan2</code>， <code>cosh</code>， <code>sinh</code>， <code>tanh</code>， <code>pow</code>，
<code>frexp</code>， 以及 <code>ldexp</code> 。
你可以用 <code>x^y</code> 替換 <code>math.pow(x,y)；
你可以用 <code>math.atan</code> 替換 <code>math.atan2</code>，前者現在可以接收一或兩個參數；
你可以用 <code>x * 2.0^exp</code> 替換 <code>math.ldexp(x,exp)</code>。
若用到其它操作，你可以寫一個擴展庫，或在 Lua 中實現它們。
</li>

<li>
<a href="#pdf-require"><code>require</code></a> 在搜索 C 加載器時處理版本號的方式有所變化。
現在，版本號應該跟在模塊名後（其它大多數工具都是這樣幹的）。
出於兼容性考慮，如果使用新格式找不到加載器的話，搜索器依然會嘗試舊格式。
（Lua 5.2 已經是這樣處理了，但是並沒有寫在文檔裡。）
</li>

</ul>




<h2>8.3 &ndash; <a name="8.3">API 的變更</a></h2>


<ul>

<li>
延續函式現在接收原來用
<code>lua_getctx</code> 獲取的參數，
所以 <code>lua_getctx</code> 就去掉了。
按需要改寫你的代碼。
</li>

<li>
函式 <a href="#lua_dump"><code>lua_dump</code></a> 有了一個額外的參數 <code>strip</code>。
如果想和之前的行為一致，這個值傳 0 。
</li>

<li>
用於傳入傳出無符號整數的函式
（<code>lua_pushunsigned</code>， <code>lua_tounsigned</code>， <code>lua_tounsignedx</code>，
<code>luaL_checkunsigned</code>， <code>luaL_optunsigned</code>）
都廢棄了。
直接從有符號版做型別轉換。
</li>

<li>
處理輸入非默認整數型別的宏
（<code>luaL_checkint</code>， <code>luaL_optint</code>， <code>luaL_checklong</code>， <code>luaL_optlong</code>）
廢棄掉了。
直接使用 <a href="#lua_Integer"><code>lua_Integer</code></a> 加一個型別轉換就可以替代
（或是只要有可能，就在你的代碼中使用 <a href="#lua_Integer"><code>lua_Integer</code></a>）。
</li>

</ul>




<h1>9 &ndash; <a name="9">Lua 的完整語法</a></h1>

<p>
這是一份採用擴展 BNF 描述的 Lua 完整語法。
在擴展 BNF 中，
{A} 表示 0 或多個 A ，
[A] 表示一個可選的 A 。
（操作符優先級，參見 <a href="#3.4.8">&sect;3.4.8</a>；
對於最終符號，名字，數字，字串字面量的解釋，參見 <a href="#3.1">&sect;3.1</a>。）




<pre>

	chunk ::= block

	block ::= {stat} [retstat]

	stat ::=  &lsquo;<b>;</b>&rsquo; | 
		 varlist &lsquo;<b>=</b>&rsquo; explist | 
		 functioncall | 
		 label | 
		 <b>break</b> | 
		 <b>goto</b> Name | 
		 <b>do</b> block <b>end</b> | 
		 <b>while</b> exp <b>do</b> block <b>end</b> | 
		 <b>repeat</b> block <b>until</b> exp | 
		 <b>if</b> exp <b>then</b> block {<b>elseif</b> exp <b>then</b> block} [<b>else</b> block] <b>end</b> | 
		 <b>for</b> Name &lsquo;<b>=</b>&rsquo; exp &lsquo;<b>,</b>&rsquo; exp [&lsquo;<b>,</b>&rsquo; exp] <b>do</b> block <b>end</b> | 
		 <b>for</b> namelist <b>in</b> explist <b>do</b> block <b>end</b> | 
		 <b>function</b> funcname funcbody | 
		 <b>local</b> <b>function</b> Name funcbody | 
		 <b>local</b> namelist [&lsquo;<b>=</b>&rsquo; explist] 

	retstat ::= <b>return</b> [explist] [&lsquo;<b>;</b>&rsquo;]

	label ::= &lsquo;<b>::</b>&rsquo; Name &lsquo;<b>::</b>&rsquo;

	funcname ::= Name {&lsquo;<b>.</b>&rsquo; Name} [&lsquo;<b>:</b>&rsquo; Name]

	varlist ::= var {&lsquo;<b>,</b>&rsquo; var}

	var ::=  Name | prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; | prefixexp &lsquo;<b>.</b>&rsquo; Name 

	namelist ::= Name {&lsquo;<b>,</b>&rsquo; Name}

	explist ::= exp {&lsquo;<b>,</b>&rsquo; exp}

	exp ::=  <b>nil</b> | <b>false</b> | <b>true</b> | Numeral | LiteralString | &lsquo;<b>...</b>&rsquo; | functiondef | 
		 prefixexp | tableconstructor | exp binop exp | unop exp 

	prefixexp ::= var | functioncall | &lsquo;<b>(</b>&rsquo; exp &lsquo;<b>)</b>&rsquo;

	functioncall ::=  prefixexp args | prefixexp &lsquo;<b>:</b>&rsquo; Name args 

	args ::=  &lsquo;<b>(</b>&rsquo; [explist] &lsquo;<b>)</b>&rsquo; | tableconstructor | LiteralString 

	functiondef ::= <b>function</b> funcbody

	funcbody ::= &lsquo;<b>(</b>&rsquo; [parlist] &lsquo;<b>)</b>&rsquo; block <b>end</b>

	parlist ::= namelist [&lsquo;<b>,</b>&rsquo; &lsquo;<b>...</b>&rsquo;] | &lsquo;<b>...</b>&rsquo;

	tableconstructor ::= &lsquo;<b>{</b>&rsquo; [fieldlist] &lsquo;<b>}</b>&rsquo;

	fieldlist ::= field {fieldsep field} [fieldsep]

	field ::= &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo; &lsquo;<b>=</b>&rsquo; exp | Name &lsquo;<b>=</b>&rsquo; exp | exp

	fieldsep ::= &lsquo;<b>,</b>&rsquo; | &lsquo;<b>;</b>&rsquo;

	binop ::=  &lsquo;<b>+</b>&rsquo; | &lsquo;<b>-</b>&rsquo; | &lsquo;<b>*</b>&rsquo; | &lsquo;<b>/</b>&rsquo; | &lsquo;<b>//</b>&rsquo; | &lsquo;<b>^</b>&rsquo; | &lsquo;<b>%</b>&rsquo; | 
		 &lsquo;<b>&amp;</b>&rsquo; | &lsquo;<b>~</b>&rsquo; | &lsquo;<b>|</b>&rsquo; | &lsquo;<b>&gt;&gt;</b>&rsquo; | &lsquo;<b>&lt;&lt;</b>&rsquo; | &lsquo;<b>..</b>&rsquo; | 
		 &lsquo;<b>&lt;</b>&rsquo; | &lsquo;<b>&lt;=</b>&rsquo; | &lsquo;<b>&gt;</b>&rsquo; | &lsquo;<b>&gt;=</b>&rsquo; | &lsquo;<b>==</b>&rsquo; | &lsquo;<b>~=</b>&rsquo; | 
		 <b>and</b> | <b>or</b>

	unop ::= &lsquo;<b>-</b>&rsquo; | <b>not</b> | &lsquo;<b>#</b>&rsquo; | &lsquo;<b>~</b>&rsquo;

</pre>

<p>






<HR>
<SMALL CLASS="footer">
最後更新時間：
2015年1月18日19:54
</SMALL>

</body></html>

